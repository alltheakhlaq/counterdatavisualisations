import {
  require_solid_namespace
} from "./chunk-BLG6VLQO.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@frogcat/ttl2jsonld/ttl2jsonld.js
var require_ttl2jsonld = __commonJS({
  "node_modules/@frogcat/ttl2jsonld/ttl2jsonld.js"(exports, module2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define([], factory);
      } else if (typeof module2 === "object" && module2.exports) {
        module2.exports = factory();
      } else {
        root.ttl2jsonld = factory();
      }
    })(exports, function() {
      "use strict";
      function peg$subclass(child, parent) {
        function ctor() {
          this.constructor = child;
        }
        ctor.prototype = parent.prototype;
        child.prototype = new ctor();
      }
      function peg$SyntaxError(message, expected, found, location) {
        this.message = message;
        this.expected = expected;
        this.found = found;
        this.location = location;
        this.name = "SyntaxError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, peg$SyntaxError);
        }
      }
      peg$subclass(peg$SyntaxError, Error);
      peg$SyntaxError.buildMessage = function(expected, found) {
        var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
          },
          "class": function(expectation) {
            var escapedParts = "", i;
            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
            }
            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },
          any: function(expectation) {
            return "any character";
          },
          end: function(expectation) {
            return "end of input";
          },
          other: function(expectation) {
            return expectation.description;
          }
        };
        function hex(ch) {
          return ch.charCodeAt(0).toString(16).toUpperCase();
        }
        function literalEscape(s) {
          return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
          });
        }
        function classEscape(s) {
          return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
          }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
          });
        }
        function describeExpectation(expectation) {
          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
        }
        function describeExpected(expected2) {
          var descriptions = new Array(expected2.length), i, j;
          for (i = 0; i < expected2.length; i++) {
            descriptions[i] = describeExpectation(expected2[i]);
          }
          descriptions.sort();
          if (descriptions.length > 0) {
            for (i = 1, j = 1; i < descriptions.length; i++) {
              if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
              }
            }
            descriptions.length = j;
          }
          switch (descriptions.length) {
            case 1:
              return descriptions[0];
            case 2:
              return descriptions[0] + " or " + descriptions[1];
            default:
              return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
          }
        }
        function describeFound(found2) {
          return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
        }
        return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
      };
      function peg$parse(input, options) {
        options = options !== void 0 ? options : {};
        var peg$FAILED = {}, peg$startRuleFunctions = { turtleDoc: peg$parseturtleDoc }, peg$startRuleFunction = peg$parseturtleDoc, peg$c0 = function(statements) {
          var jsonld = context.toJSON();
          jsonld["@graph"] = [];
          statements.filter((a) => Array.isArray(a)).forEach((a) => {
            a.forEach((b) => {
              jsonld["@graph"].push(b);
            });
          });
          if (jsonld["@graph"].length === 1) {
            Object.assign(jsonld, jsonld["@graph"][0]);
            delete jsonld["@graph"];
          }
          return jsonld;
        }, peg$c1 = "\uFEFF", peg$c2 = peg$literalExpectation("\uFEFF", false), peg$c3 = ".", peg$c4 = peg$literalExpectation(".", false), peg$c5 = function(a) {
          return a;
        }, peg$c6 = "#", peg$c7 = peg$literalExpectation("#", false), peg$c8 = /^[^\n]/, peg$c9 = peg$classExpectation(["\n"], true, false), peg$c10 = "\n", peg$c11 = peg$literalExpectation("\n", false), peg$c12 = function(a) {
          return a.join("");
        }, peg$c13 = "@prefix", peg$c14 = peg$literalExpectation("@prefix", false), peg$c15 = function(a, b) {
          context.addPrefix(a === "" ? "0" : a, b);
          return {};
        }, peg$c16 = "@base", peg$c17 = peg$literalExpectation("@base", false), peg$c18 = function(a) {
          context.addBase(a);
          return {};
        }, peg$c19 = /^[Bb]/, peg$c20 = peg$classExpectation(["B", "b"], false, false), peg$c21 = /^[Aa]/, peg$c22 = peg$classExpectation(["A", "a"], false, false), peg$c23 = /^[Ss]/, peg$c24 = peg$classExpectation(["S", "s"], false, false), peg$c25 = /^[Ee]/, peg$c26 = peg$classExpectation(["E", "e"], false, false), peg$c27 = /^[Pp]/, peg$c28 = peg$classExpectation(["P", "p"], false, false), peg$c29 = /^[Rr]/, peg$c30 = peg$classExpectation(["R", "r"], false, false), peg$c31 = /^[Ff]/, peg$c32 = peg$classExpectation(["F", "f"], false, false), peg$c33 = /^[Ii]/, peg$c34 = peg$classExpectation(["I", "i"], false, false), peg$c35 = /^[Xx]/, peg$c36 = peg$classExpectation(["X", "x"], false, false), peg$c37 = function(s, p) {
          var x = {};
          if (typeof s === "string" && s !== "[]") x["@id"] = s;
          else if (typeof s === "object") Object.assign(x, s);
          if (p) Object.assign(x, p);
          return [x];
        }, peg$c38 = function(s, p) {
          var x = {};
          if (s) Object.assign(x, s);
          if (p) Object.assign(x, p);
          return [x];
        }, peg$c39 = ";", peg$c40 = peg$literalExpectation(";", false), peg$c41 = function(a, b, e, f) {
          var x = {};
          x[e] = f;
          return x;
        }, peg$c42 = function(a, b, d) {
          return d;
        }, peg$c43 = function(a, b, c) {
          var x = {};
          c.unshift(createObject(a, b));
          c.forEach((t) => {
            if (!t) return;
            Object.keys(t).forEach((key) => {
              t[key].forEach((val) => {
                if (key === "@type" && val["@id"] !== void 0) val = val["@id"];
                if (x[key] === void 0) x[key] = val;
                else if (Array.isArray(x[key])) x[key].push(val);
                else x[key] = [x[key], val];
              });
            });
          });
          return x;
        }, peg$c44 = ",", peg$c45 = peg$literalExpectation(",", false), peg$c46 = function(a, c) {
          return c;
        }, peg$c47 = function(a, b) {
          b.unshift(a);
          return b;
        }, peg$c48 = "a", peg$c49 = peg$literalExpectation("a", false), peg$c50 = function() {
          return "@type";
        }, peg$c51 = function(a) {
          return expandList(a, true);
        }, peg$c52 = function(a) {
          return expandList(a, false);
        }, peg$c53 = function(a) {
          return a === "[]" ? {} : { "@id": a };
        }, peg$c54 = function(a) {
          return { "@id": a };
        }, peg$c55 = "[", peg$c56 = peg$literalExpectation("[", false), peg$c57 = "]", peg$c58 = peg$literalExpectation("]", false), peg$c59 = "(", peg$c60 = peg$literalExpectation("(", false), peg$c61 = ")", peg$c62 = peg$literalExpectation(")", false), peg$c63 = function(a) {
          return { "@list": a };
        }, peg$c64 = function(a, b) {
          return { "@value": a, "@language": b };
        }, peg$c65 = "^^", peg$c66 = peg$literalExpectation("^^", false), peg$c67 = function(a, b) {
          if (b === "http://www.w3.org/2001/XMLSchema#boolean" && a === "true") return true;
          if (b === "http://www.w3.org/2001/XMLSchema#boolean" && a === "false") return false;
          if (b === "http://www.w3.org/2001/XMLSchema#integer") return parseInt(a);
          if (b === "http://www.w3.org/2001/XMLSchema#double") return parseFloat(a);
          const uri = context.resolve(b, true);
          if (uri) {
            const prefix = b.split(":")[0];
            if (uri === "http://www.w3.org/2001/XMLSchema#boolean" && a === "true") {
              context.decrement(prefix);
              return true;
            }
            if (uri === "http://www.w3.org/2001/XMLSchema#boolean" && a === "false") {
              context.decrement(prefix);
              return false;
            }
            if (uri === "http://www.w3.org/2001/XMLSchema#integer") {
              context.decrement(prefix);
              return parseInt(a);
            }
            if (uri === "http://www.w3.org/2001/XMLSchema#double") {
              context.decrement(prefix);
              return parseFloat(a);
            }
          }
          return { "@value": a, "@type": b };
        }, peg$c68 = "true", peg$c69 = peg$literalExpectation("true", false), peg$c70 = function() {
          return true;
        }, peg$c71 = "false", peg$c72 = peg$literalExpectation("false", false), peg$c73 = function() {
          return false;
        }, peg$c74 = function(a) {
          return a + ":";
        }, peg$c75 = "<", peg$c76 = peg$literalExpectation("<", false), peg$c77 = /^[^\0- <>"{}|\^`\\]/, peg$c78 = peg$classExpectation([["\0", " "], "<", ">", '"', "{", "}", "|", "^", "`", "\\"], true, false), peg$c79 = ">", peg$c80 = peg$literalExpectation(">", false), peg$c81 = function(a) {
          const decoded = a.map((s) => {
            if (65536 <= s.codePointAt(0) && s.codePointAt(0) <= 983039) return "a";
            if (s.length === 1) return s;
            if (s.length === 6) return String.fromCharCode("0x" + s.substring(2));
            if (s.length === 10) return String.fromCodePoint("0x" + s.substring(2));
            return s;
          }).join("");
          if (decoded.match(/^[^\u0000-\u0020<>"{}|^`\\]*$/)) {
            var join2 = a.join("");
            try {
              return context.resolve(join2);
            } catch (e) {
              error("Invalid IRIREF " + join2);
            }
          } else error("Invalid IRIREF " + a.join("") + " / " + decoded);
        }, peg$c82 = ":", peg$c83 = peg$literalExpectation(":", false), peg$c84 = function(a) {
          a = a || "0";
          if (context.hasPrefix(a) === false)
            error("undefined prefix " + a);
          return a;
        }, peg$c85 = function(a) {
          return a || "";
        }, peg$c86 = function(a, b) {
          context.increment(a);
          return context.resolve(a + ":" + b);
        }, peg$c87 = "_:", peg$c88 = peg$literalExpectation("_:", false), peg$c89 = /^[0-9]/, peg$c90 = peg$classExpectation([["0", "9"]], false, false), peg$c91 = "@", peg$c92 = peg$literalExpectation("@", false), peg$c93 = /^[a-zA-Z]/, peg$c94 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false), peg$c95 = "-", peg$c96 = peg$literalExpectation("-", false), peg$c97 = /^[a-zA-Z0-9]/, peg$c98 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false), peg$c99 = function(a, s) {
          return "-" + s.join("");
        }, peg$c100 = function(a, b) {
          return a.join("") + b.join("");
        }, peg$c101 = /^[+\-]/, peg$c102 = peg$classExpectation(["+", "-"], false, false), peg$c103 = function(a) {
          if (a.match(/^[0+][0-9]+$/))
            return {
              "@value": a,
              "@type": "http://www.w3.org/2001/XMLSchema#integer"
            };
          return parseInt(a);
        }, peg$c104 = function(a) {
          return {
            "@value": a,
            "@type": "http://www.w3.org/2001/XMLSchema#decimal"
          };
        }, peg$c105 = function(a) {
          return {
            "@value": a,
            "@type": "http://www.w3.org/2001/XMLSchema#double"
          };
        }, peg$c106 = /^[eE]/, peg$c107 = peg$classExpectation(["e", "E"], false, false), peg$c108 = '"', peg$c109 = peg$literalExpectation('"', false), peg$c110 = /^[^"\\\n\r]/, peg$c111 = peg$classExpectation(['"', "\\", "\n", "\r"], true, false), peg$c112 = "'", peg$c113 = peg$literalExpectation("'", false), peg$c114 = /^[^'\\\n\r]/, peg$c115 = peg$classExpectation(["'", "\\", "\n", "\r"], true, false), peg$c116 = "'''", peg$c117 = peg$literalExpectation("'''", false), peg$c118 = /^[^'\\]/, peg$c119 = peg$classExpectation(["'", "\\"], true, false), peg$c120 = "''", peg$c121 = peg$literalExpectation("''", false), peg$c122 = function(head, a) {
          return "''" + a.join("");
        }, peg$c123 = function(head, a) {
          return "'" + a.join("");
        }, peg$c124 = function(head, body) {
          return head.join("") + body.join("");
        }, peg$c125 = '"""', peg$c126 = peg$literalExpectation('"""', false), peg$c127 = /^[^"\\]/, peg$c128 = peg$classExpectation(['"', "\\"], true, false), peg$c129 = '""', peg$c130 = peg$literalExpectation('""', false), peg$c131 = function(head, a) {
          return '""' + a.join("");
        }, peg$c132 = function(head, a) {
          return '"' + a.join("");
        }, peg$c133 = "\\U", peg$c134 = peg$literalExpectation("\\U", false), peg$c135 = function(hex) {
          return String.fromCodePoint(parseInt(hex.join(""), 16));
        }, peg$c136 = "\\u", peg$c137 = peg$literalExpectation("\\u", false), peg$c138 = function(hex) {
          return String.fromCharCode(parseInt(hex.join(""), 16));
        }, peg$c139 = "\\t", peg$c140 = peg$literalExpectation("\\t", false), peg$c141 = function() {
          return "	";
        }, peg$c142 = "\\b", peg$c143 = peg$literalExpectation("\\b", false), peg$c144 = function() {
          return "\b";
        }, peg$c145 = "\\n", peg$c146 = peg$literalExpectation("\\n", false), peg$c147 = function() {
          return "\n";
        }, peg$c148 = "\\r", peg$c149 = peg$literalExpectation("\\r", false), peg$c150 = function() {
          return "\r";
        }, peg$c151 = "\\f", peg$c152 = peg$literalExpectation("\\f", false), peg$c153 = function() {
          return "\f";
        }, peg$c154 = '\\"', peg$c155 = peg$literalExpectation('\\"', false), peg$c156 = function() {
          return '"';
        }, peg$c157 = "\\'", peg$c158 = peg$literalExpectation("\\'", false), peg$c159 = function() {
          return "'";
        }, peg$c160 = "\\\\", peg$c161 = peg$literalExpectation("\\\\", false), peg$c162 = function() {
          return "\\";
        }, peg$c163 = /^[ \t\r\n]/, peg$c164 = peg$classExpectation([" ", "	", "\r", "\n"], false, false), peg$c165 = function() {
          return "[]";
        }, peg$c166 = /^[\uD800-\uDBFF]/, peg$c167 = peg$classExpectation([["\uD800", "\uDBFF"]], false, false), peg$c168 = /^[\uDC00-\uDFFF]/, peg$c169 = peg$classExpectation([["\uDC00", "\uDFFF"]], false, false), peg$c170 = function(a, b) {
          return a + b;
        }, peg$c171 = /^[A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, peg$c172 = peg$classExpectation([["A", "Z"], ["a", "z"], ["À", "Ö"], ["Ø", "ö"], ["ø", "˿"], ["Ͱ", "ͽ"], ["Ϳ", "῿"], ["‌", "‍"], ["⁰", "↏"], ["Ⰰ", "⿯"], ["、", "퟿"], ["豈", "﷏"], ["ﷰ", "�"]], false, false), peg$c173 = "_", peg$c174 = peg$literalExpectation("_", false), peg$c175 = "·", peg$c176 = peg$literalExpectation("·", false), peg$c177 = /^[\u0300-\u036F]/, peg$c178 = peg$classExpectation([["̀", "ͯ"]], false, false), peg$c179 = /^[\u203F-\u2040]/, peg$c180 = peg$classExpectation([["‿", "⁀"]], false, false), peg$c181 = function(head, body, a, b) {
          return a.join("") + b.join("");
        }, peg$c182 = function(head, body, tail) {
          return head + body.join("") + tail.join("");
        }, peg$c183 = "%", peg$c184 = peg$literalExpectation("%", false), peg$c185 = /^[0-9A-Fa-f]/, peg$c186 = peg$classExpectation([["0", "9"], ["A", "F"], ["a", "f"]], false, false), peg$c187 = "\\", peg$c188 = peg$literalExpectation("\\", false), peg$c189 = /^[_~.!$&'()*+,;=\/?#@%\-]/, peg$c190 = peg$classExpectation(["_", "~", ".", "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "=", "/", "?", "#", "@", "%", "-"], false, false), peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
        if ("startRule" in options) {
          if (!(options.startRule in peg$startRuleFunctions)) {
            throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
          }
          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
        }
        function text() {
          return input.substring(peg$savedPos, peg$currPos);
        }
        function location() {
          return peg$computeLocation(peg$savedPos, peg$currPos);
        }
        function expected(description, location2) {
          location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
          throw peg$buildStructuredError(
            [peg$otherExpectation(description)],
            input.substring(peg$savedPos, peg$currPos),
            location2
          );
        }
        function error(message, location2) {
          location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
          throw peg$buildSimpleError(message, location2);
        }
        function peg$literalExpectation(text2, ignoreCase) {
          return { type: "literal", text: text2, ignoreCase };
        }
        function peg$classExpectation(parts, inverted, ignoreCase) {
          return { type: "class", parts, inverted, ignoreCase };
        }
        function peg$anyExpectation() {
          return { type: "any" };
        }
        function peg$endExpectation() {
          return { type: "end" };
        }
        function peg$otherExpectation(description) {
          return { type: "other", description };
        }
        function peg$computePosDetails(pos) {
          var details = peg$posDetailsCache[pos], p;
          if (details) {
            return details;
          } else {
            p = pos - 1;
            while (!peg$posDetailsCache[p]) {
              p--;
            }
            details = peg$posDetailsCache[p];
            details = {
              line: details.line,
              column: details.column
            };
            while (p < pos) {
              if (input.charCodeAt(p) === 10) {
                details.line++;
                details.column = 1;
              } else {
                details.column++;
              }
              p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
          }
        }
        function peg$computeLocation(startPos, endPos) {
          var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
          return {
            start: {
              offset: startPos,
              line: startPosDetails.line,
              column: startPosDetails.column
            },
            end: {
              offset: endPos,
              line: endPosDetails.line,
              column: endPosDetails.column
            }
          };
        }
        function peg$fail(expected2) {
          if (peg$currPos < peg$maxFailPos) {
            return;
          }
          if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
          }
          peg$maxFailExpected.push(expected2);
        }
        function peg$buildSimpleError(message, location2) {
          return new peg$SyntaxError(message, null, null, location2);
        }
        function peg$buildStructuredError(expected2, found, location2) {
          return new peg$SyntaxError(
            peg$SyntaxError.buildMessage(expected2, found),
            expected2,
            found,
            location2
          );
        }
        function peg$parseturtleDoc() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseBOM();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseBOM();
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsestatement();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsestatement();
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseIGNORE();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseIGNORE();
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c0(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBOM() {
          var s0;
          if (input.charCodeAt(peg$currPos) === 65279) {
            s0 = peg$c1;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c2);
            }
          }
          return s0;
        }
        function peg$parsestatement() {
          var s0, s1, s2, s3;
          s0 = peg$parsedirective();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsetriples();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseIGNORE();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseIGNORE();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s3 = peg$c3;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c4);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c5(s1);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseCOMMENT() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 35) {
            s1 = peg$c6;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c8.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c8.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c9);
                }
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 10) {
                s3 = peg$c10;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c11);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseIGNORE() {
          var s0;
          s0 = peg$parseWS();
          if (s0 === peg$FAILED) {
            s0 = peg$parseCOMMENT();
          }
          return s0;
        }
        function peg$parsedirective() {
          var s0;
          s0 = peg$parseprefixID();
          if (s0 === peg$FAILED) {
            s0 = peg$parsebase();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesparqlPrefix();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesparqlBase();
              }
            }
          }
          return s0;
        }
        function peg$parseprefixID() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 7) === peg$c13) {
              s2 = peg$c13;
              peg$currPos += 7;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c14);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseIGNORE();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseIGNORE();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parsePNAME_NS_NO_CHECK();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseIGNORE();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseIGNORE();
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseIRIREF();
                    if (s6 !== peg$FAILED) {
                      s7 = [];
                      s8 = peg$parseIGNORE();
                      while (s8 !== peg$FAILED) {
                        s7.push(s8);
                        s8 = peg$parseIGNORE();
                      }
                      if (s7 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 46) {
                          s8 = peg$c3;
                          peg$currPos++;
                        } else {
                          s8 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c4);
                          }
                        }
                        if (s8 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c15(s4, s6);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsebase() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 5) === peg$c16) {
              s2 = peg$c16;
              peg$currPos += 5;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseIGNORE();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseIGNORE();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseIRIREF();
                if (s4 !== peg$FAILED) {
                  s5 = [];
                  s6 = peg$parseIGNORE();
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    s6 = peg$parseIGNORE();
                  }
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 46) {
                      s6 = peg$c3;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c4);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c18(s4);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsesparqlBase() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            if (peg$c19.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c20);
              }
            }
            if (s2 !== peg$FAILED) {
              if (peg$c21.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c22);
                }
              }
              if (s3 !== peg$FAILED) {
                if (peg$c23.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c24);
                  }
                }
                if (s4 !== peg$FAILED) {
                  if (peg$c25.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c26);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parseIGNORE();
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$parseIGNORE();
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseIRIREF();
                      if (s7 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c18(s7);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsesparqlPrefix() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            if (peg$c27.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s2 !== peg$FAILED) {
              if (peg$c29.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c30);
                }
              }
              if (s3 !== peg$FAILED) {
                if (peg$c25.test(input.charAt(peg$currPos))) {
                  s4 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c26);
                  }
                }
                if (s4 !== peg$FAILED) {
                  if (peg$c31.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c32);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    if (peg$c33.test(input.charAt(peg$currPos))) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c34);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      if (peg$c35.test(input.charAt(peg$currPos))) {
                        s7 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c36);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = [];
                        s9 = peg$parseIGNORE();
                        while (s9 !== peg$FAILED) {
                          s8.push(s9);
                          s9 = peg$parseIGNORE();
                        }
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parsePNAME_NS_NO_CHECK();
                          if (s9 !== peg$FAILED) {
                            s10 = [];
                            s11 = peg$parseIGNORE();
                            while (s11 !== peg$FAILED) {
                              s10.push(s11);
                              s11 = peg$parseIGNORE();
                            }
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parseIRIREF();
                              if (s11 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c15(s9, s11);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsetriples() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsesubject();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsepredicateObjectList();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c37(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parseblankNodePropertyList();
            if (s1 !== peg$FAILED) {
              s2 = peg$parsepredicateObjectList();
              if (s2 === peg$FAILED) {
                s2 = null;
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c38(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parsepredicateObjectList() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
          s0 = peg$currPos;
          s1 = peg$parseverb();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseobjectList();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              s5 = [];
              s6 = peg$parseIGNORE();
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                s6 = peg$parseIGNORE();
              }
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 59) {
                  s6 = peg$c39;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c40);
                  }
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$currPos;
                  s8 = peg$parseverb();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parseobjectList();
                    if (s9 !== peg$FAILED) {
                      peg$savedPos = s7;
                      s8 = peg$c41(s1, s2, s8, s9);
                      s7 = s8;
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s7;
                    s7 = peg$FAILED;
                  }
                  if (s7 === peg$FAILED) {
                    s7 = null;
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c42(s1, s2, s7);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = [];
                s6 = peg$parseIGNORE();
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$parseIGNORE();
                }
                if (s5 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s6 = peg$c39;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c40);
                    }
                  }
                  if (s6 !== peg$FAILED) {
                    s7 = peg$currPos;
                    s8 = peg$parseverb();
                    if (s8 !== peg$FAILED) {
                      s9 = peg$parseobjectList();
                      if (s9 !== peg$FAILED) {
                        peg$savedPos = s7;
                        s8 = peg$c41(s1, s2, s8, s9);
                        s7 = s8;
                      } else {
                        peg$currPos = s7;
                        s7 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s7;
                      s7 = peg$FAILED;
                    }
                    if (s7 === peg$FAILED) {
                      s7 = null;
                    }
                    if (s7 !== peg$FAILED) {
                      peg$savedPos = s4;
                      s5 = peg$c42(s1, s2, s7);
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c43(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseobjectList() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = peg$parseobject();
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$currPos;
            s4 = [];
            s5 = peg$parseIGNORE();
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              s5 = peg$parseIGNORE();
            }
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s5 = peg$c44;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c45);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parseobject();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s3;
                  s4 = peg$c46(s1, s6);
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$currPos;
              s4 = [];
              s5 = peg$parseIGNORE();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parseIGNORE();
              }
              if (s4 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s5 = peg$c44;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c45);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseobject();
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s3;
                    s4 = peg$c46(s1, s6);
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c47(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseverb() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsepredicate();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c5(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseIGNORE();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseIGNORE();
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 97) {
                s2 = peg$c48;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c49);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c50();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parsesubject() {
          var s0, s1;
          s0 = peg$currPos;
          s1 = peg$parsecollection();
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c51(s1);
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$parseBlankNode();
            if (s0 === peg$FAILED) {
              s0 = peg$parseiri();
            }
          }
          return s0;
        }
        function peg$parsepredicate() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseiri();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c5(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseobject() {
          var s0, s1;
          s0 = peg$parseliteral();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecollection();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c52(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parseBlankNode();
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c53(s1);
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$parseblankNodePropertyList();
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c5(s1);
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  s1 = peg$parseiri();
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c54(s1);
                  }
                  s0 = s1;
                }
              }
            }
          }
          return s0;
        }
        function peg$parseliteral() {
          var s0;
          s0 = peg$parseRDFLiteral();
          if (s0 === peg$FAILED) {
            s0 = peg$parseNumericLiteral();
            if (s0 === peg$FAILED) {
              s0 = peg$parseBooleanLiteral();
            }
          }
          return s0;
        }
        function peg$parseblankNodePropertyList() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 91) {
              s2 = peg$c55;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c56);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parsepredicateObjectList();
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseIGNORE();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseIGNORE();
                }
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s5 = peg$c57;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c58);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c5(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsecollection() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 40) {
              s2 = peg$c59;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c60);
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseobject();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseobject();
              }
              if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parseIGNORE();
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  s5 = peg$parseIGNORE();
                }
                if (s4 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 41) {
                    s5 = peg$c61;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c62);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c63(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseNumericLiteral() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseDOUBLE();
            if (s2 === peg$FAILED) {
              s2 = peg$parseDECIMAL();
              if (s2 === peg$FAILED) {
                s2 = peg$parseINTEGER();
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c5(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseRDFLiteral() {
          var s0, s1, s2, s3, s4, s5, s6;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseString();
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$parseIGNORE();
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$parseIGNORE();
              }
              if (s3 !== peg$FAILED) {
                s4 = peg$parseLANGTAG();
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c64(s2, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseIGNORE();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseIGNORE();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseString();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseIGNORE();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseIGNORE();
                }
                if (s3 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 2) === peg$c65) {
                    s4 = peg$c65;
                    peg$currPos += 2;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c66);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseIGNORE();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseIGNORE();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseiri();
                      if (s6 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c67(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseIGNORE();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseIGNORE();
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parseString();
                if (s2 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c5(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            }
          }
          return s0;
        }
        function peg$parseBooleanLiteral() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 4) === peg$c68) {
              s2 = peg$c68;
              peg$currPos += 4;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c69);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c70();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseIGNORE();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseIGNORE();
            }
            if (s1 !== peg$FAILED) {
              if (input.substr(peg$currPos, 5) === peg$c71) {
                s2 = peg$c71;
                peg$currPos += 5;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c72);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c73();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseString() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseSTRING_LITERAL_LONG_SINGLE_QUOTE();
            if (s2 === peg$FAILED) {
              s2 = peg$parseSTRING_LITERAL_LONG_QUOTE();
              if (s2 === peg$FAILED) {
                s2 = peg$parseSTRING_LITERAL_SINGLE_QUOTE();
                if (s2 === peg$FAILED) {
                  s2 = peg$parseSTRING_LITERAL_QUOTE();
                }
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c5(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseiri() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseIRIREF();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c5(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseIGNORE();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseIGNORE();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsePrefixedName();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c5(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parsePrefixedName() {
          var s0, s1;
          s0 = peg$parsePNAME_LN();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsePNAME_NS();
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c74(s1);
            }
            s0 = s1;
          }
          return s0;
        }
        function peg$parseBlankNode() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = [];
          s2 = peg$parseIGNORE();
          while (s2 !== peg$FAILED) {
            s1.push(s2);
            s2 = peg$parseIGNORE();
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$parseBLANK_NODE_LABEL();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c5(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseIGNORE();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseIGNORE();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseANON();
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c5(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseIRIREF() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 60) {
            s1 = peg$c75;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c76);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c77.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c78);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$parseUCHAR();
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c77.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c78);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = peg$parseUCHAR();
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s3 = peg$c79;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c80);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c81(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePNAME_NS() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsePN_PREFIX();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c82;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c83);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c84(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePNAME_NS_NO_CHECK() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsePN_PREFIX();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s2 = peg$c82;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c83);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c85(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePNAME_LN() {
          var s0, s1, s2;
          s0 = peg$currPos;
          s1 = peg$parsePNAME_NS();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsePN_LOCAL();
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c86(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseBLANK_NODE_LABEL() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c87) {
            s2 = peg$c87;
            peg$currPos += 2;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c88);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parsePN_CHARS_U();
            if (s3 === peg$FAILED) {
              if (peg$c89.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c90);
                }
              }
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$parsePN_CHARS();
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$parsePN_CHARS();
              }
              if (s4 !== peg$FAILED) {
                s5 = [];
                s6 = peg$currPos;
                s7 = [];
                if (input.charCodeAt(peg$currPos) === 46) {
                  s8 = peg$c3;
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c4);
                  }
                }
                if (s8 !== peg$FAILED) {
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    if (input.charCodeAt(peg$currPos) === 46) {
                      s8 = peg$c3;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c4);
                      }
                    }
                  }
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s8 = [];
                  s9 = peg$parsePN_CHARS();
                  if (s9 !== peg$FAILED) {
                    while (s9 !== peg$FAILED) {
                      s8.push(s9);
                      s9 = peg$parsePN_CHARS();
                    }
                  } else {
                    s8 = peg$FAILED;
                  }
                  if (s8 !== peg$FAILED) {
                    s7 = [s7, s8];
                    s6 = s7;
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s6;
                  s6 = peg$FAILED;
                }
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  s6 = peg$currPos;
                  s7 = [];
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s8 = peg$c3;
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c4);
                    }
                  }
                  if (s8 !== peg$FAILED) {
                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      if (input.charCodeAt(peg$currPos) === 46) {
                        s8 = peg$c3;
                        peg$currPos++;
                      } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c4);
                        }
                      }
                    }
                  } else {
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = [];
                    s9 = peg$parsePN_CHARS();
                    if (s9 !== peg$FAILED) {
                      while (s9 !== peg$FAILED) {
                        s8.push(s9);
                        s9 = peg$parsePN_CHARS();
                      }
                    } else {
                      s8 = peg$FAILED;
                    }
                    if (s8 !== peg$FAILED) {
                      s7 = [s7, s8];
                      s6 = s7;
                    } else {
                      peg$currPos = s6;
                      s6 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s6;
                    s6 = peg$FAILED;
                  }
                }
                if (s5 !== peg$FAILED) {
                  s2 = [s2, s3, s4, s5];
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
          return s0;
        }
        function peg$parseLANGTAG() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 64) {
            s1 = peg$c91;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c92);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c93.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c94);
              }
            }
            if (s3 !== peg$FAILED) {
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                if (peg$c93.test(input.charAt(peg$currPos))) {
                  s3 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c94);
                  }
                }
              }
            } else {
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 45) {
                s5 = peg$c95;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c96);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = [];
                if (peg$c97.test(input.charAt(peg$currPos))) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c98);
                  }
                }
                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    if (peg$c97.test(input.charAt(peg$currPos))) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c98);
                      }
                    }
                  }
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c99(s2, s6);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 45) {
                  s5 = peg$c95;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c96);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  if (peg$c97.test(input.charAt(peg$currPos))) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c98);
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      if (peg$c97.test(input.charAt(peg$currPos))) {
                        s7 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c98);
                        }
                      }
                    }
                  } else {
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c99(s2, s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c100(s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseINTEGER() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          if (peg$c101.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c102);
            }
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            if (peg$c89.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c90);
              }
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                if (peg$c89.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c90);
                  }
                }
              }
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s2;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c103(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseDECIMAL() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          if (peg$c101.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c102);
            }
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            if (peg$c89.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c90);
              }
            }
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c89.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c90);
                }
              }
            }
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c3;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c4);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = [];
                if (peg$c89.test(input.charAt(peg$currPos))) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c90);
                  }
                }
                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    if (peg$c89.test(input.charAt(peg$currPos))) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c90);
                      }
                    }
                  }
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s3 = [s3, s4, s5, s6];
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s2;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c104(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseDOUBLE() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$currPos;
          if (peg$c101.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c102);
            }
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            s5 = [];
            if (peg$c89.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c90);
              }
            }
            if (s6 !== peg$FAILED) {
              while (s6 !== peg$FAILED) {
                s5.push(s6);
                if (peg$c89.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c90);
                  }
                }
              }
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 46) {
                s6 = peg$c3;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c4);
                }
              }
              if (s6 !== peg$FAILED) {
                s7 = [];
                if (peg$c89.test(input.charAt(peg$currPos))) {
                  s8 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c90);
                  }
                }
                while (s8 !== peg$FAILED) {
                  s7.push(s8);
                  if (peg$c89.test(input.charAt(peg$currPos))) {
                    s8 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c90);
                    }
                  }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseEXPONENT();
                  if (s8 !== peg$FAILED) {
                    s5 = [s5, s6, s7, s8];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$FAILED;
            }
            if (s4 === peg$FAILED) {
              s4 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 46) {
                s5 = peg$c3;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c4);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = [];
                if (peg$c89.test(input.charAt(peg$currPos))) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c90);
                  }
                }
                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    if (peg$c89.test(input.charAt(peg$currPos))) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c90);
                      }
                    }
                  }
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parseEXPONENT();
                  if (s7 !== peg$FAILED) {
                    s5 = [s5, s6, s7];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 === peg$FAILED) {
                s4 = peg$currPos;
                s5 = [];
                if (peg$c89.test(input.charAt(peg$currPos))) {
                  s6 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c90);
                  }
                }
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    if (peg$c89.test(input.charAt(peg$currPos))) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c90);
                      }
                    }
                  }
                } else {
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseEXPONENT();
                  if (s6 !== peg$FAILED) {
                    s5 = [s5, s6];
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
            }
            if (s4 !== peg$FAILED) {
              s3 = [s3, s4];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            s1 = input.substring(s1, peg$currPos);
          } else {
            s1 = s2;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c105(s1);
          }
          s0 = s1;
          return s0;
        }
        function peg$parseEXPONENT() {
          var s0, s1, s2, s3, s4, s5;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (peg$c106.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c107);
            }
          }
          if (s2 !== peg$FAILED) {
            if (peg$c101.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c102);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = null;
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              if (peg$c89.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c90);
                }
              }
              if (s5 !== peg$FAILED) {
                while (s5 !== peg$FAILED) {
                  s4.push(s5);
                  if (peg$c89.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c90);
                    }
                  }
                }
              } else {
                s4 = peg$FAILED;
              }
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
          return s0;
        }
        function peg$parseSTRING_LITERAL_QUOTE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s1 = peg$c108;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c109);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c110.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c111);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$parseECHAR();
              if (s3 === peg$FAILED) {
                s3 = peg$parseUCHAR();
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c110.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c111);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = peg$parseECHAR();
                if (s3 === peg$FAILED) {
                  s3 = peg$parseUCHAR();
                }
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s3 = peg$c108;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c109);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTRING_LITERAL_SINGLE_QUOTE() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 39) {
            s1 = peg$c112;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c113);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c114.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c115);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$parseECHAR();
              if (s3 === peg$FAILED) {
                s3 = peg$parseUCHAR();
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c114.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c115);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = peg$parseECHAR();
                if (s3 === peg$FAILED) {
                  s3 = peg$parseUCHAR();
                }
              }
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 39) {
                s3 = peg$c112;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c113);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c12(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTRING_LITERAL_LONG_SINGLE_QUOTE() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c116) {
            s1 = peg$c116;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c117);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c118.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c119);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$parseECHAR();
              if (s3 === peg$FAILED) {
                s3 = peg$parseUCHAR();
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c118.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c119);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = peg$parseECHAR();
                if (s3 === peg$FAILED) {
                  s3 = peg$parseUCHAR();
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c120) {
                s5 = peg$c120;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c121);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = [];
                if (peg$c118.test(input.charAt(peg$currPos))) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c119);
                  }
                }
                if (s7 === peg$FAILED) {
                  s7 = peg$parseECHAR();
                  if (s7 === peg$FAILED) {
                    s7 = peg$parseUCHAR();
                  }
                }
                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    if (peg$c118.test(input.charAt(peg$currPos))) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c119);
                      }
                    }
                    if (s7 === peg$FAILED) {
                      s7 = peg$parseECHAR();
                      if (s7 === peg$FAILED) {
                        s7 = peg$parseUCHAR();
                      }
                    }
                  }
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c122(s2, s6);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 === peg$FAILED) {
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 39) {
                  s5 = peg$c112;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c113);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  if (peg$c118.test(input.charAt(peg$currPos))) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c119);
                    }
                  }
                  if (s7 === peg$FAILED) {
                    s7 = peg$parseECHAR();
                    if (s7 === peg$FAILED) {
                      s7 = peg$parseUCHAR();
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      if (peg$c118.test(input.charAt(peg$currPos))) {
                        s7 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c119);
                        }
                      }
                      if (s7 === peg$FAILED) {
                        s7 = peg$parseECHAR();
                        if (s7 === peg$FAILED) {
                          s7 = peg$parseUCHAR();
                        }
                      }
                    }
                  } else {
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c123(s2, s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c120) {
                  s5 = peg$c120;
                  peg$currPos += 2;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c121);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  if (peg$c118.test(input.charAt(peg$currPos))) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c119);
                    }
                  }
                  if (s7 === peg$FAILED) {
                    s7 = peg$parseECHAR();
                    if (s7 === peg$FAILED) {
                      s7 = peg$parseUCHAR();
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      if (peg$c118.test(input.charAt(peg$currPos))) {
                        s7 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c119);
                        }
                      }
                      if (s7 === peg$FAILED) {
                        s7 = peg$parseECHAR();
                        if (s7 === peg$FAILED) {
                          s7 = peg$parseUCHAR();
                        }
                      }
                    }
                  } else {
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c122(s2, s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 === peg$FAILED) {
                  s4 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 39) {
                    s5 = peg$c112;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c113);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = [];
                    if (peg$c118.test(input.charAt(peg$currPos))) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c119);
                      }
                    }
                    if (s7 === peg$FAILED) {
                      s7 = peg$parseECHAR();
                      if (s7 === peg$FAILED) {
                        s7 = peg$parseUCHAR();
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        if (peg$c118.test(input.charAt(peg$currPos))) {
                          s7 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c119);
                          }
                        }
                        if (s7 === peg$FAILED) {
                          s7 = peg$parseECHAR();
                          if (s7 === peg$FAILED) {
                            s7 = peg$parseUCHAR();
                          }
                        }
                      }
                    } else {
                      s6 = peg$FAILED;
                    }
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s4;
                      s5 = peg$c123(s2, s6);
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                }
              }
              if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c116) {
                  s4 = peg$c116;
                  peg$currPos += 3;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c117);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c124(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseSTRING_LITERAL_LONG_QUOTE() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c125) {
            s1 = peg$c125;
            peg$currPos += 3;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c126);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            if (peg$c127.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c128);
              }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$parseECHAR();
              if (s3 === peg$FAILED) {
                s3 = peg$parseUCHAR();
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              if (peg$c127.test(input.charAt(peg$currPos))) {
                s3 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c128);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = peg$parseECHAR();
                if (s3 === peg$FAILED) {
                  s3 = peg$parseUCHAR();
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c129) {
                s5 = peg$c129;
                peg$currPos += 2;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c130);
                }
              }
              if (s5 !== peg$FAILED) {
                s6 = [];
                if (peg$c127.test(input.charAt(peg$currPos))) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c128);
                  }
                }
                if (s7 === peg$FAILED) {
                  s7 = peg$parseECHAR();
                  if (s7 === peg$FAILED) {
                    s7 = peg$parseUCHAR();
                  }
                }
                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    if (peg$c127.test(input.charAt(peg$currPos))) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c128);
                      }
                    }
                    if (s7 === peg$FAILED) {
                      s7 = peg$parseECHAR();
                      if (s7 === peg$FAILED) {
                        s7 = peg$parseUCHAR();
                      }
                    }
                  }
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c131(s2, s6);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              if (s4 === peg$FAILED) {
                s4 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 34) {
                  s5 = peg$c108;
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c109);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  if (peg$c127.test(input.charAt(peg$currPos))) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c128);
                    }
                  }
                  if (s7 === peg$FAILED) {
                    s7 = peg$parseECHAR();
                    if (s7 === peg$FAILED) {
                      s7 = peg$parseUCHAR();
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      if (peg$c127.test(input.charAt(peg$currPos))) {
                        s7 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c128);
                        }
                      }
                      if (s7 === peg$FAILED) {
                        s7 = peg$parseECHAR();
                        if (s7 === peg$FAILED) {
                          s7 = peg$parseUCHAR();
                        }
                      }
                    }
                  } else {
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c132(s2, s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c129) {
                  s5 = peg$c129;
                  peg$currPos += 2;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c130);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  if (peg$c127.test(input.charAt(peg$currPos))) {
                    s7 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c128);
                    }
                  }
                  if (s7 === peg$FAILED) {
                    s7 = peg$parseECHAR();
                    if (s7 === peg$FAILED) {
                      s7 = peg$parseUCHAR();
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      if (peg$c127.test(input.charAt(peg$currPos))) {
                        s7 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c128);
                        }
                      }
                      if (s7 === peg$FAILED) {
                        s7 = peg$parseECHAR();
                        if (s7 === peg$FAILED) {
                          s7 = peg$parseUCHAR();
                        }
                      }
                    }
                  } else {
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c131(s2, s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
                if (s4 === peg$FAILED) {
                  s4 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 34) {
                    s5 = peg$c108;
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c109);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s6 = [];
                    if (peg$c127.test(input.charAt(peg$currPos))) {
                      s7 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c128);
                      }
                    }
                    if (s7 === peg$FAILED) {
                      s7 = peg$parseECHAR();
                      if (s7 === peg$FAILED) {
                        s7 = peg$parseUCHAR();
                      }
                    }
                    if (s7 !== peg$FAILED) {
                      while (s7 !== peg$FAILED) {
                        s6.push(s7);
                        if (peg$c127.test(input.charAt(peg$currPos))) {
                          s7 = input.charAt(peg$currPos);
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c128);
                          }
                        }
                        if (s7 === peg$FAILED) {
                          s7 = peg$parseECHAR();
                          if (s7 === peg$FAILED) {
                            s7 = peg$parseUCHAR();
                          }
                        }
                      }
                    } else {
                      s6 = peg$FAILED;
                    }
                    if (s6 !== peg$FAILED) {
                      peg$savedPos = s4;
                      s5 = peg$c132(s2, s6);
                      s4 = s5;
                    } else {
                      peg$currPos = s4;
                      s4 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                }
              }
              if (s3 !== peg$FAILED) {
                if (input.substr(peg$currPos, 3) === peg$c125) {
                  s4 = peg$c125;
                  peg$currPos += 3;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c126);
                  }
                }
                if (s4 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c124(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parseUCHAR() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c133) {
            s1 = peg$c133;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c134);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = peg$currPos;
            s3 = peg$parseHEX();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHEX();
              if (s4 !== peg$FAILED) {
                s5 = peg$parseHEX();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parseHEX();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parseHEX();
                    if (s7 !== peg$FAILED) {
                      s8 = peg$parseHEX();
                      if (s8 !== peg$FAILED) {
                        s9 = peg$parseHEX();
                        if (s9 !== peg$FAILED) {
                          s10 = peg$parseHEX();
                          if (s10 !== peg$FAILED) {
                            s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                            s2 = s3;
                          } else {
                            peg$currPos = s2;
                            s2 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s2;
                          s2 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c135(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c136) {
              s1 = peg$c136;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c137);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseHEX();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseHEX();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseHEX();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseHEX();
                    if (s6 !== peg$FAILED) {
                      s3 = [s3, s4, s5, s6];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c138(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          }
          return s0;
        }
        function peg$parseECHAR() {
          var s0, s1;
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c139) {
            s1 = peg$c139;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c140);
            }
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c141();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c142) {
              s1 = peg$c142;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c143);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c144();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c145) {
                s1 = peg$c145;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c146);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c147();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c148) {
                  s1 = peg$c148;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c149);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c150();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c151) {
                    s1 = peg$c151;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c152);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c153();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c154) {
                      s1 = peg$c154;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c155);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$savedPos = s0;
                      s1 = peg$c156();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c157) {
                        s1 = peg$c157;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c158);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c159();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c160) {
                          s1 = peg$c160;
                          peg$currPos += 2;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c161);
                          }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c162();
                        }
                        s0 = s1;
                      }
                    }
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parseWS() {
          var s0;
          if (peg$c163.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c164);
            }
          }
          return s0;
        }
        function peg$parseANON() {
          var s0, s1, s2, s3;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 91) {
            s1 = peg$c55;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c56);
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parseIGNORE();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parseIGNORE();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 93) {
                s3 = peg$c57;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c58);
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c165();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePN_CHARS_BASE() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (peg$c166.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c167);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c168.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c169);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c170(s1, s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          if (s0 === peg$FAILED) {
            if (peg$c171.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c172);
              }
            }
          }
          return s0;
        }
        function peg$parsePN_CHARS_U() {
          var s0;
          s0 = peg$parsePN_CHARS_BASE();
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 95) {
              s0 = peg$c173;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c174);
              }
            }
          }
          return s0;
        }
        function peg$parsePN_CHARS() {
          var s0;
          s0 = peg$parsePN_CHARS_U();
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 45) {
              s0 = peg$c95;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c96);
              }
            }
            if (s0 === peg$FAILED) {
              if (peg$c89.test(input.charAt(peg$currPos))) {
                s0 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c90);
                }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 183) {
                  s0 = peg$c175;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c176);
                  }
                }
                if (s0 === peg$FAILED) {
                  if (peg$c177.test(input.charAt(peg$currPos))) {
                    s0 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c178);
                    }
                  }
                  if (s0 === peg$FAILED) {
                    if (peg$c179.test(input.charAt(peg$currPos))) {
                      s0 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c180);
                      }
                    }
                  }
                }
              }
            }
          }
          return s0;
        }
        function peg$parsePN_PREFIX() {
          var s0, s1, s2, s3, s4, s5, s6, s7, s8;
          s0 = peg$currPos;
          s1 = peg$currPos;
          s2 = peg$parsePN_CHARS_BASE();
          if (s2 !== peg$FAILED) {
            s3 = [];
            s4 = peg$parsePN_CHARS();
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parsePN_CHARS();
            }
            if (s3 !== peg$FAILED) {
              s4 = [];
              s5 = peg$currPos;
              s6 = [];
              if (input.charCodeAt(peg$currPos) === 46) {
                s7 = peg$c3;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c4);
                }
              }
              if (s7 !== peg$FAILED) {
                while (s7 !== peg$FAILED) {
                  s6.push(s7);
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s7 = peg$c3;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c4);
                    }
                  }
                }
              } else {
                s6 = peg$FAILED;
              }
              if (s6 !== peg$FAILED) {
                s7 = [];
                s8 = peg$parsePN_CHARS();
                if (s8 !== peg$FAILED) {
                  while (s8 !== peg$FAILED) {
                    s7.push(s8);
                    s8 = peg$parsePN_CHARS();
                  }
                } else {
                  s7 = peg$FAILED;
                }
                if (s7 !== peg$FAILED) {
                  s6 = [s6, s7];
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$currPos;
                s6 = [];
                if (input.charCodeAt(peg$currPos) === 46) {
                  s7 = peg$c3;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c4);
                  }
                }
                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    if (input.charCodeAt(peg$currPos) === 46) {
                      s7 = peg$c3;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c4);
                      }
                    }
                  }
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  s7 = [];
                  s8 = peg$parsePN_CHARS();
                  if (s8 !== peg$FAILED) {
                    while (s8 !== peg$FAILED) {
                      s7.push(s8);
                      s8 = peg$parsePN_CHARS();
                    }
                  } else {
                    s7 = peg$FAILED;
                  }
                  if (s7 !== peg$FAILED) {
                    s6 = [s6, s7];
                    s5 = s6;
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
          return s0;
        }
        function peg$parsePN_LOCAL() {
          var s0, s1, s2, s3, s4, s5, s6, s7;
          s0 = peg$currPos;
          s1 = peg$parsePN_CHARS_U();
          if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s1 = peg$c82;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c83);
              }
            }
            if (s1 === peg$FAILED) {
              if (peg$c89.test(input.charAt(peg$currPos))) {
                s1 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c90);
                }
              }
              if (s1 === peg$FAILED) {
                s1 = peg$parsePLX();
              }
            }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsePN_CHARS();
            if (s3 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 58) {
                s3 = peg$c82;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c83);
                }
              }
              if (s3 === peg$FAILED) {
                s3 = peg$parsePLX();
              }
            }
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsePN_CHARS();
              if (s3 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s3 = peg$c82;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c83);
                  }
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$parsePLX();
                }
              }
            }
            if (s2 !== peg$FAILED) {
              s3 = [];
              s4 = peg$currPos;
              s5 = [];
              if (input.charCodeAt(peg$currPos) === 46) {
                s6 = peg$c3;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c4);
                }
              }
              if (s6 !== peg$FAILED) {
                while (s6 !== peg$FAILED) {
                  s5.push(s6);
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s6 = peg$c3;
                    peg$currPos++;
                  } else {
                    s6 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c4);
                    }
                  }
                }
              } else {
                s5 = peg$FAILED;
              }
              if (s5 !== peg$FAILED) {
                s6 = [];
                s7 = peg$parsePN_CHARS();
                if (s7 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 58) {
                    s7 = peg$c82;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c83);
                    }
                  }
                  if (s7 === peg$FAILED) {
                    s7 = peg$parsePLX();
                  }
                }
                if (s7 !== peg$FAILED) {
                  while (s7 !== peg$FAILED) {
                    s6.push(s7);
                    s7 = peg$parsePN_CHARS();
                    if (s7 === peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 58) {
                        s7 = peg$c82;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c83);
                        }
                      }
                      if (s7 === peg$FAILED) {
                        s7 = peg$parsePLX();
                      }
                    }
                  }
                } else {
                  s6 = peg$FAILED;
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s4;
                  s5 = peg$c181(s1, s2, s5, s6);
                  s4 = s5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              } else {
                peg$currPos = s4;
                s4 = peg$FAILED;
              }
              while (s4 !== peg$FAILED) {
                s3.push(s4);
                s4 = peg$currPos;
                s5 = [];
                if (input.charCodeAt(peg$currPos) === 46) {
                  s6 = peg$c3;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c4);
                  }
                }
                if (s6 !== peg$FAILED) {
                  while (s6 !== peg$FAILED) {
                    s5.push(s6);
                    if (input.charCodeAt(peg$currPos) === 46) {
                      s6 = peg$c3;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c4);
                      }
                    }
                  }
                } else {
                  s5 = peg$FAILED;
                }
                if (s5 !== peg$FAILED) {
                  s6 = [];
                  s7 = peg$parsePN_CHARS();
                  if (s7 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 58) {
                      s7 = peg$c82;
                      peg$currPos++;
                    } else {
                      s7 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c83);
                      }
                    }
                    if (s7 === peg$FAILED) {
                      s7 = peg$parsePLX();
                    }
                  }
                  if (s7 !== peg$FAILED) {
                    while (s7 !== peg$FAILED) {
                      s6.push(s7);
                      s7 = peg$parsePN_CHARS();
                      if (s7 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 58) {
                          s7 = peg$c82;
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c83);
                          }
                        }
                        if (s7 === peg$FAILED) {
                          s7 = peg$parsePLX();
                        }
                      }
                    }
                  } else {
                    s6 = peg$FAILED;
                  }
                  if (s6 !== peg$FAILED) {
                    peg$savedPos = s4;
                    s5 = peg$c181(s1, s2, s5, s6);
                    s4 = s5;
                  } else {
                    peg$currPos = s4;
                    s4 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s4;
                  s4 = peg$FAILED;
                }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c182(s1, s2, s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        function peg$parsePLX() {
          var s0;
          s0 = peg$parsePERCENT();
          if (s0 === peg$FAILED) {
            s0 = peg$parsePN_LOCAL_ESC();
          }
          return s0;
        }
        function peg$parsePERCENT() {
          var s0, s1, s2, s3, s4;
          s0 = peg$currPos;
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 37) {
            s2 = peg$c183;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c184);
            }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parseHEX();
            if (s3 !== peg$FAILED) {
              s4 = peg$parseHEX();
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
          if (s1 !== peg$FAILED) {
            s0 = input.substring(s0, peg$currPos);
          } else {
            s0 = s1;
          }
          return s0;
        }
        function peg$parseHEX() {
          var s0;
          if (peg$c185.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c186);
            }
          }
          return s0;
        }
        function peg$parsePN_LOCAL_ESC() {
          var s0, s1, s2;
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 92) {
            s1 = peg$c187;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c188);
            }
          }
          if (s1 !== peg$FAILED) {
            if (peg$c189.test(input.charAt(peg$currPos))) {
              s2 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c190);
              }
            }
            if (s2 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c5(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
          return s0;
        }
        var isIRI = function(a) {
          return a.match(/^[a-z](.*?):(.+?)/g);
        };
        function createObject(property, value) {
          var a = {};
          a[property] = value;
          return a;
        }
        var context = {
          base: [],
          data: {},
          addBase: function(uri) {
            if (context.base.length === 0) {
              context.base.push(uri);
              return;
            }
            const last = context.base[context.base.length - 1];
            if (last !== uri) context.base.push(new URL(uri, last).toString());
          },
          addPrefix: function(prefix, uri) {
            const list = context.data[prefix];
            if (list === void 0) {
              context.data[prefix] = [{ uri, count: 0 }];
            } else if (list[list.length - 1].uri !== uri) {
              list.push({ uri, count: 0 });
            }
          },
          hasPrefix: function(prefix) {
            return this.data[prefix] !== void 0;
          },
          resolve: function(pname, force) {
            const prefix = Object.keys(context.data).find((key) => pname.indexOf(key + ":") === 0);
            if (prefix !== void 0) {
              const list = context.data[prefix];
              if (list.length === 1 && force !== true && isIRI(list[0].uri)) return pname;
              const uri = list[list.length - 1].uri;
              return pname.replace(prefix + ":", uri);
            } else {
              var base = context.base.length === 0 ? options.baseIRI : context.base[context.base.length - 1];
              if (!base || pname.match(/^(http:|https:|urn:|file:)/)) return pname;
              if (pname.indexOf("//") === 0 && base) return base.split("//")[0] + pname;
              return new URL(pname, base).toString();
            }
          },
          increment: function(prefix) {
            const list = context.data[prefix];
            if (list !== void 0) list[list.length - 1].count++;
          },
          decrement: function(prefix) {
            const list = context.data[prefix];
            if (list !== void 0) list[list.length - 1].count--;
          },
          toJSON: function() {
            const root = {};
            if (context.base.length > 0) {
              if (root["@context"] === void 0) root["@context"] = {};
              root["@context"]["@base"] = context.base[0];
            }
            Object.keys(context.data).forEach((key) => {
              const head = context.data[key][0];
              if (head.uri === "http://www.w3.org/2001/XMLSchema#" && head.count < 1) return;
              if (!isIRI(head.uri)) return;
              if (root["@context"] === void 0) root["@context"] = {};
              root["@context"][key] = head.uri;
            });
            return root;
          }
        };
        function expandList(container, force) {
          if (container["@list"] === void 0) return container;
          if (!force && !container["@list"].find((x) => x["@list"] !== void 0)) return container;
          if (container["@list"].length === 0)
            return { "@id": "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil" };
          var root = {};
          var focus = null;
          container["@list"].forEach((b) => {
            if (focus === null) focus = root;
            else {
              focus["http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"] = {};
              focus = focus["http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"];
            }
            focus["http://www.w3.org/1999/02/22-rdf-syntax-ns#first"] = expandList(b, true);
            focus["http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"] = {
              "@id": "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"
            };
          });
          return root;
        }
        peg$result = peg$startRuleFunction();
        if (peg$result !== peg$FAILED && peg$currPos === input.length) {
          return peg$result;
        } else {
          if (peg$result !== peg$FAILED && peg$currPos < input.length) {
            peg$fail(peg$endExpectation());
          }
          throw peg$buildStructuredError(
            peg$maxFailExpected,
            peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
            peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
          );
        }
      }
      return {
        SyntaxError: peg$SyntaxError,
        parse: peg$parse
      };
    });
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports) {
    "use strict";
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          var item = list[i];
          if (predicate.call(void 0, item, i, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports.assign = assign;
    exports.find = find;
    exports.freeze = freeze;
    exports.MIME_TYPE = MIME_TYPE;
    exports.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports) {
    var conventions = require_conventions();
    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        if (Object.prototype.hasOwnProperty.call(src, p)) {
          dest[p] = src[p];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t2 = function() {
        };
        var t = t2;
        ;
        t2.prototype = Super.prototype;
        t2 = new t2();
        copy(pt, t2);
        Class.prototype = pt = t2;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (Object.prototype.hasOwnProperty.call(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node3() {
    }
    Node3.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node3);
    copy(NodeType, Node3.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns3 = newAttr.namespaceURI;
      if (ns3 === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns3 = newAttr.namespaceURI;
      if (ns3 === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node3.DOCUMENT_NODE || node.nodeType === Node3.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node3.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node3.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node3.COMMENT_NODE || node.nodeType === Node3.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node3.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node3.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node3.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node3.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node3.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node3.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node3.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
        var targetDoc = parent.ownerDocument || parent;
        _updateOwnerDocument(newFirst, targetDoc);
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _updateOwnerDocument(node, newOwnerDocument) {
      if (node.ownerDocument === newOwnerDocument) {
        return;
      }
      node.ownerDocument = newOwnerDocument;
      if (node.nodeType === ELEMENT_NODE && node.attributes) {
        for (var i = 0; i < node.attributes.length; i++) {
          var attr = node.attributes.item(i);
          if (attr) {
            attr.ownerDocument = newOwnerDocument;
          }
        }
      }
      var child = node.firstChild;
      while (child) {
        _updateOwnerDocument(child, newOwnerDocument);
        child = child.nextSibling;
      }
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      var targetDoc = parentNode.ownerDocument || parentNode;
      _updateOwnerDocument(newChild, targetDoc);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        _updateOwnerDocument(newChild, this);
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        _updateOwnerDocument(newChild, this);
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node3);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node3);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node3);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node3);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node3);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node3);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node3);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node3);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node3);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node3);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node3.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns3 = visibleNamespaces[i];
        if (ns3.prefix === prefix) {
          return ns3.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        //case ENTITY_NODE:
        //case NOTATION_NODE:
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        //var attrs = node2.attributes;
        //var len = attrs.length;
        //for(var i=0;i<len;i++){
        //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
        //}
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        if (Object.prototype.hasOwnProperty.call(node, n)) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node3.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent;
    exports.DocumentType = DocumentType;
    exports.DOMException = DOMException;
    exports.DOMImplementation = DOMImplementation;
    exports.Element = Element;
    exports.Node = Node3;
    exports.NodeList = NodeList;
    exports.XMLSerializer = XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports.HTML_ENTITIES = freeze({
      Aacute: "Á",
      aacute: "á",
      Abreve: "Ă",
      abreve: "ă",
      ac: "∾",
      acd: "∿",
      acE: "∾̳",
      Acirc: "Â",
      acirc: "â",
      acute: "´",
      Acy: "А",
      acy: "а",
      AElig: "Æ",
      aelig: "æ",
      af: "⁡",
      Afr: "𝔄",
      afr: "𝔞",
      Agrave: "À",
      agrave: "à",
      alefsym: "ℵ",
      aleph: "ℵ",
      Alpha: "Α",
      alpha: "α",
      Amacr: "Ā",
      amacr: "ā",
      amalg: "⨿",
      AMP: "&",
      amp: "&",
      And: "⩓",
      and: "∧",
      andand: "⩕",
      andd: "⩜",
      andslope: "⩘",
      andv: "⩚",
      ang: "∠",
      ange: "⦤",
      angle: "∠",
      angmsd: "∡",
      angmsdaa: "⦨",
      angmsdab: "⦩",
      angmsdac: "⦪",
      angmsdad: "⦫",
      angmsdae: "⦬",
      angmsdaf: "⦭",
      angmsdag: "⦮",
      angmsdah: "⦯",
      angrt: "∟",
      angrtvb: "⊾",
      angrtvbd: "⦝",
      angsph: "∢",
      angst: "Å",
      angzarr: "⍼",
      Aogon: "Ą",
      aogon: "ą",
      Aopf: "𝔸",
      aopf: "𝕒",
      ap: "≈",
      apacir: "⩯",
      apE: "⩰",
      ape: "≊",
      apid: "≋",
      apos: "'",
      ApplyFunction: "⁡",
      approx: "≈",
      approxeq: "≊",
      Aring: "Å",
      aring: "å",
      Ascr: "𝒜",
      ascr: "𝒶",
      Assign: "≔",
      ast: "*",
      asymp: "≈",
      asympeq: "≍",
      Atilde: "Ã",
      atilde: "ã",
      Auml: "Ä",
      auml: "ä",
      awconint: "∳",
      awint: "⨑",
      backcong: "≌",
      backepsilon: "϶",
      backprime: "‵",
      backsim: "∽",
      backsimeq: "⋍",
      Backslash: "∖",
      Barv: "⫧",
      barvee: "⊽",
      Barwed: "⌆",
      barwed: "⌅",
      barwedge: "⌅",
      bbrk: "⎵",
      bbrktbrk: "⎶",
      bcong: "≌",
      Bcy: "Б",
      bcy: "б",
      bdquo: "„",
      becaus: "∵",
      Because: "∵",
      because: "∵",
      bemptyv: "⦰",
      bepsi: "϶",
      bernou: "ℬ",
      Bernoullis: "ℬ",
      Beta: "Β",
      beta: "β",
      beth: "ℶ",
      between: "≬",
      Bfr: "𝔅",
      bfr: "𝔟",
      bigcap: "⋂",
      bigcirc: "◯",
      bigcup: "⋃",
      bigodot: "⨀",
      bigoplus: "⨁",
      bigotimes: "⨂",
      bigsqcup: "⨆",
      bigstar: "★",
      bigtriangledown: "▽",
      bigtriangleup: "△",
      biguplus: "⨄",
      bigvee: "⋁",
      bigwedge: "⋀",
      bkarow: "⤍",
      blacklozenge: "⧫",
      blacksquare: "▪",
      blacktriangle: "▴",
      blacktriangledown: "▾",
      blacktriangleleft: "◂",
      blacktriangleright: "▸",
      blank: "␣",
      blk12: "▒",
      blk14: "░",
      blk34: "▓",
      block: "█",
      bne: "=⃥",
      bnequiv: "≡⃥",
      bNot: "⫭",
      bnot: "⌐",
      Bopf: "𝔹",
      bopf: "𝕓",
      bot: "⊥",
      bottom: "⊥",
      bowtie: "⋈",
      boxbox: "⧉",
      boxDL: "╗",
      boxDl: "╖",
      boxdL: "╕",
      boxdl: "┐",
      boxDR: "╔",
      boxDr: "╓",
      boxdR: "╒",
      boxdr: "┌",
      boxH: "═",
      boxh: "─",
      boxHD: "╦",
      boxHd: "╤",
      boxhD: "╥",
      boxhd: "┬",
      boxHU: "╩",
      boxHu: "╧",
      boxhU: "╨",
      boxhu: "┴",
      boxminus: "⊟",
      boxplus: "⊞",
      boxtimes: "⊠",
      boxUL: "╝",
      boxUl: "╜",
      boxuL: "╛",
      boxul: "┘",
      boxUR: "╚",
      boxUr: "╙",
      boxuR: "╘",
      boxur: "└",
      boxV: "║",
      boxv: "│",
      boxVH: "╬",
      boxVh: "╫",
      boxvH: "╪",
      boxvh: "┼",
      boxVL: "╣",
      boxVl: "╢",
      boxvL: "╡",
      boxvl: "┤",
      boxVR: "╠",
      boxVr: "╟",
      boxvR: "╞",
      boxvr: "├",
      bprime: "‵",
      Breve: "˘",
      breve: "˘",
      brvbar: "¦",
      Bscr: "ℬ",
      bscr: "𝒷",
      bsemi: "⁏",
      bsim: "∽",
      bsime: "⋍",
      bsol: "\\",
      bsolb: "⧅",
      bsolhsub: "⟈",
      bull: "•",
      bullet: "•",
      bump: "≎",
      bumpE: "⪮",
      bumpe: "≏",
      Bumpeq: "≎",
      bumpeq: "≏",
      Cacute: "Ć",
      cacute: "ć",
      Cap: "⋒",
      cap: "∩",
      capand: "⩄",
      capbrcup: "⩉",
      capcap: "⩋",
      capcup: "⩇",
      capdot: "⩀",
      CapitalDifferentialD: "ⅅ",
      caps: "∩︀",
      caret: "⁁",
      caron: "ˇ",
      Cayleys: "ℭ",
      ccaps: "⩍",
      Ccaron: "Č",
      ccaron: "č",
      Ccedil: "Ç",
      ccedil: "ç",
      Ccirc: "Ĉ",
      ccirc: "ĉ",
      Cconint: "∰",
      ccups: "⩌",
      ccupssm: "⩐",
      Cdot: "Ċ",
      cdot: "ċ",
      cedil: "¸",
      Cedilla: "¸",
      cemptyv: "⦲",
      cent: "¢",
      CenterDot: "·",
      centerdot: "·",
      Cfr: "ℭ",
      cfr: "𝔠",
      CHcy: "Ч",
      chcy: "ч",
      check: "✓",
      checkmark: "✓",
      Chi: "Χ",
      chi: "χ",
      cir: "○",
      circ: "ˆ",
      circeq: "≗",
      circlearrowleft: "↺",
      circlearrowright: "↻",
      circledast: "⊛",
      circledcirc: "⊚",
      circleddash: "⊝",
      CircleDot: "⊙",
      circledR: "®",
      circledS: "Ⓢ",
      CircleMinus: "⊖",
      CirclePlus: "⊕",
      CircleTimes: "⊗",
      cirE: "⧃",
      cire: "≗",
      cirfnint: "⨐",
      cirmid: "⫯",
      cirscir: "⧂",
      ClockwiseContourIntegral: "∲",
      CloseCurlyDoubleQuote: "”",
      CloseCurlyQuote: "’",
      clubs: "♣",
      clubsuit: "♣",
      Colon: "∷",
      colon: ":",
      Colone: "⩴",
      colone: "≔",
      coloneq: "≔",
      comma: ",",
      commat: "@",
      comp: "∁",
      compfn: "∘",
      complement: "∁",
      complexes: "ℂ",
      cong: "≅",
      congdot: "⩭",
      Congruent: "≡",
      Conint: "∯",
      conint: "∮",
      ContourIntegral: "∮",
      Copf: "ℂ",
      copf: "𝕔",
      coprod: "∐",
      Coproduct: "∐",
      COPY: "©",
      copy: "©",
      copysr: "℗",
      CounterClockwiseContourIntegral: "∳",
      crarr: "↵",
      Cross: "⨯",
      cross: "✗",
      Cscr: "𝒞",
      cscr: "𝒸",
      csub: "⫏",
      csube: "⫑",
      csup: "⫐",
      csupe: "⫒",
      ctdot: "⋯",
      cudarrl: "⤸",
      cudarrr: "⤵",
      cuepr: "⋞",
      cuesc: "⋟",
      cularr: "↶",
      cularrp: "⤽",
      Cup: "⋓",
      cup: "∪",
      cupbrcap: "⩈",
      CupCap: "≍",
      cupcap: "⩆",
      cupcup: "⩊",
      cupdot: "⊍",
      cupor: "⩅",
      cups: "∪︀",
      curarr: "↷",
      curarrm: "⤼",
      curlyeqprec: "⋞",
      curlyeqsucc: "⋟",
      curlyvee: "⋎",
      curlywedge: "⋏",
      curren: "¤",
      curvearrowleft: "↶",
      curvearrowright: "↷",
      cuvee: "⋎",
      cuwed: "⋏",
      cwconint: "∲",
      cwint: "∱",
      cylcty: "⌭",
      Dagger: "‡",
      dagger: "†",
      daleth: "ℸ",
      Darr: "↡",
      dArr: "⇓",
      darr: "↓",
      dash: "‐",
      Dashv: "⫤",
      dashv: "⊣",
      dbkarow: "⤏",
      dblac: "˝",
      Dcaron: "Ď",
      dcaron: "ď",
      Dcy: "Д",
      dcy: "д",
      DD: "ⅅ",
      dd: "ⅆ",
      ddagger: "‡",
      ddarr: "⇊",
      DDotrahd: "⤑",
      ddotseq: "⩷",
      deg: "°",
      Del: "∇",
      Delta: "Δ",
      delta: "δ",
      demptyv: "⦱",
      dfisht: "⥿",
      Dfr: "𝔇",
      dfr: "𝔡",
      dHar: "⥥",
      dharl: "⇃",
      dharr: "⇂",
      DiacriticalAcute: "´",
      DiacriticalDot: "˙",
      DiacriticalDoubleAcute: "˝",
      DiacriticalGrave: "`",
      DiacriticalTilde: "˜",
      diam: "⋄",
      Diamond: "⋄",
      diamond: "⋄",
      diamondsuit: "♦",
      diams: "♦",
      die: "¨",
      DifferentialD: "ⅆ",
      digamma: "ϝ",
      disin: "⋲",
      div: "÷",
      divide: "÷",
      divideontimes: "⋇",
      divonx: "⋇",
      DJcy: "Ђ",
      djcy: "ђ",
      dlcorn: "⌞",
      dlcrop: "⌍",
      dollar: "$",
      Dopf: "𝔻",
      dopf: "𝕕",
      Dot: "¨",
      dot: "˙",
      DotDot: "⃜",
      doteq: "≐",
      doteqdot: "≑",
      DotEqual: "≐",
      dotminus: "∸",
      dotplus: "∔",
      dotsquare: "⊡",
      doublebarwedge: "⌆",
      DoubleContourIntegral: "∯",
      DoubleDot: "¨",
      DoubleDownArrow: "⇓",
      DoubleLeftArrow: "⇐",
      DoubleLeftRightArrow: "⇔",
      DoubleLeftTee: "⫤",
      DoubleLongLeftArrow: "⟸",
      DoubleLongLeftRightArrow: "⟺",
      DoubleLongRightArrow: "⟹",
      DoubleRightArrow: "⇒",
      DoubleRightTee: "⊨",
      DoubleUpArrow: "⇑",
      DoubleUpDownArrow: "⇕",
      DoubleVerticalBar: "∥",
      DownArrow: "↓",
      Downarrow: "⇓",
      downarrow: "↓",
      DownArrowBar: "⤓",
      DownArrowUpArrow: "⇵",
      DownBreve: "̑",
      downdownarrows: "⇊",
      downharpoonleft: "⇃",
      downharpoonright: "⇂",
      DownLeftRightVector: "⥐",
      DownLeftTeeVector: "⥞",
      DownLeftVector: "↽",
      DownLeftVectorBar: "⥖",
      DownRightTeeVector: "⥟",
      DownRightVector: "⇁",
      DownRightVectorBar: "⥗",
      DownTee: "⊤",
      DownTeeArrow: "↧",
      drbkarow: "⤐",
      drcorn: "⌟",
      drcrop: "⌌",
      Dscr: "𝒟",
      dscr: "𝒹",
      DScy: "Ѕ",
      dscy: "ѕ",
      dsol: "⧶",
      Dstrok: "Đ",
      dstrok: "đ",
      dtdot: "⋱",
      dtri: "▿",
      dtrif: "▾",
      duarr: "⇵",
      duhar: "⥯",
      dwangle: "⦦",
      DZcy: "Џ",
      dzcy: "џ",
      dzigrarr: "⟿",
      Eacute: "É",
      eacute: "é",
      easter: "⩮",
      Ecaron: "Ě",
      ecaron: "ě",
      ecir: "≖",
      Ecirc: "Ê",
      ecirc: "ê",
      ecolon: "≕",
      Ecy: "Э",
      ecy: "э",
      eDDot: "⩷",
      Edot: "Ė",
      eDot: "≑",
      edot: "ė",
      ee: "ⅇ",
      efDot: "≒",
      Efr: "𝔈",
      efr: "𝔢",
      eg: "⪚",
      Egrave: "È",
      egrave: "è",
      egs: "⪖",
      egsdot: "⪘",
      el: "⪙",
      Element: "∈",
      elinters: "⏧",
      ell: "ℓ",
      els: "⪕",
      elsdot: "⪗",
      Emacr: "Ē",
      emacr: "ē",
      empty: "∅",
      emptyset: "∅",
      EmptySmallSquare: "◻",
      emptyv: "∅",
      EmptyVerySmallSquare: "▫",
      emsp: " ",
      emsp13: " ",
      emsp14: " ",
      ENG: "Ŋ",
      eng: "ŋ",
      ensp: " ",
      Eogon: "Ę",
      eogon: "ę",
      Eopf: "𝔼",
      eopf: "𝕖",
      epar: "⋕",
      eparsl: "⧣",
      eplus: "⩱",
      epsi: "ε",
      Epsilon: "Ε",
      epsilon: "ε",
      epsiv: "ϵ",
      eqcirc: "≖",
      eqcolon: "≕",
      eqsim: "≂",
      eqslantgtr: "⪖",
      eqslantless: "⪕",
      Equal: "⩵",
      equals: "=",
      EqualTilde: "≂",
      equest: "≟",
      Equilibrium: "⇌",
      equiv: "≡",
      equivDD: "⩸",
      eqvparsl: "⧥",
      erarr: "⥱",
      erDot: "≓",
      Escr: "ℰ",
      escr: "ℯ",
      esdot: "≐",
      Esim: "⩳",
      esim: "≂",
      Eta: "Η",
      eta: "η",
      ETH: "Ð",
      eth: "ð",
      Euml: "Ë",
      euml: "ë",
      euro: "€",
      excl: "!",
      exist: "∃",
      Exists: "∃",
      expectation: "ℰ",
      ExponentialE: "ⅇ",
      exponentiale: "ⅇ",
      fallingdotseq: "≒",
      Fcy: "Ф",
      fcy: "ф",
      female: "♀",
      ffilig: "ﬃ",
      fflig: "ﬀ",
      ffllig: "ﬄ",
      Ffr: "𝔉",
      ffr: "𝔣",
      filig: "ﬁ",
      FilledSmallSquare: "◼",
      FilledVerySmallSquare: "▪",
      fjlig: "fj",
      flat: "♭",
      fllig: "ﬂ",
      fltns: "▱",
      fnof: "ƒ",
      Fopf: "𝔽",
      fopf: "𝕗",
      ForAll: "∀",
      forall: "∀",
      fork: "⋔",
      forkv: "⫙",
      Fouriertrf: "ℱ",
      fpartint: "⨍",
      frac12: "½",
      frac13: "⅓",
      frac14: "¼",
      frac15: "⅕",
      frac16: "⅙",
      frac18: "⅛",
      frac23: "⅔",
      frac25: "⅖",
      frac34: "¾",
      frac35: "⅗",
      frac38: "⅜",
      frac45: "⅘",
      frac56: "⅚",
      frac58: "⅝",
      frac78: "⅞",
      frasl: "⁄",
      frown: "⌢",
      Fscr: "ℱ",
      fscr: "𝒻",
      gacute: "ǵ",
      Gamma: "Γ",
      gamma: "γ",
      Gammad: "Ϝ",
      gammad: "ϝ",
      gap: "⪆",
      Gbreve: "Ğ",
      gbreve: "ğ",
      Gcedil: "Ģ",
      Gcirc: "Ĝ",
      gcirc: "ĝ",
      Gcy: "Г",
      gcy: "г",
      Gdot: "Ġ",
      gdot: "ġ",
      gE: "≧",
      ge: "≥",
      gEl: "⪌",
      gel: "⋛",
      geq: "≥",
      geqq: "≧",
      geqslant: "⩾",
      ges: "⩾",
      gescc: "⪩",
      gesdot: "⪀",
      gesdoto: "⪂",
      gesdotol: "⪄",
      gesl: "⋛︀",
      gesles: "⪔",
      Gfr: "𝔊",
      gfr: "𝔤",
      Gg: "⋙",
      gg: "≫",
      ggg: "⋙",
      gimel: "ℷ",
      GJcy: "Ѓ",
      gjcy: "ѓ",
      gl: "≷",
      gla: "⪥",
      glE: "⪒",
      glj: "⪤",
      gnap: "⪊",
      gnapprox: "⪊",
      gnE: "≩",
      gne: "⪈",
      gneq: "⪈",
      gneqq: "≩",
      gnsim: "⋧",
      Gopf: "𝔾",
      gopf: "𝕘",
      grave: "`",
      GreaterEqual: "≥",
      GreaterEqualLess: "⋛",
      GreaterFullEqual: "≧",
      GreaterGreater: "⪢",
      GreaterLess: "≷",
      GreaterSlantEqual: "⩾",
      GreaterTilde: "≳",
      Gscr: "𝒢",
      gscr: "ℊ",
      gsim: "≳",
      gsime: "⪎",
      gsiml: "⪐",
      Gt: "≫",
      GT: ">",
      gt: ">",
      gtcc: "⪧",
      gtcir: "⩺",
      gtdot: "⋗",
      gtlPar: "⦕",
      gtquest: "⩼",
      gtrapprox: "⪆",
      gtrarr: "⥸",
      gtrdot: "⋗",
      gtreqless: "⋛",
      gtreqqless: "⪌",
      gtrless: "≷",
      gtrsim: "≳",
      gvertneqq: "≩︀",
      gvnE: "≩︀",
      Hacek: "ˇ",
      hairsp: " ",
      half: "½",
      hamilt: "ℋ",
      HARDcy: "Ъ",
      hardcy: "ъ",
      hArr: "⇔",
      harr: "↔",
      harrcir: "⥈",
      harrw: "↭",
      Hat: "^",
      hbar: "ℏ",
      Hcirc: "Ĥ",
      hcirc: "ĥ",
      hearts: "♥",
      heartsuit: "♥",
      hellip: "…",
      hercon: "⊹",
      Hfr: "ℌ",
      hfr: "𝔥",
      HilbertSpace: "ℋ",
      hksearow: "⤥",
      hkswarow: "⤦",
      hoarr: "⇿",
      homtht: "∻",
      hookleftarrow: "↩",
      hookrightarrow: "↪",
      Hopf: "ℍ",
      hopf: "𝕙",
      horbar: "―",
      HorizontalLine: "─",
      Hscr: "ℋ",
      hscr: "𝒽",
      hslash: "ℏ",
      Hstrok: "Ħ",
      hstrok: "ħ",
      HumpDownHump: "≎",
      HumpEqual: "≏",
      hybull: "⁃",
      hyphen: "‐",
      Iacute: "Í",
      iacute: "í",
      ic: "⁣",
      Icirc: "Î",
      icirc: "î",
      Icy: "И",
      icy: "и",
      Idot: "İ",
      IEcy: "Е",
      iecy: "е",
      iexcl: "¡",
      iff: "⇔",
      Ifr: "ℑ",
      ifr: "𝔦",
      Igrave: "Ì",
      igrave: "ì",
      ii: "ⅈ",
      iiiint: "⨌",
      iiint: "∭",
      iinfin: "⧜",
      iiota: "℩",
      IJlig: "Ĳ",
      ijlig: "ĳ",
      Im: "ℑ",
      Imacr: "Ī",
      imacr: "ī",
      image: "ℑ",
      ImaginaryI: "ⅈ",
      imagline: "ℐ",
      imagpart: "ℑ",
      imath: "ı",
      imof: "⊷",
      imped: "Ƶ",
      Implies: "⇒",
      in: "∈",
      incare: "℅",
      infin: "∞",
      infintie: "⧝",
      inodot: "ı",
      Int: "∬",
      int: "∫",
      intcal: "⊺",
      integers: "ℤ",
      Integral: "∫",
      intercal: "⊺",
      Intersection: "⋂",
      intlarhk: "⨗",
      intprod: "⨼",
      InvisibleComma: "⁣",
      InvisibleTimes: "⁢",
      IOcy: "Ё",
      iocy: "ё",
      Iogon: "Į",
      iogon: "į",
      Iopf: "𝕀",
      iopf: "𝕚",
      Iota: "Ι",
      iota: "ι",
      iprod: "⨼",
      iquest: "¿",
      Iscr: "ℐ",
      iscr: "𝒾",
      isin: "∈",
      isindot: "⋵",
      isinE: "⋹",
      isins: "⋴",
      isinsv: "⋳",
      isinv: "∈",
      it: "⁢",
      Itilde: "Ĩ",
      itilde: "ĩ",
      Iukcy: "І",
      iukcy: "і",
      Iuml: "Ï",
      iuml: "ï",
      Jcirc: "Ĵ",
      jcirc: "ĵ",
      Jcy: "Й",
      jcy: "й",
      Jfr: "𝔍",
      jfr: "𝔧",
      jmath: "ȷ",
      Jopf: "𝕁",
      jopf: "𝕛",
      Jscr: "𝒥",
      jscr: "𝒿",
      Jsercy: "Ј",
      jsercy: "ј",
      Jukcy: "Є",
      jukcy: "є",
      Kappa: "Κ",
      kappa: "κ",
      kappav: "ϰ",
      Kcedil: "Ķ",
      kcedil: "ķ",
      Kcy: "К",
      kcy: "к",
      Kfr: "𝔎",
      kfr: "𝔨",
      kgreen: "ĸ",
      KHcy: "Х",
      khcy: "х",
      KJcy: "Ќ",
      kjcy: "ќ",
      Kopf: "𝕂",
      kopf: "𝕜",
      Kscr: "𝒦",
      kscr: "𝓀",
      lAarr: "⇚",
      Lacute: "Ĺ",
      lacute: "ĺ",
      laemptyv: "⦴",
      lagran: "ℒ",
      Lambda: "Λ",
      lambda: "λ",
      Lang: "⟪",
      lang: "⟨",
      langd: "⦑",
      langle: "⟨",
      lap: "⪅",
      Laplacetrf: "ℒ",
      laquo: "«",
      Larr: "↞",
      lArr: "⇐",
      larr: "←",
      larrb: "⇤",
      larrbfs: "⤟",
      larrfs: "⤝",
      larrhk: "↩",
      larrlp: "↫",
      larrpl: "⤹",
      larrsim: "⥳",
      larrtl: "↢",
      lat: "⪫",
      lAtail: "⤛",
      latail: "⤙",
      late: "⪭",
      lates: "⪭︀",
      lBarr: "⤎",
      lbarr: "⤌",
      lbbrk: "❲",
      lbrace: "{",
      lbrack: "[",
      lbrke: "⦋",
      lbrksld: "⦏",
      lbrkslu: "⦍",
      Lcaron: "Ľ",
      lcaron: "ľ",
      Lcedil: "Ļ",
      lcedil: "ļ",
      lceil: "⌈",
      lcub: "{",
      Lcy: "Л",
      lcy: "л",
      ldca: "⤶",
      ldquo: "“",
      ldquor: "„",
      ldrdhar: "⥧",
      ldrushar: "⥋",
      ldsh: "↲",
      lE: "≦",
      le: "≤",
      LeftAngleBracket: "⟨",
      LeftArrow: "←",
      Leftarrow: "⇐",
      leftarrow: "←",
      LeftArrowBar: "⇤",
      LeftArrowRightArrow: "⇆",
      leftarrowtail: "↢",
      LeftCeiling: "⌈",
      LeftDoubleBracket: "⟦",
      LeftDownTeeVector: "⥡",
      LeftDownVector: "⇃",
      LeftDownVectorBar: "⥙",
      LeftFloor: "⌊",
      leftharpoondown: "↽",
      leftharpoonup: "↼",
      leftleftarrows: "⇇",
      LeftRightArrow: "↔",
      Leftrightarrow: "⇔",
      leftrightarrow: "↔",
      leftrightarrows: "⇆",
      leftrightharpoons: "⇋",
      leftrightsquigarrow: "↭",
      LeftRightVector: "⥎",
      LeftTee: "⊣",
      LeftTeeArrow: "↤",
      LeftTeeVector: "⥚",
      leftthreetimes: "⋋",
      LeftTriangle: "⊲",
      LeftTriangleBar: "⧏",
      LeftTriangleEqual: "⊴",
      LeftUpDownVector: "⥑",
      LeftUpTeeVector: "⥠",
      LeftUpVector: "↿",
      LeftUpVectorBar: "⥘",
      LeftVector: "↼",
      LeftVectorBar: "⥒",
      lEg: "⪋",
      leg: "⋚",
      leq: "≤",
      leqq: "≦",
      leqslant: "⩽",
      les: "⩽",
      lescc: "⪨",
      lesdot: "⩿",
      lesdoto: "⪁",
      lesdotor: "⪃",
      lesg: "⋚︀",
      lesges: "⪓",
      lessapprox: "⪅",
      lessdot: "⋖",
      lesseqgtr: "⋚",
      lesseqqgtr: "⪋",
      LessEqualGreater: "⋚",
      LessFullEqual: "≦",
      LessGreater: "≶",
      lessgtr: "≶",
      LessLess: "⪡",
      lesssim: "≲",
      LessSlantEqual: "⩽",
      LessTilde: "≲",
      lfisht: "⥼",
      lfloor: "⌊",
      Lfr: "𝔏",
      lfr: "𝔩",
      lg: "≶",
      lgE: "⪑",
      lHar: "⥢",
      lhard: "↽",
      lharu: "↼",
      lharul: "⥪",
      lhblk: "▄",
      LJcy: "Љ",
      ljcy: "љ",
      Ll: "⋘",
      ll: "≪",
      llarr: "⇇",
      llcorner: "⌞",
      Lleftarrow: "⇚",
      llhard: "⥫",
      lltri: "◺",
      Lmidot: "Ŀ",
      lmidot: "ŀ",
      lmoust: "⎰",
      lmoustache: "⎰",
      lnap: "⪉",
      lnapprox: "⪉",
      lnE: "≨",
      lne: "⪇",
      lneq: "⪇",
      lneqq: "≨",
      lnsim: "⋦",
      loang: "⟬",
      loarr: "⇽",
      lobrk: "⟦",
      LongLeftArrow: "⟵",
      Longleftarrow: "⟸",
      longleftarrow: "⟵",
      LongLeftRightArrow: "⟷",
      Longleftrightarrow: "⟺",
      longleftrightarrow: "⟷",
      longmapsto: "⟼",
      LongRightArrow: "⟶",
      Longrightarrow: "⟹",
      longrightarrow: "⟶",
      looparrowleft: "↫",
      looparrowright: "↬",
      lopar: "⦅",
      Lopf: "𝕃",
      lopf: "𝕝",
      loplus: "⨭",
      lotimes: "⨴",
      lowast: "∗",
      lowbar: "_",
      LowerLeftArrow: "↙",
      LowerRightArrow: "↘",
      loz: "◊",
      lozenge: "◊",
      lozf: "⧫",
      lpar: "(",
      lparlt: "⦓",
      lrarr: "⇆",
      lrcorner: "⌟",
      lrhar: "⇋",
      lrhard: "⥭",
      lrm: "‎",
      lrtri: "⊿",
      lsaquo: "‹",
      Lscr: "ℒ",
      lscr: "𝓁",
      Lsh: "↰",
      lsh: "↰",
      lsim: "≲",
      lsime: "⪍",
      lsimg: "⪏",
      lsqb: "[",
      lsquo: "‘",
      lsquor: "‚",
      Lstrok: "Ł",
      lstrok: "ł",
      Lt: "≪",
      LT: "<",
      lt: "<",
      ltcc: "⪦",
      ltcir: "⩹",
      ltdot: "⋖",
      lthree: "⋋",
      ltimes: "⋉",
      ltlarr: "⥶",
      ltquest: "⩻",
      ltri: "◃",
      ltrie: "⊴",
      ltrif: "◂",
      ltrPar: "⦖",
      lurdshar: "⥊",
      luruhar: "⥦",
      lvertneqq: "≨︀",
      lvnE: "≨︀",
      macr: "¯",
      male: "♂",
      malt: "✠",
      maltese: "✠",
      Map: "⤅",
      map: "↦",
      mapsto: "↦",
      mapstodown: "↧",
      mapstoleft: "↤",
      mapstoup: "↥",
      marker: "▮",
      mcomma: "⨩",
      Mcy: "М",
      mcy: "м",
      mdash: "—",
      mDDot: "∺",
      measuredangle: "∡",
      MediumSpace: " ",
      Mellintrf: "ℳ",
      Mfr: "𝔐",
      mfr: "𝔪",
      mho: "℧",
      micro: "µ",
      mid: "∣",
      midast: "*",
      midcir: "⫰",
      middot: "·",
      minus: "−",
      minusb: "⊟",
      minusd: "∸",
      minusdu: "⨪",
      MinusPlus: "∓",
      mlcp: "⫛",
      mldr: "…",
      mnplus: "∓",
      models: "⊧",
      Mopf: "𝕄",
      mopf: "𝕞",
      mp: "∓",
      Mscr: "ℳ",
      mscr: "𝓂",
      mstpos: "∾",
      Mu: "Μ",
      mu: "μ",
      multimap: "⊸",
      mumap: "⊸",
      nabla: "∇",
      Nacute: "Ń",
      nacute: "ń",
      nang: "∠⃒",
      nap: "≉",
      napE: "⩰̸",
      napid: "≋̸",
      napos: "ŉ",
      napprox: "≉",
      natur: "♮",
      natural: "♮",
      naturals: "ℕ",
      nbsp: " ",
      nbump: "≎̸",
      nbumpe: "≏̸",
      ncap: "⩃",
      Ncaron: "Ň",
      ncaron: "ň",
      Ncedil: "Ņ",
      ncedil: "ņ",
      ncong: "≇",
      ncongdot: "⩭̸",
      ncup: "⩂",
      Ncy: "Н",
      ncy: "н",
      ndash: "–",
      ne: "≠",
      nearhk: "⤤",
      neArr: "⇗",
      nearr: "↗",
      nearrow: "↗",
      nedot: "≐̸",
      NegativeMediumSpace: "​",
      NegativeThickSpace: "​",
      NegativeThinSpace: "​",
      NegativeVeryThinSpace: "​",
      nequiv: "≢",
      nesear: "⤨",
      nesim: "≂̸",
      NestedGreaterGreater: "≫",
      NestedLessLess: "≪",
      NewLine: "\n",
      nexist: "∄",
      nexists: "∄",
      Nfr: "𝔑",
      nfr: "𝔫",
      ngE: "≧̸",
      nge: "≱",
      ngeq: "≱",
      ngeqq: "≧̸",
      ngeqslant: "⩾̸",
      nges: "⩾̸",
      nGg: "⋙̸",
      ngsim: "≵",
      nGt: "≫⃒",
      ngt: "≯",
      ngtr: "≯",
      nGtv: "≫̸",
      nhArr: "⇎",
      nharr: "↮",
      nhpar: "⫲",
      ni: "∋",
      nis: "⋼",
      nisd: "⋺",
      niv: "∋",
      NJcy: "Њ",
      njcy: "њ",
      nlArr: "⇍",
      nlarr: "↚",
      nldr: "‥",
      nlE: "≦̸",
      nle: "≰",
      nLeftarrow: "⇍",
      nleftarrow: "↚",
      nLeftrightarrow: "⇎",
      nleftrightarrow: "↮",
      nleq: "≰",
      nleqq: "≦̸",
      nleqslant: "⩽̸",
      nles: "⩽̸",
      nless: "≮",
      nLl: "⋘̸",
      nlsim: "≴",
      nLt: "≪⃒",
      nlt: "≮",
      nltri: "⋪",
      nltrie: "⋬",
      nLtv: "≪̸",
      nmid: "∤",
      NoBreak: "⁠",
      NonBreakingSpace: " ",
      Nopf: "ℕ",
      nopf: "𝕟",
      Not: "⫬",
      not: "¬",
      NotCongruent: "≢",
      NotCupCap: "≭",
      NotDoubleVerticalBar: "∦",
      NotElement: "∉",
      NotEqual: "≠",
      NotEqualTilde: "≂̸",
      NotExists: "∄",
      NotGreater: "≯",
      NotGreaterEqual: "≱",
      NotGreaterFullEqual: "≧̸",
      NotGreaterGreater: "≫̸",
      NotGreaterLess: "≹",
      NotGreaterSlantEqual: "⩾̸",
      NotGreaterTilde: "≵",
      NotHumpDownHump: "≎̸",
      NotHumpEqual: "≏̸",
      notin: "∉",
      notindot: "⋵̸",
      notinE: "⋹̸",
      notinva: "∉",
      notinvb: "⋷",
      notinvc: "⋶",
      NotLeftTriangle: "⋪",
      NotLeftTriangleBar: "⧏̸",
      NotLeftTriangleEqual: "⋬",
      NotLess: "≮",
      NotLessEqual: "≰",
      NotLessGreater: "≸",
      NotLessLess: "≪̸",
      NotLessSlantEqual: "⩽̸",
      NotLessTilde: "≴",
      NotNestedGreaterGreater: "⪢̸",
      NotNestedLessLess: "⪡̸",
      notni: "∌",
      notniva: "∌",
      notnivb: "⋾",
      notnivc: "⋽",
      NotPrecedes: "⊀",
      NotPrecedesEqual: "⪯̸",
      NotPrecedesSlantEqual: "⋠",
      NotReverseElement: "∌",
      NotRightTriangle: "⋫",
      NotRightTriangleBar: "⧐̸",
      NotRightTriangleEqual: "⋭",
      NotSquareSubset: "⊏̸",
      NotSquareSubsetEqual: "⋢",
      NotSquareSuperset: "⊐̸",
      NotSquareSupersetEqual: "⋣",
      NotSubset: "⊂⃒",
      NotSubsetEqual: "⊈",
      NotSucceeds: "⊁",
      NotSucceedsEqual: "⪰̸",
      NotSucceedsSlantEqual: "⋡",
      NotSucceedsTilde: "≿̸",
      NotSuperset: "⊃⃒",
      NotSupersetEqual: "⊉",
      NotTilde: "≁",
      NotTildeEqual: "≄",
      NotTildeFullEqual: "≇",
      NotTildeTilde: "≉",
      NotVerticalBar: "∤",
      npar: "∦",
      nparallel: "∦",
      nparsl: "⫽⃥",
      npart: "∂̸",
      npolint: "⨔",
      npr: "⊀",
      nprcue: "⋠",
      npre: "⪯̸",
      nprec: "⊀",
      npreceq: "⪯̸",
      nrArr: "⇏",
      nrarr: "↛",
      nrarrc: "⤳̸",
      nrarrw: "↝̸",
      nRightarrow: "⇏",
      nrightarrow: "↛",
      nrtri: "⋫",
      nrtrie: "⋭",
      nsc: "⊁",
      nsccue: "⋡",
      nsce: "⪰̸",
      Nscr: "𝒩",
      nscr: "𝓃",
      nshortmid: "∤",
      nshortparallel: "∦",
      nsim: "≁",
      nsime: "≄",
      nsimeq: "≄",
      nsmid: "∤",
      nspar: "∦",
      nsqsube: "⋢",
      nsqsupe: "⋣",
      nsub: "⊄",
      nsubE: "⫅̸",
      nsube: "⊈",
      nsubset: "⊂⃒",
      nsubseteq: "⊈",
      nsubseteqq: "⫅̸",
      nsucc: "⊁",
      nsucceq: "⪰̸",
      nsup: "⊅",
      nsupE: "⫆̸",
      nsupe: "⊉",
      nsupset: "⊃⃒",
      nsupseteq: "⊉",
      nsupseteqq: "⫆̸",
      ntgl: "≹",
      Ntilde: "Ñ",
      ntilde: "ñ",
      ntlg: "≸",
      ntriangleleft: "⋪",
      ntrianglelefteq: "⋬",
      ntriangleright: "⋫",
      ntrianglerighteq: "⋭",
      Nu: "Ν",
      nu: "ν",
      num: "#",
      numero: "№",
      numsp: " ",
      nvap: "≍⃒",
      nVDash: "⊯",
      nVdash: "⊮",
      nvDash: "⊭",
      nvdash: "⊬",
      nvge: "≥⃒",
      nvgt: ">⃒",
      nvHarr: "⤄",
      nvinfin: "⧞",
      nvlArr: "⤂",
      nvle: "≤⃒",
      nvlt: "<⃒",
      nvltrie: "⊴⃒",
      nvrArr: "⤃",
      nvrtrie: "⊵⃒",
      nvsim: "∼⃒",
      nwarhk: "⤣",
      nwArr: "⇖",
      nwarr: "↖",
      nwarrow: "↖",
      nwnear: "⤧",
      Oacute: "Ó",
      oacute: "ó",
      oast: "⊛",
      ocir: "⊚",
      Ocirc: "Ô",
      ocirc: "ô",
      Ocy: "О",
      ocy: "о",
      odash: "⊝",
      Odblac: "Ő",
      odblac: "ő",
      odiv: "⨸",
      odot: "⊙",
      odsold: "⦼",
      OElig: "Œ",
      oelig: "œ",
      ofcir: "⦿",
      Ofr: "𝔒",
      ofr: "𝔬",
      ogon: "˛",
      Ograve: "Ò",
      ograve: "ò",
      ogt: "⧁",
      ohbar: "⦵",
      ohm: "Ω",
      oint: "∮",
      olarr: "↺",
      olcir: "⦾",
      olcross: "⦻",
      oline: "‾",
      olt: "⧀",
      Omacr: "Ō",
      omacr: "ō",
      Omega: "Ω",
      omega: "ω",
      Omicron: "Ο",
      omicron: "ο",
      omid: "⦶",
      ominus: "⊖",
      Oopf: "𝕆",
      oopf: "𝕠",
      opar: "⦷",
      OpenCurlyDoubleQuote: "“",
      OpenCurlyQuote: "‘",
      operp: "⦹",
      oplus: "⊕",
      Or: "⩔",
      or: "∨",
      orarr: "↻",
      ord: "⩝",
      order: "ℴ",
      orderof: "ℴ",
      ordf: "ª",
      ordm: "º",
      origof: "⊶",
      oror: "⩖",
      orslope: "⩗",
      orv: "⩛",
      oS: "Ⓢ",
      Oscr: "𝒪",
      oscr: "ℴ",
      Oslash: "Ø",
      oslash: "ø",
      osol: "⊘",
      Otilde: "Õ",
      otilde: "õ",
      Otimes: "⨷",
      otimes: "⊗",
      otimesas: "⨶",
      Ouml: "Ö",
      ouml: "ö",
      ovbar: "⌽",
      OverBar: "‾",
      OverBrace: "⏞",
      OverBracket: "⎴",
      OverParenthesis: "⏜",
      par: "∥",
      para: "¶",
      parallel: "∥",
      parsim: "⫳",
      parsl: "⫽",
      part: "∂",
      PartialD: "∂",
      Pcy: "П",
      pcy: "п",
      percnt: "%",
      period: ".",
      permil: "‰",
      perp: "⊥",
      pertenk: "‱",
      Pfr: "𝔓",
      pfr: "𝔭",
      Phi: "Φ",
      phi: "φ",
      phiv: "ϕ",
      phmmat: "ℳ",
      phone: "☎",
      Pi: "Π",
      pi: "π",
      pitchfork: "⋔",
      piv: "ϖ",
      planck: "ℏ",
      planckh: "ℎ",
      plankv: "ℏ",
      plus: "+",
      plusacir: "⨣",
      plusb: "⊞",
      pluscir: "⨢",
      plusdo: "∔",
      plusdu: "⨥",
      pluse: "⩲",
      PlusMinus: "±",
      plusmn: "±",
      plussim: "⨦",
      plustwo: "⨧",
      pm: "±",
      Poincareplane: "ℌ",
      pointint: "⨕",
      Popf: "ℙ",
      popf: "𝕡",
      pound: "£",
      Pr: "⪻",
      pr: "≺",
      prap: "⪷",
      prcue: "≼",
      prE: "⪳",
      pre: "⪯",
      prec: "≺",
      precapprox: "⪷",
      preccurlyeq: "≼",
      Precedes: "≺",
      PrecedesEqual: "⪯",
      PrecedesSlantEqual: "≼",
      PrecedesTilde: "≾",
      preceq: "⪯",
      precnapprox: "⪹",
      precneqq: "⪵",
      precnsim: "⋨",
      precsim: "≾",
      Prime: "″",
      prime: "′",
      primes: "ℙ",
      prnap: "⪹",
      prnE: "⪵",
      prnsim: "⋨",
      prod: "∏",
      Product: "∏",
      profalar: "⌮",
      profline: "⌒",
      profsurf: "⌓",
      prop: "∝",
      Proportion: "∷",
      Proportional: "∝",
      propto: "∝",
      prsim: "≾",
      prurel: "⊰",
      Pscr: "𝒫",
      pscr: "𝓅",
      Psi: "Ψ",
      psi: "ψ",
      puncsp: " ",
      Qfr: "𝔔",
      qfr: "𝔮",
      qint: "⨌",
      Qopf: "ℚ",
      qopf: "𝕢",
      qprime: "⁗",
      Qscr: "𝒬",
      qscr: "𝓆",
      quaternions: "ℍ",
      quatint: "⨖",
      quest: "?",
      questeq: "≟",
      QUOT: '"',
      quot: '"',
      rAarr: "⇛",
      race: "∽̱",
      Racute: "Ŕ",
      racute: "ŕ",
      radic: "√",
      raemptyv: "⦳",
      Rang: "⟫",
      rang: "⟩",
      rangd: "⦒",
      range: "⦥",
      rangle: "⟩",
      raquo: "»",
      Rarr: "↠",
      rArr: "⇒",
      rarr: "→",
      rarrap: "⥵",
      rarrb: "⇥",
      rarrbfs: "⤠",
      rarrc: "⤳",
      rarrfs: "⤞",
      rarrhk: "↪",
      rarrlp: "↬",
      rarrpl: "⥅",
      rarrsim: "⥴",
      Rarrtl: "⤖",
      rarrtl: "↣",
      rarrw: "↝",
      rAtail: "⤜",
      ratail: "⤚",
      ratio: "∶",
      rationals: "ℚ",
      RBarr: "⤐",
      rBarr: "⤏",
      rbarr: "⤍",
      rbbrk: "❳",
      rbrace: "}",
      rbrack: "]",
      rbrke: "⦌",
      rbrksld: "⦎",
      rbrkslu: "⦐",
      Rcaron: "Ř",
      rcaron: "ř",
      Rcedil: "Ŗ",
      rcedil: "ŗ",
      rceil: "⌉",
      rcub: "}",
      Rcy: "Р",
      rcy: "р",
      rdca: "⤷",
      rdldhar: "⥩",
      rdquo: "”",
      rdquor: "”",
      rdsh: "↳",
      Re: "ℜ",
      real: "ℜ",
      realine: "ℛ",
      realpart: "ℜ",
      reals: "ℝ",
      rect: "▭",
      REG: "®",
      reg: "®",
      ReverseElement: "∋",
      ReverseEquilibrium: "⇋",
      ReverseUpEquilibrium: "⥯",
      rfisht: "⥽",
      rfloor: "⌋",
      Rfr: "ℜ",
      rfr: "𝔯",
      rHar: "⥤",
      rhard: "⇁",
      rharu: "⇀",
      rharul: "⥬",
      Rho: "Ρ",
      rho: "ρ",
      rhov: "ϱ",
      RightAngleBracket: "⟩",
      RightArrow: "→",
      Rightarrow: "⇒",
      rightarrow: "→",
      RightArrowBar: "⇥",
      RightArrowLeftArrow: "⇄",
      rightarrowtail: "↣",
      RightCeiling: "⌉",
      RightDoubleBracket: "⟧",
      RightDownTeeVector: "⥝",
      RightDownVector: "⇂",
      RightDownVectorBar: "⥕",
      RightFloor: "⌋",
      rightharpoondown: "⇁",
      rightharpoonup: "⇀",
      rightleftarrows: "⇄",
      rightleftharpoons: "⇌",
      rightrightarrows: "⇉",
      rightsquigarrow: "↝",
      RightTee: "⊢",
      RightTeeArrow: "↦",
      RightTeeVector: "⥛",
      rightthreetimes: "⋌",
      RightTriangle: "⊳",
      RightTriangleBar: "⧐",
      RightTriangleEqual: "⊵",
      RightUpDownVector: "⥏",
      RightUpTeeVector: "⥜",
      RightUpVector: "↾",
      RightUpVectorBar: "⥔",
      RightVector: "⇀",
      RightVectorBar: "⥓",
      ring: "˚",
      risingdotseq: "≓",
      rlarr: "⇄",
      rlhar: "⇌",
      rlm: "‏",
      rmoust: "⎱",
      rmoustache: "⎱",
      rnmid: "⫮",
      roang: "⟭",
      roarr: "⇾",
      robrk: "⟧",
      ropar: "⦆",
      Ropf: "ℝ",
      ropf: "𝕣",
      roplus: "⨮",
      rotimes: "⨵",
      RoundImplies: "⥰",
      rpar: ")",
      rpargt: "⦔",
      rppolint: "⨒",
      rrarr: "⇉",
      Rrightarrow: "⇛",
      rsaquo: "›",
      Rscr: "ℛ",
      rscr: "𝓇",
      Rsh: "↱",
      rsh: "↱",
      rsqb: "]",
      rsquo: "’",
      rsquor: "’",
      rthree: "⋌",
      rtimes: "⋊",
      rtri: "▹",
      rtrie: "⊵",
      rtrif: "▸",
      rtriltri: "⧎",
      RuleDelayed: "⧴",
      ruluhar: "⥨",
      rx: "℞",
      Sacute: "Ś",
      sacute: "ś",
      sbquo: "‚",
      Sc: "⪼",
      sc: "≻",
      scap: "⪸",
      Scaron: "Š",
      scaron: "š",
      sccue: "≽",
      scE: "⪴",
      sce: "⪰",
      Scedil: "Ş",
      scedil: "ş",
      Scirc: "Ŝ",
      scirc: "ŝ",
      scnap: "⪺",
      scnE: "⪶",
      scnsim: "⋩",
      scpolint: "⨓",
      scsim: "≿",
      Scy: "С",
      scy: "с",
      sdot: "⋅",
      sdotb: "⊡",
      sdote: "⩦",
      searhk: "⤥",
      seArr: "⇘",
      searr: "↘",
      searrow: "↘",
      sect: "§",
      semi: ";",
      seswar: "⤩",
      setminus: "∖",
      setmn: "∖",
      sext: "✶",
      Sfr: "𝔖",
      sfr: "𝔰",
      sfrown: "⌢",
      sharp: "♯",
      SHCHcy: "Щ",
      shchcy: "щ",
      SHcy: "Ш",
      shcy: "ш",
      ShortDownArrow: "↓",
      ShortLeftArrow: "←",
      shortmid: "∣",
      shortparallel: "∥",
      ShortRightArrow: "→",
      ShortUpArrow: "↑",
      shy: "­",
      Sigma: "Σ",
      sigma: "σ",
      sigmaf: "ς",
      sigmav: "ς",
      sim: "∼",
      simdot: "⩪",
      sime: "≃",
      simeq: "≃",
      simg: "⪞",
      simgE: "⪠",
      siml: "⪝",
      simlE: "⪟",
      simne: "≆",
      simplus: "⨤",
      simrarr: "⥲",
      slarr: "←",
      SmallCircle: "∘",
      smallsetminus: "∖",
      smashp: "⨳",
      smeparsl: "⧤",
      smid: "∣",
      smile: "⌣",
      smt: "⪪",
      smte: "⪬",
      smtes: "⪬︀",
      SOFTcy: "Ь",
      softcy: "ь",
      sol: "/",
      solb: "⧄",
      solbar: "⌿",
      Sopf: "𝕊",
      sopf: "𝕤",
      spades: "♠",
      spadesuit: "♠",
      spar: "∥",
      sqcap: "⊓",
      sqcaps: "⊓︀",
      sqcup: "⊔",
      sqcups: "⊔︀",
      Sqrt: "√",
      sqsub: "⊏",
      sqsube: "⊑",
      sqsubset: "⊏",
      sqsubseteq: "⊑",
      sqsup: "⊐",
      sqsupe: "⊒",
      sqsupset: "⊐",
      sqsupseteq: "⊒",
      squ: "□",
      Square: "□",
      square: "□",
      SquareIntersection: "⊓",
      SquareSubset: "⊏",
      SquareSubsetEqual: "⊑",
      SquareSuperset: "⊐",
      SquareSupersetEqual: "⊒",
      SquareUnion: "⊔",
      squarf: "▪",
      squf: "▪",
      srarr: "→",
      Sscr: "𝒮",
      sscr: "𝓈",
      ssetmn: "∖",
      ssmile: "⌣",
      sstarf: "⋆",
      Star: "⋆",
      star: "☆",
      starf: "★",
      straightepsilon: "ϵ",
      straightphi: "ϕ",
      strns: "¯",
      Sub: "⋐",
      sub: "⊂",
      subdot: "⪽",
      subE: "⫅",
      sube: "⊆",
      subedot: "⫃",
      submult: "⫁",
      subnE: "⫋",
      subne: "⊊",
      subplus: "⪿",
      subrarr: "⥹",
      Subset: "⋐",
      subset: "⊂",
      subseteq: "⊆",
      subseteqq: "⫅",
      SubsetEqual: "⊆",
      subsetneq: "⊊",
      subsetneqq: "⫋",
      subsim: "⫇",
      subsub: "⫕",
      subsup: "⫓",
      succ: "≻",
      succapprox: "⪸",
      succcurlyeq: "≽",
      Succeeds: "≻",
      SucceedsEqual: "⪰",
      SucceedsSlantEqual: "≽",
      SucceedsTilde: "≿",
      succeq: "⪰",
      succnapprox: "⪺",
      succneqq: "⪶",
      succnsim: "⋩",
      succsim: "≿",
      SuchThat: "∋",
      Sum: "∑",
      sum: "∑",
      sung: "♪",
      Sup: "⋑",
      sup: "⊃",
      sup1: "¹",
      sup2: "²",
      sup3: "³",
      supdot: "⪾",
      supdsub: "⫘",
      supE: "⫆",
      supe: "⊇",
      supedot: "⫄",
      Superset: "⊃",
      SupersetEqual: "⊇",
      suphsol: "⟉",
      suphsub: "⫗",
      suplarr: "⥻",
      supmult: "⫂",
      supnE: "⫌",
      supne: "⊋",
      supplus: "⫀",
      Supset: "⋑",
      supset: "⊃",
      supseteq: "⊇",
      supseteqq: "⫆",
      supsetneq: "⊋",
      supsetneqq: "⫌",
      supsim: "⫈",
      supsub: "⫔",
      supsup: "⫖",
      swarhk: "⤦",
      swArr: "⇙",
      swarr: "↙",
      swarrow: "↙",
      swnwar: "⤪",
      szlig: "ß",
      Tab: "	",
      target: "⌖",
      Tau: "Τ",
      tau: "τ",
      tbrk: "⎴",
      Tcaron: "Ť",
      tcaron: "ť",
      Tcedil: "Ţ",
      tcedil: "ţ",
      Tcy: "Т",
      tcy: "т",
      tdot: "⃛",
      telrec: "⌕",
      Tfr: "𝔗",
      tfr: "𝔱",
      there4: "∴",
      Therefore: "∴",
      therefore: "∴",
      Theta: "Θ",
      theta: "θ",
      thetasym: "ϑ",
      thetav: "ϑ",
      thickapprox: "≈",
      thicksim: "∼",
      ThickSpace: "  ",
      thinsp: " ",
      ThinSpace: " ",
      thkap: "≈",
      thksim: "∼",
      THORN: "Þ",
      thorn: "þ",
      Tilde: "∼",
      tilde: "˜",
      TildeEqual: "≃",
      TildeFullEqual: "≅",
      TildeTilde: "≈",
      times: "×",
      timesb: "⊠",
      timesbar: "⨱",
      timesd: "⨰",
      tint: "∭",
      toea: "⤨",
      top: "⊤",
      topbot: "⌶",
      topcir: "⫱",
      Topf: "𝕋",
      topf: "𝕥",
      topfork: "⫚",
      tosa: "⤩",
      tprime: "‴",
      TRADE: "™",
      trade: "™",
      triangle: "▵",
      triangledown: "▿",
      triangleleft: "◃",
      trianglelefteq: "⊴",
      triangleq: "≜",
      triangleright: "▹",
      trianglerighteq: "⊵",
      tridot: "◬",
      trie: "≜",
      triminus: "⨺",
      TripleDot: "⃛",
      triplus: "⨹",
      trisb: "⧍",
      tritime: "⨻",
      trpezium: "⏢",
      Tscr: "𝒯",
      tscr: "𝓉",
      TScy: "Ц",
      tscy: "ц",
      TSHcy: "Ћ",
      tshcy: "ћ",
      Tstrok: "Ŧ",
      tstrok: "ŧ",
      twixt: "≬",
      twoheadleftarrow: "↞",
      twoheadrightarrow: "↠",
      Uacute: "Ú",
      uacute: "ú",
      Uarr: "↟",
      uArr: "⇑",
      uarr: "↑",
      Uarrocir: "⥉",
      Ubrcy: "Ў",
      ubrcy: "ў",
      Ubreve: "Ŭ",
      ubreve: "ŭ",
      Ucirc: "Û",
      ucirc: "û",
      Ucy: "У",
      ucy: "у",
      udarr: "⇅",
      Udblac: "Ű",
      udblac: "ű",
      udhar: "⥮",
      ufisht: "⥾",
      Ufr: "𝔘",
      ufr: "𝔲",
      Ugrave: "Ù",
      ugrave: "ù",
      uHar: "⥣",
      uharl: "↿",
      uharr: "↾",
      uhblk: "▀",
      ulcorn: "⌜",
      ulcorner: "⌜",
      ulcrop: "⌏",
      ultri: "◸",
      Umacr: "Ū",
      umacr: "ū",
      uml: "¨",
      UnderBar: "_",
      UnderBrace: "⏟",
      UnderBracket: "⎵",
      UnderParenthesis: "⏝",
      Union: "⋃",
      UnionPlus: "⊎",
      Uogon: "Ų",
      uogon: "ų",
      Uopf: "𝕌",
      uopf: "𝕦",
      UpArrow: "↑",
      Uparrow: "⇑",
      uparrow: "↑",
      UpArrowBar: "⤒",
      UpArrowDownArrow: "⇅",
      UpDownArrow: "↕",
      Updownarrow: "⇕",
      updownarrow: "↕",
      UpEquilibrium: "⥮",
      upharpoonleft: "↿",
      upharpoonright: "↾",
      uplus: "⊎",
      UpperLeftArrow: "↖",
      UpperRightArrow: "↗",
      Upsi: "ϒ",
      upsi: "υ",
      upsih: "ϒ",
      Upsilon: "Υ",
      upsilon: "υ",
      UpTee: "⊥",
      UpTeeArrow: "↥",
      upuparrows: "⇈",
      urcorn: "⌝",
      urcorner: "⌝",
      urcrop: "⌎",
      Uring: "Ů",
      uring: "ů",
      urtri: "◹",
      Uscr: "𝒰",
      uscr: "𝓊",
      utdot: "⋰",
      Utilde: "Ũ",
      utilde: "ũ",
      utri: "▵",
      utrif: "▴",
      uuarr: "⇈",
      Uuml: "Ü",
      uuml: "ü",
      uwangle: "⦧",
      vangrt: "⦜",
      varepsilon: "ϵ",
      varkappa: "ϰ",
      varnothing: "∅",
      varphi: "ϕ",
      varpi: "ϖ",
      varpropto: "∝",
      vArr: "⇕",
      varr: "↕",
      varrho: "ϱ",
      varsigma: "ς",
      varsubsetneq: "⊊︀",
      varsubsetneqq: "⫋︀",
      varsupsetneq: "⊋︀",
      varsupsetneqq: "⫌︀",
      vartheta: "ϑ",
      vartriangleleft: "⊲",
      vartriangleright: "⊳",
      Vbar: "⫫",
      vBar: "⫨",
      vBarv: "⫩",
      Vcy: "В",
      vcy: "в",
      VDash: "⊫",
      Vdash: "⊩",
      vDash: "⊨",
      vdash: "⊢",
      Vdashl: "⫦",
      Vee: "⋁",
      vee: "∨",
      veebar: "⊻",
      veeeq: "≚",
      vellip: "⋮",
      Verbar: "‖",
      verbar: "|",
      Vert: "‖",
      vert: "|",
      VerticalBar: "∣",
      VerticalLine: "|",
      VerticalSeparator: "❘",
      VerticalTilde: "≀",
      VeryThinSpace: " ",
      Vfr: "𝔙",
      vfr: "𝔳",
      vltri: "⊲",
      vnsub: "⊂⃒",
      vnsup: "⊃⃒",
      Vopf: "𝕍",
      vopf: "𝕧",
      vprop: "∝",
      vrtri: "⊳",
      Vscr: "𝒱",
      vscr: "𝓋",
      vsubnE: "⫋︀",
      vsubne: "⊊︀",
      vsupnE: "⫌︀",
      vsupne: "⊋︀",
      Vvdash: "⊪",
      vzigzag: "⦚",
      Wcirc: "Ŵ",
      wcirc: "ŵ",
      wedbar: "⩟",
      Wedge: "⋀",
      wedge: "∧",
      wedgeq: "≙",
      weierp: "℘",
      Wfr: "𝔚",
      wfr: "𝔴",
      Wopf: "𝕎",
      wopf: "𝕨",
      wp: "℘",
      wr: "≀",
      wreath: "≀",
      Wscr: "𝒲",
      wscr: "𝓌",
      xcap: "⋂",
      xcirc: "◯",
      xcup: "⋃",
      xdtri: "▽",
      Xfr: "𝔛",
      xfr: "𝔵",
      xhArr: "⟺",
      xharr: "⟷",
      Xi: "Ξ",
      xi: "ξ",
      xlArr: "⟸",
      xlarr: "⟵",
      xmap: "⟼",
      xnis: "⋻",
      xodot: "⨀",
      Xopf: "𝕏",
      xopf: "𝕩",
      xoplus: "⨁",
      xotime: "⨂",
      xrArr: "⟹",
      xrarr: "⟶",
      Xscr: "𝒳",
      xscr: "𝓍",
      xsqcup: "⨆",
      xuplus: "⨄",
      xutri: "△",
      xvee: "⋁",
      xwedge: "⋀",
      Yacute: "Ý",
      yacute: "ý",
      YAcy: "Я",
      yacy: "я",
      Ycirc: "Ŷ",
      ycirc: "ŷ",
      Ycy: "Ы",
      ycy: "ы",
      yen: "¥",
      Yfr: "𝔜",
      yfr: "𝔶",
      YIcy: "Ї",
      yicy: "ї",
      Yopf: "𝕐",
      yopf: "𝕪",
      Yscr: "𝒴",
      yscr: "𝓎",
      YUcy: "Ю",
      yucy: "ю",
      Yuml: "Ÿ",
      yuml: "ÿ",
      Zacute: "Ź",
      zacute: "ź",
      Zcaron: "Ž",
      zcaron: "ž",
      Zcy: "З",
      zcy: "з",
      Zdot: "Ż",
      zdot: "ż",
      zeetrf: "ℨ",
      ZeroWidthSpace: "​",
      Zeta: "Ζ",
      zeta: "ζ",
      Zfr: "ℨ",
      zfr: "𝔷",
      ZHcy: "Ж",
      zhcy: "ж",
      zigrarr: "⇝",
      Zopf: "ℤ",
      zopf: "𝕫",
      Zscr: "𝒵",
      zscr: "𝓏",
      zwj: "‍",
      zwnj: "‌"
    });
    exports.entityMap = exports.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse3(
          source,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse3(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k = a2.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            // end elment
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }
    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p);
              }
              start = p + 1;
              p = source.indexOf(c, start);
              if (p > 0) {
                value = source.slice(start, p);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              //case S_EQ:
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              //normal
              case S_ATTR_NOQUOT_VALUE:
              //Compatible state
              case S_ATTR:
                value = source.slice(start, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          /*xml space '\x20' | #x9 | #xD | #xA; */
          case "":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                //case S_TAG:void();break;
                //case S_ATTR:void();break;
                //case S_ATTR_NOQUOT_VALUE:void();break;
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns3 = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns3, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns3, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n in source) {
        if (Object.prototype.hasOwnProperty.call(source, n)) {
          target[n] = source[n];
        }
      }
    }
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }
    exports.XMLReader = XMLReader;
    exports.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser2(options) {
      this.options = options || { locator: {} };
    }
    DOMParser2.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(
          normalize(source),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports.__DOMHandler = DOMHandler;
    exports.normalizeLineEndings = normalizeLineEndings;
    exports.DOMParser = DOMParser2;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports) {
    var dom = require_dom();
    exports.DOMImplementation = dom.DOMImplementation;
    exports.XMLSerializer = dom.XMLSerializer;
    exports.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output2 = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output2.push(tripletToBase64(tmp));
      }
      return output2.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string2, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string2, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string2, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf)) buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string2, encoding) {
      if (Buffer2.isBuffer(string2)) {
        return string2.length;
      }
      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
        return string2.byteLength;
      }
      if (typeof string2 !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
        );
      }
      const len = string2.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string2).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string2).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string2).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string2, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string2.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string2.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string2, offset, length) {
      return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string2, offset, length) {
      return blitBuffer(asciiToBytes(string2), buf, offset, length);
    }
    function base64Write(buf, string2, offset, length) {
      return blitBuffer(base64ToBytes(string2), buf, offset, length);
    }
    function ucs2Write(buf, string2, offset, length) {
      return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string2, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string2, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string2, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string2, offset, length);
          case "base64":
            return base64Write(this, string2, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string2, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string2, units) {
      units = units || Infinity;
      let codePoint;
      const length = string2.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string2.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/readable-stream/lib/ours/primordials.js
var require_primordials = __commonJS({
  "node_modules/readable-stream/lib/ours/primordials.js"(exports, module2) {
    "use strict";
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        let message = "";
        for (let i = 0; i < errors.length; i++) {
          message += `    ${errors[i].stack}
`;
        }
        super(message);
        this.name = "AggregateError";
        this.errors = errors;
      }
    };
    module2.exports = {
      AggregateError,
      ArrayIsArray(self2) {
        return Array.isArray(self2);
      },
      ArrayPrototypeIncludes(self2, el) {
        return self2.includes(el);
      },
      ArrayPrototypeIndexOf(self2, el) {
        return self2.indexOf(el);
      },
      ArrayPrototypeJoin(self2, sep) {
        return self2.join(sep);
      },
      ArrayPrototypeMap(self2, fn) {
        return self2.map(fn);
      },
      ArrayPrototypePop(self2, el) {
        return self2.pop(el);
      },
      ArrayPrototypePush(self2, el) {
        return self2.push(el);
      },
      ArrayPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      Error,
      FunctionPrototypeCall(fn, thisArgs, ...args) {
        return fn.call(thisArgs, ...args);
      },
      FunctionPrototypeSymbolHasInstance(self2, instance) {
        return Function.prototype[Symbol.hasInstance].call(self2, instance);
      },
      MathFloor: Math.floor,
      Number,
      NumberIsInteger: Number.isInteger,
      NumberIsNaN: Number.isNaN,
      NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
      NumberParseInt: Number.parseInt,
      ObjectDefineProperties(self2, props) {
        return Object.defineProperties(self2, props);
      },
      ObjectDefineProperty(self2, name, prop) {
        return Object.defineProperty(self2, name, prop);
      },
      ObjectGetOwnPropertyDescriptor(self2, name) {
        return Object.getOwnPropertyDescriptor(self2, name);
      },
      ObjectKeys(obj) {
        return Object.keys(obj);
      },
      ObjectSetPrototypeOf(target, proto) {
        return Object.setPrototypeOf(target, proto);
      },
      Promise,
      PromisePrototypeCatch(self2, fn) {
        return self2.catch(fn);
      },
      PromisePrototypeThen(self2, thenFn, catchFn) {
        return self2.then(thenFn, catchFn);
      },
      PromiseReject(err) {
        return Promise.reject(err);
      },
      PromiseResolve(val) {
        return Promise.resolve(val);
      },
      ReflectApply: Reflect.apply,
      RegExpPrototypeTest(self2, value) {
        return self2.test(value);
      },
      SafeSet: Set,
      String,
      StringPrototypeSlice(self2, start, end) {
        return self2.slice(start, end);
      },
      StringPrototypeToLowerCase(self2) {
        return self2.toLowerCase();
      },
      StringPrototypeToUpperCase(self2) {
        return self2.toUpperCase();
      },
      StringPrototypeTrim(self2) {
        return self2.trim();
      },
      Symbol,
      SymbolFor: Symbol.for,
      SymbolAsyncIterator: Symbol.asyncIterator,
      SymbolHasInstance: Symbol.hasInstance,
      SymbolIterator: Symbol.iterator,
      SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
      SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
      TypedArrayPrototypeSet(self2, buf, len) {
        return self2.set(buf, len);
      },
      Boolean,
      Uint8Array
    };
  }
});

// node_modules/readable-stream/lib/ours/util/inspect.js
var require_inspect = __commonJS({
  "node_modules/readable-stream/lib/ours/util/inspect.js"(exports, module2) {
    "use strict";
    module2.exports = {
      format(format, ...args) {
        return format.replace(/%([sdifj])/g, function(...[_unused, type]) {
          const replacement = args.shift();
          if (type === "f") {
            return replacement.toFixed(6);
          } else if (type === "j") {
            return JSON.stringify(replacement);
          } else if (type === "s" && typeof replacement === "object") {
            const ctor = replacement.constructor !== Object ? replacement.constructor.name : "";
            return `${ctor} {}`.trim();
          } else {
            return replacement.toString();
          }
        });
      },
      inspect(value) {
        switch (typeof value) {
          case "string":
            if (value.includes("'")) {
              if (!value.includes('"')) {
                return `"${value}"`;
              } else if (!value.includes("`") && !value.includes("${")) {
                return `\`${value}\``;
              }
            }
            return `'${value}'`;
          case "number":
            if (isNaN(value)) {
              return "NaN";
            } else if (Object.is(value, -0)) {
              return String(value);
            }
            return value;
          case "bigint":
            return `${String(value)}n`;
          case "boolean":
          case "undefined":
            return String(value);
          case "object":
            return "{}";
        }
      }
    };
  }
});

// node_modules/readable-stream/lib/ours/errors.js
var require_errors = __commonJS({
  "node_modules/readable-stream/lib/ours/errors.js"(exports, module2) {
    "use strict";
    var { format, inspect } = require_inspect();
    var { AggregateError: CustomAggregateError } = require_primordials();
    var AggregateError = globalThis.AggregateError || CustomAggregateError;
    var kIsNodeError = Symbol("kIsNodeError");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var classRegExp = /^([A-Z][a-z0-9]*)+$/;
    var nodeInternalPrefix = "__node_internal_";
    var codes = {};
    function assert(value, message) {
      if (!value) {
        throw new codes.ERR_INTERNAL_ASSERTION(message);
      }
    }
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function getMessage(key, msg, args) {
      if (typeof msg === "function") {
        assert(
          msg.length <= args.length,
          // Default options do not count.
          `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${msg.length}).`
        );
        return msg(...args);
      }
      const expectedLength = (msg.match(/%[dfijoOs]/g) || []).length;
      assert(
        expectedLength === args.length,
        `Code: ${key}; The provided arguments length (${args.length}) does not match the required ones (${expectedLength}).`
      );
      if (args.length === 0) {
        return msg;
      }
      return format(msg, ...args);
    }
    function E(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      class NodeError extends Base {
        constructor(...args) {
          super(getMessage(code, message, args));
        }
        toString() {
          return `${this.name} [${code}]: ${this.message}`;
        }
      }
      Object.defineProperties(NodeError.prototype, {
        name: {
          value: Base.name,
          writable: true,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return `${this.name} [${code}]: ${this.message}`;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      NodeError.prototype.code = code;
      NodeError.prototype[kIsNodeError] = true;
      codes[code] = NodeError;
    }
    function hideStackFrames(fn) {
      const hidden = nodeInternalPrefix + fn.name;
      Object.defineProperty(fn, "name", {
        value: hidden
      });
      return fn;
    }
    function aggregateTwoErrors(innerError, outerError) {
      if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
          outerError.errors.push(innerError);
          return outerError;
        }
        const err = new AggregateError([outerError, innerError], outerError.message);
        err.code = outerError.code;
        return err;
      }
      return innerError || outerError;
    }
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted", options = void 0) {
        if (options !== void 0 && typeof options !== "object") {
          throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
      }
    };
    E("ERR_ASSERTION", "%s", Error);
    E(
      "ERR_INVALID_ARG_TYPE",
      (name, expected, actual) => {
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          msg += `"${name}" ${name.includes(".") ? "property" : "argument"} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(typeof value === "string", "All expected entries have to be of type string");
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(value !== "object", 'The value "object" should be written as "Object"');
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(types, pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          switch (types.length) {
            case 1:
              msg += `of type ${types[0]}`;
              break;
            case 2:
              msg += `one of type ${types[0]} or ${types[1]}`;
              break;
            default: {
              const last = types.pop();
              msg += `one of type ${types.join(", ")}, or ${last}`;
            }
          }
          if (instances.length > 0 || other.length > 0) {
            msg += " or ";
          }
        }
        if (instances.length > 0) {
          switch (instances.length) {
            case 1:
              msg += `an instance of ${instances[0]}`;
              break;
            case 2:
              msg += `an instance of ${instances[0]} or ${instances[1]}`;
              break;
            default: {
              const last = instances.pop();
              msg += `an instance of ${instances.join(", ")}, or ${last}`;
            }
          }
          if (other.length > 0) {
            msg += " or ";
          }
        }
        switch (other.length) {
          case 0:
            break;
          case 1:
            if (other[0].toLowerCase() !== other[0]) {
              msg += "an ";
            }
            msg += `${other[0]}`;
            break;
          case 2:
            msg += `one of ${other[0]} or ${other[1]}`;
            break;
          default: {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          var _actual$constructor;
          if ((_actual$constructor = actual.constructor) !== null && _actual$constructor !== void 0 && _actual$constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = inspect(actual, {
              depth: -1
            });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = inspect(actual, {
            colors: false
          });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        return msg;
      },
      TypeError
    );
    E(
      "ERR_INVALID_ARG_VALUE",
      (name, value, reason = "is invalid") => {
        let inspected = inspect(value);
        if (inspected.length > 128) {
          inspected = inspected.slice(0, 128) + "...";
        }
        const type = name.includes(".") ? "property" : "argument";
        return `The ${type} '${name}' ${reason}. Received ${inspected}`;
      },
      TypeError
    );
    E(
      "ERR_INVALID_RETURN_VALUE",
      (input, name, value) => {
        var _value$constructor;
        const type = value !== null && value !== void 0 && (_value$constructor = value.constructor) !== null && _value$constructor !== void 0 && _value$constructor.name ? `instance of ${value.constructor.name}` : `type ${typeof value}`;
        return `Expected ${input} to be returned from the "${name}" function but got ${type}.`;
      },
      TypeError
    );
    E(
      "ERR_MISSING_ARGS",
      (...args) => {
        assert(args.length > 0, "At least one arg needs to be specified");
        let msg;
        const len = args.length;
        args = (Array.isArray(args) ? args : [args]).map((a) => `"${a}"`).join(" or ");
        switch (len) {
          case 1:
            msg += `The ${args[0]} argument`;
            break;
          case 2:
            msg += `The ${args[0]} and ${args[1]} arguments`;
            break;
          default:
            {
              const last = args.pop();
              msg += `The ${args.join(", ")}, and ${last} arguments`;
            }
            break;
        }
        return `${msg} must be specified`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      (str, range, input) => {
        assert(range, 'Missing "range" argument');
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          const limit = BigInt(2) ** BigInt(32);
          if (input > limit || input < -limit) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        } else {
          received = inspect(input);
        }
        return `The value of "${str}" is out of range. It must be ${range}. Received ${received}`;
      },
      RangeError
    );
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    E("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    E("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    E("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    E("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    E("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    E("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    E("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    E("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    E("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    module2.exports = {
      AbortError,
      aggregateTwoErrors: hideStackFrames(aggregateTwoErrors),
      hideStackFrames,
      codes
    };
  }
});

// node_modules/abort-controller/browser.js
var require_browser = __commonJS({
  "node_modules/abort-controller/browser.js"(exports, module2) {
    "use strict";
    var { AbortController: AbortController2, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : (
      /* otherwise */
      void 0
    );
    module2.exports = AbortController2;
    module2.exports.AbortSignal = AbortSignal;
    module2.exports.default = AbortController2;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module2) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module2.exports = EventEmitter;
    module2.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/readable-stream/lib/ours/util.js
var require_util = __commonJS({
  "node_modules/readable-stream/lib/ours/util.js"(exports, module2) {
    "use strict";
    var bufferModule = require_buffer();
    var { format, inspect } = require_inspect();
    var {
      codes: { ERR_INVALID_ARG_TYPE }
    } = require_errors();
    var { kResistStopPropagation, AggregateError, SymbolDispose } = require_primordials();
    var AbortSignal = globalThis.AbortSignal || require_browser().AbortSignal;
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var validateAbortSignal = (signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    var validateFunction = (value, name) => {
      if (typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
      }
    };
    module2.exports = {
      AggregateError,
      kEmptyObject: Object.freeze({}),
      once(callback) {
        let called = false;
        return function(...args) {
          if (called) {
            return;
          }
          called = true;
          callback.apply(this, args);
        };
      },
      createDeferredPromise: function() {
        let resolve;
        let reject;
        const promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        return {
          promise,
          resolve,
          reject
        };
      },
      promisify(fn) {
        return new Promise((resolve, reject) => {
          fn((err, ...args) => {
            if (err) {
              return reject(err);
            }
            return resolve(...args);
          });
        });
      },
      debuglog() {
        return function() {
        };
      },
      format,
      inspect,
      types: {
        isAsyncFunction(fn) {
          return fn instanceof AsyncFunction;
        },
        isArrayBufferView(arr) {
          return ArrayBuffer.isView(arr);
        }
      },
      isBlob,
      deprecate(fn, message) {
        return fn;
      },
      addAbortListener: require_events().addAbortListener || function addAbortListener(signal, listener) {
        if (signal === void 0) {
          throw new ERR_INVALID_ARG_TYPE("signal", "AbortSignal", signal);
        }
        validateAbortSignal(signal, "signal");
        validateFunction(listener, "listener");
        let removeEventListener;
        if (signal.aborted) {
          queueMicrotask(() => listener());
        } else {
          signal.addEventListener("abort", listener, {
            __proto__: null,
            once: true,
            [kResistStopPropagation]: true
          });
          removeEventListener = () => {
            signal.removeEventListener("abort", listener);
          };
        }
        return {
          __proto__: null,
          [SymbolDispose]() {
            var _removeEventListener;
            (_removeEventListener = removeEventListener) === null || _removeEventListener === void 0 ? void 0 : _removeEventListener();
          }
        };
      },
      AbortSignalAny: AbortSignal.any || function AbortSignalAny(signals) {
        if (signals.length === 1) {
          return signals[0];
        }
        const ac = new AbortController2();
        const abort = () => ac.abort();
        signals.forEach((signal) => {
          validateAbortSignal(signal, "signals");
          signal.addEventListener("abort", abort, {
            once: true
          });
        });
        ac.signal.addEventListener(
          "abort",
          () => {
            signals.forEach((signal) => signal.removeEventListener("abort", abort));
          },
          {
            once: true
          }
        );
        return ac.signal;
      }
    };
    module2.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
  }
});

// node_modules/readable-stream/lib/internal/validators.js
var require_validators = __commonJS({
  "node_modules/readable-stream/lib/internal/validators.js"(exports, module2) {
    "use strict";
    var {
      ArrayIsArray,
      ArrayPrototypeIncludes,
      ArrayPrototypeJoin,
      ArrayPrototypeMap,
      NumberIsInteger,
      NumberIsNaN,
      NumberMAX_SAFE_INTEGER,
      NumberMIN_SAFE_INTEGER,
      NumberParseInt,
      ObjectPrototypeHasOwnProperty,
      RegExpPrototypeExec,
      String: String2,
      StringPrototypeToUpperCase,
      StringPrototypeTrim
    } = require_primordials();
    var {
      hideStackFrames,
      codes: { ERR_SOCKET_BAD_PORT, ERR_INVALID_ARG_TYPE, ERR_INVALID_ARG_VALUE, ERR_OUT_OF_RANGE, ERR_UNKNOWN_SIGNAL }
    } = require_errors();
    var { normalizeEncoding } = require_util();
    var { isAsyncFunction, isArrayBufferView } = require_util().types;
    var signals = {};
    function isInt32(value) {
      return value === (value | 0);
    }
    function isUint32(value) {
      return value === value >>> 0;
    }
    var octalReg = /^[0-7]+$/;
    var modeDesc = "must be a 32-bit unsigned integer or an octal string";
    function parseFileMode(value, name, def) {
      if (typeof value === "undefined") {
        value = def;
      }
      if (typeof value === "string") {
        if (RegExpPrototypeExec(octalReg, value) === null) {
          throw new ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = NumberParseInt(value, 8);
      }
      validateUint32(value, name);
      return value;
    }
    var validateInteger = hideStackFrames((value, name, min = NumberMIN_SAFE_INTEGER, max = NumberMAX_SAFE_INTEGER) => {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (!NumberIsInteger(value)) throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      if (value < min || value > max) throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    });
    var validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    var validateUint32 = hideStackFrames((value, name, positive = false) => {
      if (typeof value !== "number") {
        throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      }
      if (!NumberIsInteger(value)) {
        throw new ERR_OUT_OF_RANGE(name, "an integer", value);
      }
      const min = positive ? 1 : 0;
      const max = 4294967295;
      if (value < min || value > max) {
        throw new ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
      }
    });
    function validateString(value, name) {
      if (typeof value !== "string") throw new ERR_INVALID_ARG_TYPE(name, "string", value);
    }
    function validateNumber(value, name, min = void 0, max) {
      if (typeof value !== "number") throw new ERR_INVALID_ARG_TYPE(name, "number", value);
      if (min != null && value < min || max != null && value > max || (min != null || max != null) && NumberIsNaN(value)) {
        throw new ERR_OUT_OF_RANGE(
          name,
          `${min != null ? `>= ${min}` : ""}${min != null && max != null ? " && " : ""}${max != null ? `<= ${max}` : ""}`,
          value
        );
      }
    }
    var validateOneOf = hideStackFrames((value, name, oneOf) => {
      if (!ArrayPrototypeIncludes(oneOf, value)) {
        const allowed = ArrayPrototypeJoin(
          ArrayPrototypeMap(oneOf, (v) => typeof v === "string" ? `'${v}'` : String2(v)),
          ", "
        );
        const reason = "must be one of: " + allowed;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateBoolean(value, name) {
      if (typeof value !== "boolean") throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    function getOwnPropertyValueOrDefault(options, key, defaultValue) {
      return options == null || !ObjectPrototypeHasOwnProperty(options, key) ? defaultValue : options[key];
    }
    var validateObject = hideStackFrames((value, name, options = null) => {
      const allowArray = getOwnPropertyValueOrDefault(options, "allowArray", false);
      const allowFunction = getOwnPropertyValueOrDefault(options, "allowFunction", false);
      const nullable = getOwnPropertyValueOrDefault(options, "nullable", false);
      if (!nullable && value === null || !allowArray && ArrayIsArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    });
    var validateDictionary = hideStackFrames((value, name) => {
      if (value != null && typeof value !== "object" && typeof value !== "function") {
        throw new ERR_INVALID_ARG_TYPE(name, "a dictionary", value);
      }
    });
    var validateArray = hideStackFrames((value, name, minLength = 0) => {
      if (!ArrayIsArray(value)) {
        throw new ERR_INVALID_ARG_TYPE(name, "Array", value);
      }
      if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new ERR_INVALID_ARG_VALUE(name, value, reason);
      }
    });
    function validateStringArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateString(value[i], `${name}[${i}]`);
      }
    }
    function validateBooleanArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        validateBoolean(value[i], `${name}[${i}]`);
      }
    }
    function validateAbortSignalArray(value, name) {
      validateArray(value, name);
      for (let i = 0; i < value.length; i++) {
        const signal = value[i];
        const indexedName = `${name}[${i}]`;
        if (signal == null) {
          throw new ERR_INVALID_ARG_TYPE(indexedName, "AbortSignal", signal);
        }
        validateAbortSignal(signal, indexedName);
      }
    }
    function validateSignalName(signal, name = "signal") {
      validateString(signal, name);
      if (signals[signal] === void 0) {
        if (signals[StringPrototypeToUpperCase(signal)] !== void 0) {
          throw new ERR_UNKNOWN_SIGNAL(signal + " (signals must use all capital letters)");
        }
        throw new ERR_UNKNOWN_SIGNAL(signal);
      }
    }
    var validateBuffer = hideStackFrames((buffer, name = "buffer") => {
      if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, ["Buffer", "TypedArray", "DataView"], buffer);
      }
    });
    function validateEncoding(data, encoding) {
      const normalizedEncoding = normalizeEncoding(encoding);
      const length = data.length;
      if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
      }
    }
    function validatePort(port, name = "Port", allowZero = true) {
      if (typeof port !== "number" && typeof port !== "string" || typeof port === "string" && StringPrototypeTrim(port).length === 0 || +port !== +port >>> 0 || port > 65535 || port === 0 && !allowZero) {
        throw new ERR_SOCKET_BAD_PORT(name, port, allowZero);
      }
      return port | 0;
    }
    var validateAbortSignal = hideStackFrames((signal, name) => {
      if (signal !== void 0 && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    });
    var validateFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function") throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validatePlainFunction = hideStackFrames((value, name) => {
      if (typeof value !== "function" || isAsyncFunction(value)) throw new ERR_INVALID_ARG_TYPE(name, "Function", value);
    });
    var validateUndefined = hideStackFrames((value, name) => {
      if (value !== void 0) throw new ERR_INVALID_ARG_TYPE(name, "undefined", value);
    });
    function validateUnion(value, name, union) {
      if (!ArrayPrototypeIncludes(union, value)) {
        throw new ERR_INVALID_ARG_TYPE(name, `('${ArrayPrototypeJoin(union, "|")}')`, value);
      }
    }
    var linkValueRegExp = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function validateLinkHeaderFormat(value, name) {
      if (typeof value === "undefined" || !RegExpPrototypeExec(linkValueRegExp, value)) {
        throw new ERR_INVALID_ARG_VALUE(
          name,
          value,
          'must be an array or string of format "</styles.css>; rel=preload; as=style"'
        );
      }
    }
    function validateLinkHeaderValue(hints) {
      if (typeof hints === "string") {
        validateLinkHeaderFormat(hints, "hints");
        return hints;
      } else if (ArrayIsArray(hints)) {
        const hintsLength = hints.length;
        let result = "";
        if (hintsLength === 0) {
          return result;
        }
        for (let i = 0; i < hintsLength; i++) {
          const link = hints[i];
          validateLinkHeaderFormat(link, "hints");
          result += link;
          if (i !== hintsLength - 1) {
            result += ", ";
          }
        }
        return result;
      }
      throw new ERR_INVALID_ARG_VALUE(
        "hints",
        hints,
        'must be an array or string of format "</styles.css>; rel=preload; as=style"'
      );
    }
    module2.exports = {
      isInt32,
      isUint32,
      parseFileMode,
      validateArray,
      validateStringArray,
      validateBooleanArray,
      validateAbortSignalArray,
      validateBoolean,
      validateBuffer,
      validateDictionary,
      validateEncoding,
      validateFunction,
      validateInt32,
      validateInteger,
      validateNumber,
      validateObject,
      validateOneOf,
      validatePlainFunction,
      validatePort,
      validateSignalName,
      validateString,
      validateUint32,
      validateUndefined,
      validateUnion,
      validateAbortSignal,
      validateLinkHeaderValue
    };
  }
});

// node_modules/process/browser.js
var require_browser2 = __commonJS({
  "node_modules/process/browser.js"(exports, module2) {
    var process = module2.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process.title = "browser";
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = "";
    process.versions = {};
    function noop2() {
    }
    process.on = noop2;
    process.addListener = noop2;
    process.once = noop2;
    process.off = noop2;
    process.removeListener = noop2;
    process.removeAllListeners = noop2;
    process.emit = noop2;
    process.prependListener = noop2;
    process.prependOnceListener = noop2;
    process.listeners = function(name) {
      return [];
    };
    process.binding = function(name) {
      throw new Error("process.binding is not supported");
    };
    process.cwd = function() {
      return "/";
    };
    process.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process.umask = function() {
      return 0;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/utils.js
var require_utils = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/utils.js"(exports, module2) {
    "use strict";
    var { SymbolAsyncIterator, SymbolIterator, SymbolFor } = require_primordials();
    var kIsDestroyed = SymbolFor("nodejs.stream.destroyed");
    var kIsErrored = SymbolFor("nodejs.stream.errored");
    var kIsReadable = SymbolFor("nodejs.stream.readable");
    var kIsWritable = SymbolFor("nodejs.stream.writable");
    var kIsDisturbed = SymbolFor("nodejs.stream.disturbed");
    var kIsClosedPromise = SymbolFor("nodejs.webstream.isClosedPromise");
    var kControllerErrorFunction = SymbolFor("nodejs.webstream.controllerErrorFunction");
    function isReadableNodeStream(obj, strict = false) {
      var _obj$_readableState;
      return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!strict || typeof obj.pause === "function" && typeof obj.resume === "function") && (!obj._writableState || ((_obj$_readableState = obj._readableState) === null || _obj$_readableState === void 0 ? void 0 : _obj$_readableState.readable) !== false) && // Duplex
      (!obj._writableState || obj._readableState));
    }
    function isWritableNodeStream(obj) {
      var _obj$_writableState;
      return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || ((_obj$_writableState = obj._writableState) === null || _obj$_writableState === void 0 ? void 0 : _obj$_writableState.writable) !== false));
    }
    function isDuplexNodeStream(obj) {
      return !!(obj && typeof obj.pipe === "function" && obj._readableState && typeof obj.on === "function" && typeof obj.write === "function");
    }
    function isNodeStream(obj) {
      return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
    }
    function isReadableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.pipeThrough === "function" && typeof obj.getReader === "function" && typeof obj.cancel === "function");
    }
    function isWritableStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.getWriter === "function" && typeof obj.abort === "function");
    }
    function isTransformStream(obj) {
      return !!(obj && !isNodeStream(obj) && typeof obj.readable === "object" && typeof obj.writable === "object");
    }
    function isWebStream(obj) {
      return isReadableStream(obj) || isWritableStream(obj) || isTransformStream(obj);
    }
    function isIterable(obj, isAsync) {
      if (obj == null) return false;
      if (isAsync === true) return typeof obj[SymbolAsyncIterator] === "function";
      if (isAsync === false) return typeof obj[SymbolIterator] === "function";
      return typeof obj[SymbolAsyncIterator] === "function" || typeof obj[SymbolIterator] === "function";
    }
    function isDestroyed(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !!(stream.destroyed || stream[kIsDestroyed] || state !== null && state !== void 0 && state.destroyed);
    }
    function isWritableEnded(stream) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableEnded === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.ended) !== "boolean") return null;
      return wState.ended;
    }
    function isWritableFinished(stream, strict) {
      if (!isWritableNodeStream(stream)) return null;
      if (stream.writableFinished === true) return true;
      const wState = stream._writableState;
      if (wState !== null && wState !== void 0 && wState.errored) return false;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.finished) !== "boolean") return null;
      return !!(wState.finished || strict === false && wState.ended === true && wState.length === 0);
    }
    function isReadableEnded(stream) {
      if (!isReadableNodeStream(stream)) return null;
      if (stream.readableEnded === true) return true;
      const rState = stream._readableState;
      if (!rState || rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.ended) !== "boolean") return null;
      return rState.ended;
    }
    function isReadableFinished(stream, strict) {
      if (!isReadableNodeStream(stream)) return null;
      const rState = stream._readableState;
      if (rState !== null && rState !== void 0 && rState.errored) return false;
      if (typeof (rState === null || rState === void 0 ? void 0 : rState.endEmitted) !== "boolean") return null;
      return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
    }
    function isReadable(stream) {
      if (stream && stream[kIsReadable] != null) return stream[kIsReadable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.readable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isReadableNodeStream(stream) && stream.readable && !isReadableFinished(stream);
    }
    function isWritable(stream) {
      if (stream && stream[kIsWritable] != null) return stream[kIsWritable];
      if (typeof (stream === null || stream === void 0 ? void 0 : stream.writable) !== "boolean") return null;
      if (isDestroyed(stream)) return false;
      return isWritableNodeStream(stream) && stream.writable && !isWritableEnded(stream);
    }
    function isFinished(stream, opts) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (isDestroyed(stream)) {
        return true;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.readable) !== false && isReadable(stream)) {
        return false;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.writable) !== false && isWritable(stream)) {
        return false;
      }
      return true;
    }
    function isWritableErrored(stream) {
      var _stream$_writableStat, _stream$_writableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.writableErrored) {
        return stream.writableErrored;
      }
      return (_stream$_writableStat = (_stream$_writableStat2 = stream._writableState) === null || _stream$_writableStat2 === void 0 ? void 0 : _stream$_writableStat2.errored) !== null && _stream$_writableStat !== void 0 ? _stream$_writableStat : null;
    }
    function isReadableErrored(stream) {
      var _stream$_readableStat, _stream$_readableStat2;
      if (!isNodeStream(stream)) {
        return null;
      }
      if (stream.readableErrored) {
        return stream.readableErrored;
      }
      return (_stream$_readableStat = (_stream$_readableStat2 = stream._readableState) === null || _stream$_readableStat2 === void 0 ? void 0 : _stream$_readableStat2.errored) !== null && _stream$_readableStat !== void 0 ? _stream$_readableStat : null;
    }
    function isClosed(stream) {
      if (!isNodeStream(stream)) {
        return null;
      }
      if (typeof stream.closed === "boolean") {
        return stream.closed;
      }
      const wState = stream._writableState;
      const rState = stream._readableState;
      if (typeof (wState === null || wState === void 0 ? void 0 : wState.closed) === "boolean" || typeof (rState === null || rState === void 0 ? void 0 : rState.closed) === "boolean") {
        return (wState === null || wState === void 0 ? void 0 : wState.closed) || (rState === null || rState === void 0 ? void 0 : rState.closed);
      }
      if (typeof stream._closed === "boolean" && isOutgoingMessage(stream)) {
        return stream._closed;
      }
      return null;
    }
    function isOutgoingMessage(stream) {
      return typeof stream._closed === "boolean" && typeof stream._defaultKeepAlive === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean";
    }
    function isServerResponse(stream) {
      return typeof stream._sent100 === "boolean" && isOutgoingMessage(stream);
    }
    function isServerRequest(stream) {
      var _stream$req;
      return typeof stream._consuming === "boolean" && typeof stream._dumped === "boolean" && ((_stream$req = stream.req) === null || _stream$req === void 0 ? void 0 : _stream$req.upgradeOrConnect) === void 0;
    }
    function willEmitClose(stream) {
      if (!isNodeStream(stream)) return null;
      const wState = stream._writableState;
      const rState = stream._readableState;
      const state = wState || rState;
      return !state && isServerResponse(stream) || !!(state && state.autoDestroy && state.emitClose && state.closed === false);
    }
    function isDisturbed(stream) {
      var _stream$kIsDisturbed;
      return !!(stream && ((_stream$kIsDisturbed = stream[kIsDisturbed]) !== null && _stream$kIsDisturbed !== void 0 ? _stream$kIsDisturbed : stream.readableDidRead || stream.readableAborted));
    }
    function isErrored(stream) {
      var _ref, _ref2, _ref3, _ref4, _ref5, _stream$kIsErrored, _stream$_readableStat3, _stream$_writableStat3, _stream$_readableStat4, _stream$_writableStat4;
      return !!(stream && ((_ref = (_ref2 = (_ref3 = (_ref4 = (_ref5 = (_stream$kIsErrored = stream[kIsErrored]) !== null && _stream$kIsErrored !== void 0 ? _stream$kIsErrored : stream.readableErrored) !== null && _ref5 !== void 0 ? _ref5 : stream.writableErrored) !== null && _ref4 !== void 0 ? _ref4 : (_stream$_readableStat3 = stream._readableState) === null || _stream$_readableStat3 === void 0 ? void 0 : _stream$_readableStat3.errorEmitted) !== null && _ref3 !== void 0 ? _ref3 : (_stream$_writableStat3 = stream._writableState) === null || _stream$_writableStat3 === void 0 ? void 0 : _stream$_writableStat3.errorEmitted) !== null && _ref2 !== void 0 ? _ref2 : (_stream$_readableStat4 = stream._readableState) === null || _stream$_readableStat4 === void 0 ? void 0 : _stream$_readableStat4.errored) !== null && _ref !== void 0 ? _ref : (_stream$_writableStat4 = stream._writableState) === null || _stream$_writableStat4 === void 0 ? void 0 : _stream$_writableStat4.errored));
    }
    module2.exports = {
      isDestroyed,
      kIsDestroyed,
      isDisturbed,
      kIsDisturbed,
      isErrored,
      kIsErrored,
      isReadable,
      kIsReadable,
      kIsClosedPromise,
      kControllerErrorFunction,
      kIsWritable,
      isClosed,
      isDuplexNodeStream,
      isFinished,
      isIterable,
      isReadableNodeStream,
      isReadableStream,
      isReadableEnded,
      isReadableFinished,
      isReadableErrored,
      isNodeStream,
      isWebStream,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableEnded,
      isWritableFinished,
      isWritableErrored,
      isServerRequest,
      isServerResponse,
      willEmitClose,
      isTransformStream
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports, module2) {
    "use strict";
    var process = require_browser2();
    var { AbortError, codes } = require_errors();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes;
    var { kEmptyObject, once } = require_util();
    var { validateAbortSignal, validateFunction, validateObject, validateBoolean } = require_validators();
    var { Promise: Promise2, PromisePrototypeThen, SymbolDispose } = require_primordials();
    var {
      isClosed,
      isReadable,
      isReadableNodeStream,
      isReadableStream,
      isReadableFinished,
      isReadableErrored,
      isWritable,
      isWritableNodeStream,
      isWritableStream,
      isWritableFinished,
      isWritableErrored,
      isNodeStream,
      willEmitClose: _willEmitClose,
      kIsClosedPromise
    } = require_utils();
    var addAbortListener;
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    var nop = () => {
    };
    function eos(stream, options, callback) {
      var _options$readable, _options$writable;
      if (arguments.length === 2) {
        callback = options;
        options = kEmptyObject;
      } else if (options == null) {
        options = kEmptyObject;
      } else {
        validateObject(options, "options");
      }
      validateFunction(callback, "callback");
      validateAbortSignal(options.signal, "options.signal");
      callback = once(callback);
      if (isReadableStream(stream) || isWritableStream(stream)) {
        return eosWeb(stream, options, callback);
      }
      if (!isNodeStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      const readable = (_options$readable = options.readable) !== null && _options$readable !== void 0 ? _options$readable : isReadableNodeStream(stream);
      const writable = (_options$writable = options.writable) !== null && _options$writable !== void 0 ? _options$writable : isWritableNodeStream(stream);
      const wState = stream._writableState;
      const rState = stream._readableState;
      const onlegacyfinish = () => {
        if (!stream.writable) {
          onfinish();
        }
      };
      let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;
      let writableFinished = isWritableFinished(stream, false);
      const onfinish = () => {
        writableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.readable || readable)) {
          return;
        }
        if (!readable || readableFinished) {
          callback.call(stream);
        }
      };
      let readableFinished = isReadableFinished(stream, false);
      const onend = () => {
        readableFinished = true;
        if (stream.destroyed) {
          willEmitClose = false;
        }
        if (willEmitClose && (!stream.writable || writable)) {
          return;
        }
        if (!writable || writableFinished) {
          callback.call(stream);
        }
      };
      const onerror = (err) => {
        callback.call(stream, err);
      };
      let closed = isClosed(stream);
      const onclose = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        if (readable && !readableFinished && isReadableNodeStream(stream, true)) {
          if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        if (writable && !writableFinished) {
          if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
        }
        callback.call(stream);
      };
      const onclosed = () => {
        closed = true;
        const errored = isWritableErrored(stream) || isReadableErrored(stream);
        if (errored && typeof errored !== "boolean") {
          return callback.call(stream, errored);
        }
        callback.call(stream);
      };
      const onrequest = () => {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
          stream.on("abort", onclose);
        }
        if (stream.req) {
          onrequest();
        } else {
          stream.on("request", onrequest);
        }
      } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (options.error !== false) {
        stream.on("error", onerror);
      }
      stream.on("close", onclose);
      if (closed) {
        process.nextTick(onclose);
      } else if (wState !== null && wState !== void 0 && wState.errorEmitted || rState !== null && rState !== void 0 && rState.errorEmitted) {
        if (!willEmitClose) {
          process.nextTick(onclosed);
        }
      } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {
        process.nextTick(onclosed);
      } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {
        process.nextTick(onclosed);
      } else if (rState && stream.req && stream.aborted) {
        process.nextTick(onclosed);
      }
      const cleanup = () => {
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
      if (options.signal && !closed) {
        const abort = () => {
          const endCallback = callback;
          cleanup();
          endCallback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      return cleanup;
    }
    function eosWeb(stream, options, callback) {
      let isAborted = false;
      let abort = nop;
      if (options.signal) {
        abort = () => {
          isAborted = true;
          callback.call(
            stream,
            new AbortError(void 0, {
              cause: options.signal.reason
            })
          );
        };
        if (options.signal.aborted) {
          process.nextTick(abort);
        } else {
          addAbortListener = addAbortListener || require_util().addAbortListener;
          const disposable = addAbortListener(options.signal, abort);
          const originalCallback = callback;
          callback = once((...args) => {
            disposable[SymbolDispose]();
            originalCallback.apply(stream, args);
          });
        }
      }
      const resolverFn = (...args) => {
        if (!isAborted) {
          process.nextTick(() => callback.apply(stream, args));
        }
      };
      PromisePrototypeThen(stream[kIsClosedPromise].promise, resolverFn, resolverFn);
      return nop;
    }
    function finished(stream, opts) {
      var _opts;
      let autoCleanup = false;
      if (opts === null) {
        opts = kEmptyObject;
      }
      if ((_opts = opts) !== null && _opts !== void 0 && _opts.cleanup) {
        validateBoolean(opts.cleanup, "cleanup");
        autoCleanup = opts.cleanup;
      }
      return new Promise2((resolve, reject) => {
        const cleanup = eos(stream, opts, (err) => {
          if (autoCleanup) {
            cleanup();
          }
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      });
    }
    module2.exports = eos;
    module2.exports.finished = finished;
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    var process = require_browser2();
    var {
      aggregateTwoErrors,
      codes: { ERR_MULTIPLE_CALLBACK },
      AbortError
    } = require_errors();
    var { Symbol: Symbol2 } = require_primordials();
    var { kIsDestroyed, isDestroyed, isFinished, isServerRequest } = require_utils();
    var kDestroy = Symbol2("kDestroy");
    var kConstruct = Symbol2("kConstruct");
    function checkError(err, w, r) {
      if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
      }
    }
    function destroy(err, cb) {
      const r = this._readableState;
      const w = this._writableState;
      const s = w || r;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        if (typeof cb === "function") {
          cb();
        }
        return this;
      }
      checkError(err, w, r);
      if (w) {
        w.destroyed = true;
      }
      if (r) {
        r.destroyed = true;
      }
      if (!s.constructed) {
        this.once(kDestroy, function(er) {
          _destroy(this, aggregateTwoErrors(er, err), cb);
        });
      } else {
        _destroy(this, err, cb);
      }
      return this;
    }
    function _destroy(self2, err, cb) {
      let called = false;
      function onDestroy(err2) {
        if (called) {
          return;
        }
        called = true;
        const r = self2._readableState;
        const w = self2._writableState;
        checkError(err2, w, r);
        if (w) {
          w.closed = true;
        }
        if (r) {
          r.closed = true;
        }
        if (typeof cb === "function") {
          cb(err2);
        }
        if (err2) {
          process.nextTick(emitErrorCloseNT, self2, err2);
        } else {
          process.nextTick(emitCloseNT, self2);
        }
      }
      try {
        self2._destroy(err || null, onDestroy);
      } catch (err2) {
        onDestroy(err2);
      }
    }
    function emitErrorCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w) {
        w.closeEmitted = true;
      }
      if (r) {
        r.closeEmitted = true;
      }
      if (w !== null && w !== void 0 && w.emitClose || r !== null && r !== void 0 && r.emitClose) {
        self2.emit("close");
      }
    }
    function emitErrorNT(self2, err) {
      const r = self2._readableState;
      const w = self2._writableState;
      if (w !== null && w !== void 0 && w.errorEmitted || r !== null && r !== void 0 && r.errorEmitted) {
        return;
      }
      if (w) {
        w.errorEmitted = true;
      }
      if (r) {
        r.errorEmitted = true;
      }
      self2.emit("error", err);
    }
    function undestroy() {
      const r = this._readableState;
      const w = this._writableState;
      if (r) {
        r.constructed = true;
        r.closed = false;
        r.closeEmitted = false;
        r.destroyed = false;
        r.errored = null;
        r.errorEmitted = false;
        r.reading = false;
        r.ended = r.readable === false;
        r.endEmitted = r.readable === false;
      }
      if (w) {
        w.constructed = true;
        w.destroyed = false;
        w.closed = false;
        w.closeEmitted = false;
        w.errored = null;
        w.errorEmitted = false;
        w.finalCalled = false;
        w.prefinished = false;
        w.ended = w.writable === false;
        w.ending = w.writable === false;
        w.finished = w.writable === false;
      }
    }
    function errorOrDestroy(stream, err, sync) {
      const r = stream._readableState;
      const w = stream._writableState;
      if (w !== null && w !== void 0 && w.destroyed || r !== null && r !== void 0 && r.destroyed) {
        return this;
      }
      if (r !== null && r !== void 0 && r.autoDestroy || w !== null && w !== void 0 && w.autoDestroy)
        stream.destroy(err);
      else if (err) {
        err.stack;
        if (w && !w.errored) {
          w.errored = err;
        }
        if (r && !r.errored) {
          r.errored = err;
        }
        if (sync) {
          process.nextTick(emitErrorNT, stream, err);
        } else {
          emitErrorNT(stream, err);
        }
      }
    }
    function construct(stream, cb) {
      if (typeof stream._construct !== "function") {
        return;
      }
      const r = stream._readableState;
      const w = stream._writableState;
      if (r) {
        r.constructed = false;
      }
      if (w) {
        w.constructed = false;
      }
      stream.once(kConstruct, cb);
      if (stream.listenerCount(kConstruct) > 1) {
        return;
      }
      process.nextTick(constructNT, stream);
    }
    function constructNT(stream) {
      let called = false;
      function onConstruct(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : new ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        const r = stream._readableState;
        const w = stream._writableState;
        const s = w || r;
        if (r) {
          r.constructed = true;
        }
        if (w) {
          w.constructed = true;
        }
        if (s.destroyed) {
          stream.emit(kDestroy, err);
        } else if (err) {
          errorOrDestroy(stream, err, true);
        } else {
          process.nextTick(emitConstructNT, stream);
        }
      }
      try {
        stream._construct((err) => {
          process.nextTick(onConstruct, err);
        });
      } catch (err) {
        process.nextTick(onConstruct, err);
      }
    }
    function emitConstructNT(stream) {
      stream.emit(kConstruct);
    }
    function isRequest(stream) {
      return (stream === null || stream === void 0 ? void 0 : stream.setHeader) && typeof stream.abort === "function";
    }
    function emitCloseLegacy(stream) {
      stream.emit("close");
    }
    function emitErrorCloseLegacy(stream, err) {
      stream.emit("error", err);
      process.nextTick(emitCloseLegacy, stream);
    }
    function destroyer(stream, err) {
      if (!stream || isDestroyed(stream)) {
        return;
      }
      if (!err && !isFinished(stream)) {
        err = new AbortError();
      }
      if (isServerRequest(stream)) {
        stream.socket = null;
        stream.destroy(err);
      } else if (isRequest(stream)) {
        stream.abort();
      } else if (isRequest(stream.req)) {
        stream.req.abort();
      } else if (typeof stream.destroy === "function") {
        stream.destroy(err);
      } else if (typeof stream.close === "function") {
        stream.close();
      } else if (err) {
        process.nextTick(emitErrorCloseLegacy, stream, err);
      } else {
        process.nextTick(emitCloseLegacy, stream);
      }
      if (!stream.destroyed) {
        stream[kIsDestroyed] = true;
      }
    }
    module2.exports = {
      construct,
      destroyer,
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/legacy.js
var require_legacy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/legacy.js"(exports, module2) {
    "use strict";
    var { ArrayIsArray, ObjectSetPrototypeOf } = require_primordials();
    var { EventEmitter: EE } = require_events();
    function Stream(opts) {
      EE.call(this, opts);
    }
    ObjectSetPrototypeOf(Stream.prototype, EE.prototype);
    ObjectSetPrototypeOf(Stream, EE);
    Stream.prototype.pipe = function(dest, options) {
      const source = this;
      function ondata(chunk) {
        if (dest.writable && dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend);
        source.on("close", onclose);
      }
      let didOnEnd = false;
      function onend() {
        if (didOnEnd) return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd) return;
        didOnEnd = true;
        if (typeof dest.destroy === "function") dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, "error") === 0) {
          this.emit("error", er);
        }
      }
      prependListener(source, "error", onerror);
      prependListener(dest, "error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (ArrayIsArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    module2.exports = {
      Stream,
      prependListener
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/add-abort-signal.js
var require_add_abort_signal = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/add-abort-signal.js"(exports, module2) {
    "use strict";
    var { SymbolDispose } = require_primordials();
    var { AbortError, codes } = require_errors();
    var { isNodeStream, isWebStream, kControllerErrorFunction } = require_utils();
    var eos = require_end_of_stream();
    var { ERR_INVALID_ARG_TYPE } = codes;
    var addAbortListener;
    var validateAbortSignal = (signal, name) => {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        throw new ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
      }
    };
    module2.exports.addAbortSignal = function addAbortSignal(signal, stream) {
      validateAbortSignal(signal, "signal");
      if (!isNodeStream(stream) && !isWebStream(stream)) {
        throw new ERR_INVALID_ARG_TYPE("stream", ["ReadableStream", "WritableStream", "Stream"], stream);
      }
      return module2.exports.addAbortSignalNoValidate(signal, stream);
    };
    module2.exports.addAbortSignalNoValidate = function(signal, stream) {
      if (typeof signal !== "object" || !("aborted" in signal)) {
        return stream;
      }
      const onAbort = isNodeStream(stream) ? () => {
        stream.destroy(
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      } : () => {
        stream[kControllerErrorFunction](
          new AbortError(void 0, {
            cause: signal.reason
          })
        );
      };
      if (signal.aborted) {
        onAbort();
      } else {
        addAbortListener = addAbortListener || require_util().addAbortListener;
        const disposable = addAbortListener(signal, onAbort);
        eos(stream, disposable[SymbolDispose]);
      }
      return stream;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports, module2) {
    "use strict";
    var { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array: Uint8Array2 } = require_primordials();
    var { Buffer: Buffer2 } = require_buffer();
    var { inspect } = require_util();
    module2.exports = class BufferList {
      constructor() {
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      push(v) {
        const entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
      unshift(v) {
        const entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
      shift() {
        if (this.length === 0) return;
        const ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
      clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
      join(s) {
        if (this.length === 0) return "";
        let p = this.head;
        let ret = "" + p.data;
        while ((p = p.next) !== null) ret += s + p.data;
        return ret;
      }
      concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        const ret = Buffer2.allocUnsafe(n >>> 0);
        let p = this.head;
        let i = 0;
        while (p) {
          TypedArrayPrototypeSet(ret, p.data, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
      consume(n, hasStrings) {
        const data = this.head.data;
        if (n < data.length) {
          const slice = data.slice(0, n);
          this.head.data = data.slice(n);
          return slice;
        }
        if (n === data.length) {
          return this.shift();
        }
        return hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      first() {
        return this.head.data;
      }
      *[SymbolIterator]() {
        for (let p = this.head; p; p = p.next) {
          yield p.data;
        }
      }
      // Consumes a specified amount of characters from the buffered data.
      _getString(n) {
        let ret = "";
        let p = this.head;
        let c = 0;
        do {
          const str = p.data;
          if (n > str.length) {
            ret += str;
            n -= str.length;
          } else {
            if (n === str.length) {
              ret += str;
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              ret += StringPrototypeSlice(str, 0, n);
              this.head = p;
              p.data = StringPrototypeSlice(str, n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
      _getBuffer(n) {
        const ret = Buffer2.allocUnsafe(n);
        const retLen = n;
        let p = this.head;
        let c = 0;
        do {
          const buf = p.data;
          if (n > buf.length) {
            TypedArrayPrototypeSet(ret, buf, retLen - n);
            n -= buf.length;
          } else {
            if (n === buf.length) {
              TypedArrayPrototypeSet(ret, buf, retLen - n);
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              TypedArrayPrototypeSet(ret, new Uint8Array2(buf.buffer, buf.byteOffset, n), retLen - n);
              this.head = p;
              p.data = buf.slice(n);
            }
            break;
          }
          ++c;
        } while ((p = p.next) !== null);
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
      [Symbol.for("nodejs.util.inspect.custom")](_, options) {
        return inspect(this, {
          ...options,
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        });
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports, module2) {
    "use strict";
    var { MathFloor, NumberIsInteger } = require_primordials();
    var { validateInteger } = require_validators();
    var { ERR_INVALID_ARG_VALUE } = require_errors().codes;
    var defaultHighWaterMarkBytes = 16 * 1024;
    var defaultHighWaterMarkObjectMode = 16;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getDefaultHighWaterMark(objectMode) {
      return objectMode ? defaultHighWaterMarkObjectMode : defaultHighWaterMarkBytes;
    }
    function setDefaultHighWaterMark(objectMode, value) {
      validateInteger(value, "value", 0);
      if (objectMode) {
        defaultHighWaterMarkObjectMode = value;
      } else {
        defaultHighWaterMarkBytes = value;
      }
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      const hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!NumberIsInteger(hwm) || hwm < 0) {
          const name = isDuplex ? `options.${duplexKey}` : "options.highWaterMark";
          throw new ERR_INVALID_ARG_VALUE(name, hwm);
        }
        return MathFloor(hwm);
      }
      return getDefaultHighWaterMark(state.objectMode);
    }
    module2.exports = {
      getHighWaterMark,
      getDefaultHighWaterMark,
      setDefaultHighWaterMark
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "�";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "�";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "�";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "�";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports, module2) {
    "use strict";
    var process = require_browser2();
    var { PromisePrototypeThen, SymbolAsyncIterator, SymbolIterator } = require_primordials();
    var { Buffer: Buffer2 } = require_buffer();
    var { ERR_INVALID_ARG_TYPE, ERR_STREAM_NULL_VALUES } = require_errors().codes;
    function from(Readable2, iterable, opts) {
      let iterator;
      if (typeof iterable === "string" || iterable instanceof Buffer2) {
        return new Readable2({
          objectMode: true,
          ...opts,
          read() {
            this.push(iterable);
            this.push(null);
          }
        });
      }
      let isAsync;
      if (iterable && iterable[SymbolAsyncIterator]) {
        isAsync = true;
        iterator = iterable[SymbolAsyncIterator]();
      } else if (iterable && iterable[SymbolIterator]) {
        isAsync = false;
        iterator = iterable[SymbolIterator]();
      } else {
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      }
      const readable = new Readable2({
        objectMode: true,
        highWaterMark: 1,
        // TODO(ronag): What options should be allowed?
        ...opts
      });
      let reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      readable._destroy = function(error, cb) {
        PromisePrototypeThen(
          close(error),
          () => process.nextTick(cb, error),
          // nextTick is here in case cb throws
          (e) => process.nextTick(cb, e || error)
        );
      };
      async function close(error) {
        const hadError = error !== void 0 && error !== null;
        const hasThrow = typeof iterator.throw === "function";
        if (hadError && hasThrow) {
          const { value, done } = await iterator.throw(error);
          await value;
          if (done) {
            return;
          }
        }
        if (typeof iterator.return === "function") {
          const { value } = await iterator.return();
          await value;
        }
      }
      async function next() {
        for (; ; ) {
          try {
            const { value, done } = isAsync ? await iterator.next() : iterator.next();
            if (done) {
              readable.push(null);
            } else {
              const res = value && typeof value.then === "function" ? await value : value;
              if (res === null) {
                reading = false;
                throw new ERR_STREAM_NULL_VALUES();
              } else if (readable.push(res)) {
                continue;
              } else {
                reading = false;
              }
            }
          } catch (err) {
            readable.destroy(err);
          }
          break;
        }
      }
      return readable;
    }
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/internal/streams/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/readable.js"(exports, module2) {
    "use strict";
    var process = require_browser2();
    var {
      ArrayPrototypeIndexOf,
      NumberIsInteger,
      NumberIsNaN,
      NumberParseInt,
      ObjectDefineProperties,
      ObjectKeys,
      ObjectSetPrototypeOf,
      Promise: Promise2,
      SafeSet,
      SymbolAsyncDispose,
      SymbolAsyncIterator,
      Symbol: Symbol2
    } = require_primordials();
    module2.exports = Readable2;
    Readable2.ReadableState = ReadableState;
    var { EventEmitter: EE } = require_events();
    var { Stream, prependListener } = require_legacy();
    var { Buffer: Buffer2 } = require_buffer();
    var { addAbortSignal } = require_add_abort_signal();
    var eos = require_end_of_stream();
    var debug = require_util().debuglog("stream", (fn) => {
      debug = fn;
    });
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_METHOD_NOT_IMPLEMENTED,
        ERR_OUT_OF_RANGE,
        ERR_STREAM_PUSH_AFTER_EOF,
        ERR_STREAM_UNSHIFT_AFTER_END_EVENT
      },
      AbortError
    } = require_errors();
    var { validateObject } = require_validators();
    var kPaused = Symbol2("kPaused");
    var { StringDecoder } = require_string_decoder();
    var from = require_from();
    ObjectSetPrototypeOf(Readable2.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Readable2, Stream);
    var nop = () => {
    };
    var { errorOrDestroy } = destroyImpl;
    var kObjectMode = 1 << 0;
    var kEnded = 1 << 1;
    var kEndEmitted = 1 << 2;
    var kReading = 1 << 3;
    var kConstructed = 1 << 4;
    var kSync = 1 << 5;
    var kNeedReadable = 1 << 6;
    var kEmittedReadable = 1 << 7;
    var kReadableListening = 1 << 8;
    var kResumeScheduled = 1 << 9;
    var kErrorEmitted = 1 << 10;
    var kEmitClose = 1 << 11;
    var kAutoDestroy = 1 << 12;
    var kDestroyed = 1 << 13;
    var kClosed = 1 << 14;
    var kCloseEmitted = 1 << 15;
    var kMultiAwaitDrain = 1 << 16;
    var kReadingMore = 1 << 17;
    var kDataEmitted = 1 << 18;
    function makeBitMapDescriptor(bit) {
      return {
        enumerable: false,
        get() {
          return (this.state & bit) !== 0;
        },
        set(value) {
          if (value) this.state |= bit;
          else this.state &= ~bit;
        }
      };
    }
    ObjectDefineProperties(ReadableState.prototype, {
      objectMode: makeBitMapDescriptor(kObjectMode),
      ended: makeBitMapDescriptor(kEnded),
      endEmitted: makeBitMapDescriptor(kEndEmitted),
      reading: makeBitMapDescriptor(kReading),
      // Stream is still being constructed and cannot be
      // destroyed until construction finished or failed.
      // Async construction is opt in, therefore we start as
      // constructed.
      constructed: makeBitMapDescriptor(kConstructed),
      // A flag to be able to tell if the event 'readable'/'data' is emitted
      // immediately, or on a later tick.  We set this to true at first, because
      // any actions that shouldn't happen until "later" should generally also
      // not happen before the first read call.
      sync: makeBitMapDescriptor(kSync),
      // Whenever we return null, then we set a flag to say
      // that we're awaiting a 'readable' event emission.
      needReadable: makeBitMapDescriptor(kNeedReadable),
      emittedReadable: makeBitMapDescriptor(kEmittedReadable),
      readableListening: makeBitMapDescriptor(kReadableListening),
      resumeScheduled: makeBitMapDescriptor(kResumeScheduled),
      // True if the error was already emitted and should not be thrown again.
      errorEmitted: makeBitMapDescriptor(kErrorEmitted),
      emitClose: makeBitMapDescriptor(kEmitClose),
      autoDestroy: makeBitMapDescriptor(kAutoDestroy),
      // Has it been destroyed.
      destroyed: makeBitMapDescriptor(kDestroyed),
      // Indicates whether the stream has finished destroying.
      closed: makeBitMapDescriptor(kClosed),
      // True if close has been emitted or would have been emitted
      // depending on emitClose.
      closeEmitted: makeBitMapDescriptor(kCloseEmitted),
      multiAwaitDrain: makeBitMapDescriptor(kMultiAwaitDrain),
      // If true, a maybeReadMore has been scheduled.
      readingMore: makeBitMapDescriptor(kReadingMore),
      dataEmitted: makeBitMapDescriptor(kDataEmitted)
    });
    function ReadableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.state = kEmitClose | kAutoDestroy | kConstructed | kSync;
      if (options && options.objectMode) this.state |= kObjectMode;
      if (isDuplex && options && options.readableObjectMode) this.state |= kObjectMode;
      this.highWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = [];
      this.flowing = null;
      this[kPaused] = null;
      if (options && options.emitClose === false) this.state &= ~kEmitClose;
      if (options && options.autoDestroy === false) this.state &= ~kAutoDestroy;
      this.errored = null;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.awaitDrainWriters = null;
      this.decoder = null;
      this.encoding = null;
      if (options && options.encoding) {
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      if (!(this instanceof Readable2)) return new Readable2(options);
      const isDuplex = this instanceof require_duplex();
      this._readableState = new ReadableState(options, this, isDuplex);
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal && !isDuplex) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        if (this._readableState.needReadable) {
          maybeReadMore(this, this._readableState);
        }
      });
    }
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    Readable2.prototype[SymbolAsyncDispose] = function() {
      let error;
      if (!this.destroyed) {
        error = this.readableEnded ? null : new AbortError();
        this.destroy(error);
      }
      return new Promise2((resolve, reject) => eos(this, (err) => err && err !== error ? reject(err) : resolve(null)));
    };
    Readable2.prototype.push = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, false);
    };
    Readable2.prototype.unshift = function(chunk, encoding) {
      return readableAddChunk(this, chunk, encoding, true);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront) {
      debug("readableAddChunk", chunk);
      const state = stream._readableState;
      let err;
      if ((state.state & kObjectMode) === 0) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (state.encoding !== encoding) {
            if (addToFront && state.encoding) {
              chunk = Buffer2.from(chunk, encoding).toString(state.encoding);
            } else {
              chunk = Buffer2.from(chunk, encoding);
              encoding = "";
            }
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "";
        } else if (chunk != null) {
          err = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      if (err) {
        errorOrDestroy(stream, err);
      } else if (chunk === null) {
        state.state &= ~kReading;
        onEofChunk(stream, state);
      } else if ((state.state & kObjectMode) !== 0 || chunk && chunk.length > 0) {
        if (addToFront) {
          if ((state.state & kEndEmitted) !== 0) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else if (state.destroyed || state.errored) return false;
          else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed || state.errored) {
          return false;
        } else {
          state.state &= ~kReading;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
            else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.state &= ~kReading;
        maybeReadMore(stream, state);
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync && stream.listenerCount("data") > 0) {
        if ((state.state & kMultiAwaitDrain) !== 0) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
        state.dataEmitted = true;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if ((state.state & kNeedReadable) !== 0) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    Readable2.prototype.isPaused = function() {
      const state = this._readableState;
      return state[kPaused] === true || state.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      const decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      const buffer = this._readableState.buffer;
      let content = "";
      for (const data of buffer) {
        content += decoder.write(data);
      }
      buffer.clear();
      if (content !== "") buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n > MAX_HWM) {
        throw new ERR_OUT_OF_RANGE("size", "<= 1GiB", n);
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if ((state.state & kObjectMode) !== 0) return 1;
      if (NumberIsNaN(n)) {
        if (state.flowing && state.length) return state.buffer.first().length;
        return state.length;
      }
      if (n <= state.length) return n;
      return state.ended ? state.length : 0;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      if (n === void 0) {
        n = NaN;
      } else if (!NumberIsInteger(n)) {
        n = NumberParseInt(n, 10);
      }
      const state = this._readableState;
      const nOrig = n;
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n !== 0) state.state &= ~kEmittedReadable;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      let doRead = (state.state & kNeedReadable) !== 0;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading || state.destroyed || state.errored || !state.constructed) {
        doRead = false;
        debug("reading, ended or constructing", doRead);
      } else if (doRead) {
        debug("do read");
        state.state |= kReading | kSync;
        if (state.length === 0) state.state |= kNeedReadable;
        try {
          this._read(state.highWaterMark);
        } catch (err) {
          errorOrDestroy(this, err);
        }
        state.state &= ~kSync;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      let ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        if (state.multiAwaitDrain) {
          state.awaitDrainWriters.clear();
        } else {
          state.awaitDrainWriters = null;
        }
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null && !state.errorEmitted && !state.closeEmitted) {
        state.dataEmitted = true;
        this.emit("data", ret);
      }
      return ret;
    };
    function onEofChunk(stream, state) {
      debug("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        const chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
    function emitReadable(stream) {
      const state = stream._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      const state = stream._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && !state.errored && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore && state.constructed) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        const len = state.length;
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_read()");
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      const src = this;
      const state = this._readableState;
      if (state.pipes.length === 1) {
        if (!state.multiAwaitDrain) {
          state.multiAwaitDrain = true;
          state.awaitDrainWriters = new SafeSet(state.awaitDrainWriters ? [state.awaitDrainWriters] : []);
        }
      }
      state.pipes.push(dest);
      debug("pipe count=%d opts=%j", state.pipes.length, pipeOpts);
      const doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      const endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      let ondrain;
      let cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        if (ondrain) {
          dest.removeListener("drain", ondrain);
        }
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (ondrain && state.awaitDrainWriters && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      function pause() {
        if (!cleanedUp) {
          if (state.pipes.length === 1 && state.pipes[0] === dest) {
            debug("false write response, pause", 0);
            state.awaitDrainWriters = dest;
            state.multiAwaitDrain = false;
          } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {
            debug("false write response, pause", state.awaitDrainWriters.size);
            state.awaitDrainWriters.add(dest);
          }
          src.pause();
        }
        if (!ondrain) {
          ondrain = pipeOnDrain(src, dest);
          dest.on("drain", ondrain);
        }
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        const ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (dest.listenerCount("error") === 0) {
          const s = dest._writableState || dest._readableState;
          if (s && !s.errorEmitted) {
            errorOrDestroy(dest, er);
          } else {
            dest.emit("error", er);
          }
        }
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (dest.writableNeedDrain === true) {
        pause();
      } else if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src, dest) {
      return function pipeOnDrainFunctionResult() {
        const state = src._readableState;
        if (state.awaitDrainWriters === dest) {
          debug("pipeOnDrain", 1);
          state.awaitDrainWriters = null;
        } else if (state.multiAwaitDrain) {
          debug("pipeOnDrain", state.awaitDrainWriters.size);
          state.awaitDrainWriters.delete(dest);
        }
        if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) && src.listenerCount("data")) {
          src.resume();
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      const state = this._readableState;
      const unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipes.length === 0) return this;
      if (!dest) {
        const dests = state.pipes;
        state.pipes = [];
        this.pause();
        for (let i = 0; i < dests.length; i++)
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        return this;
      }
      const index = ArrayPrototypeIndexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      if (state.pipes.length === 0) this.pause();
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      const res = Stream.prototype.on.call(this, ev, fn);
      const state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      const res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.off = Readable2.prototype.removeListener;
    Readable2.prototype.removeAllListeners = function(ev) {
      const res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      const state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && state[kPaused] === false) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      } else if (!state.readableListening) {
        state.flowing = null;
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      const state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state[kPaused] = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState[kPaused] = true;
      return this;
    };
    function flow(stream) {
      const state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    Readable2.prototype.wrap = function(stream) {
      let paused = false;
      stream.on("data", (chunk) => {
        if (!this.push(chunk) && stream.pause) {
          paused = true;
          stream.pause();
        }
      });
      stream.on("end", () => {
        this.push(null);
      });
      stream.on("error", (err) => {
        errorOrDestroy(this, err);
      });
      stream.on("close", () => {
        this.destroy();
      });
      stream.on("destroy", () => {
        this.destroy();
      });
      this._read = () => {
        if (paused && stream.resume) {
          paused = false;
          stream.resume();
        }
      };
      const streamKeys = ObjectKeys(stream);
      for (let j = 1; j < streamKeys.length; j++) {
        const i = streamKeys[j];
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = stream[i].bind(stream);
        }
      }
      return this;
    };
    Readable2.prototype[SymbolAsyncIterator] = function() {
      return streamToAsyncIterator(this);
    };
    Readable2.prototype.iterator = function(options) {
      if (options !== void 0) {
        validateObject(options, "options");
      }
      return streamToAsyncIterator(this, options);
    };
    function streamToAsyncIterator(stream, options) {
      if (typeof stream.read !== "function") {
        stream = Readable2.wrap(stream, {
          objectMode: true
        });
      }
      const iter = createAsyncIterator(stream, options);
      iter.stream = stream;
      return iter;
    }
    async function* createAsyncIterator(stream, options) {
      let callback = nop;
      function next(resolve) {
        if (this === stream) {
          callback();
          callback = nop;
        } else {
          callback = resolve;
        }
      }
      stream.on("readable", next);
      let error;
      const cleanup = eos(
        stream,
        {
          writable: false
        },
        (err) => {
          error = err ? aggregateTwoErrors(error, err) : null;
          callback();
          callback = nop;
        }
      );
      try {
        while (true) {
          const chunk = stream.destroyed ? null : stream.read();
          if (chunk !== null) {
            yield chunk;
          } else if (error) {
            throw error;
          } else if (error === null) {
            return;
          } else {
            await new Promise2(next);
          }
        }
      } catch (err) {
        error = aggregateTwoErrors(error, err);
        throw error;
      } finally {
        if ((error || (options === null || options === void 0 ? void 0 : options.destroyOnReturn) !== false) && (error === void 0 || stream._readableState.autoDestroy)) {
          destroyImpl.destroyer(stream, null);
        } else {
          stream.off("readable", next);
          cleanup();
        }
      }
    }
    ObjectDefineProperties(Readable2.prototype, {
      readable: {
        __proto__: null,
        get() {
          const r = this._readableState;
          return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted && !r.endEmitted;
        },
        set(val) {
          if (this._readableState) {
            this._readableState.readable = !!val;
          }
        }
      },
      readableDidRead: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.dataEmitted;
        }
      },
      readableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._readableState.readable !== false && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
        }
      },
      readableHighWaterMark: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.highWaterMark;
        }
      },
      readableBuffer: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState && this._readableState.buffer;
        }
      },
      readableFlowing: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return this._readableState.flowing;
        },
        set: function(state) {
          if (this._readableState) {
            this._readableState.flowing = state;
          }
        }
      },
      readableLength: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState.length;
        }
      },
      readableObjectMode: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.objectMode : false;
        }
      },
      readableEncoding: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.encoding : null;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.errored : null;
        }
      },
      closed: {
        __proto__: null,
        get() {
          return this._readableState ? this._readableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.destroyed : false;
        },
        set(value) {
          if (!this._readableState) {
            return;
          }
          this._readableState.destroyed = value;
        }
      },
      readableEnded: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._readableState ? this._readableState.endEmitted : false;
        }
      }
    });
    ObjectDefineProperties(ReadableState.prototype, {
      // Legacy getter for `pipesCount`.
      pipesCount: {
        __proto__: null,
        get() {
          return this.pipes.length;
        }
      },
      // Legacy property for `paused`.
      paused: {
        __proto__: null,
        get() {
          return this[kPaused] !== false;
        },
        set(value) {
          this[kPaused] = !!value;
        }
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      let ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      const state = stream._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.errored && !state.closeEmitted && !state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.emit("end");
        if (stream.writable && stream.allowHalfOpen === false) {
          process.nextTick(endWritableNT, stream);
        } else if (state.autoDestroy) {
          const wState = stream._writableState;
          const autoDestroy = !wState || wState.autoDestroy && // We don't expect the writable to ever 'finish'
          // if writable is explicitly set to false.
          (wState.finished || wState.writable === false);
          if (autoDestroy) {
            stream.destroy();
          }
        }
      }
    }
    function endWritableNT(stream) {
      const writable = stream.writable && !stream.writableEnded && !stream.destroyed;
      if (writable) {
        stream.end();
      }
    }
    Readable2.from = function(iterable, opts) {
      return from(Readable2, iterable, opts);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Readable2.fromWeb = function(readableStream, options) {
      return lazyWebStreams().newStreamReadableFromReadableStream(readableStream, options);
    };
    Readable2.toWeb = function(streamReadable, options) {
      return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable, options);
    };
    Readable2.wrap = function(src, options) {
      var _ref, _src$readableObjectMo;
      return new Readable2({
        objectMode: (_ref = (_src$readableObjectMo = src.readableObjectMode) !== null && _src$readableObjectMo !== void 0 ? _src$readableObjectMo : src.objectMode) !== null && _ref !== void 0 ? _ref : true,
        ...options,
        destroy(err, callback) {
          destroyImpl.destroyer(src, err);
          callback(err);
        }
      }).wrap(src);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/writable.js
var require_writable = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/writable.js"(exports, module2) {
    "use strict";
    var process = require_browser2();
    var {
      ArrayPrototypeSlice,
      Error: Error2,
      FunctionPrototypeSymbolHasInstance,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectSetPrototypeOf,
      StringPrototypeToLowerCase,
      Symbol: Symbol2,
      SymbolHasInstance
    } = require_primordials();
    module2.exports = Writable;
    Writable.WritableState = WritableState;
    var { EventEmitter: EE } = require_events();
    var Stream = require_legacy().Stream;
    var { Buffer: Buffer2 } = require_buffer();
    var destroyImpl = require_destroy();
    var { addAbortSignal } = require_add_abort_signal();
    var { getHighWaterMark, getDefaultHighWaterMark } = require_state();
    var {
      ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED,
      ERR_STREAM_ALREADY_FINISHED,
      ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING
    } = require_errors().codes;
    var { errorOrDestroy } = destroyImpl;
    ObjectSetPrototypeOf(Writable.prototype, Stream.prototype);
    ObjectSetPrototypeOf(Writable, Stream);
    function nop() {
    }
    var kOnFinished = Symbol2("kOnFinished");
    function WritableState(options, stream, isDuplex) {
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof require_duplex();
      this.objectMode = !!(options && options.objectMode);
      if (isDuplex) this.objectMode = this.objectMode || !!(options && options.writableObjectMode);
      this.highWaterMark = options ? getHighWaterMark(this, options, "writableHighWaterMark", isDuplex) : getDefaultHighWaterMark(false);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      const noDecode = !!(options && options.decodeStrings === false);
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options && options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = onwrite.bind(void 0, stream);
      this.writecb = null;
      this.writelen = 0;
      this.afterWriteTickInfo = null;
      resetBuffer(this);
      this.pendingcb = 0;
      this.constructed = true;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = !options || options.emitClose !== false;
      this.autoDestroy = !options || options.autoDestroy !== false;
      this.errored = null;
      this.closed = false;
      this.closeEmitted = false;
      this[kOnFinished] = [];
    }
    function resetBuffer(state) {
      state.buffered = [];
      state.bufferedIndex = 0;
      state.allBuffers = true;
      state.allNoop = true;
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      return ArrayPrototypeSlice(this.buffered, this.bufferedIndex);
    };
    ObjectDefineProperty(WritableState.prototype, "bufferedRequestCount", {
      __proto__: null,
      get() {
        return this.buffered.length - this.bufferedIndex;
      }
    });
    function Writable(options) {
      const isDuplex = this instanceof require_duplex();
      if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
        if (typeof options.construct === "function") this._construct = options.construct;
        if (options.signal) addAbortSignal(options.signal, this);
      }
      Stream.call(this, options);
      destroyImpl.construct(this, () => {
        const state = this._writableState;
        if (!state.writing) {
          clearBuffer(this, state);
        }
        finishMaybe(this, state);
      });
    }
    ObjectDefineProperty(Writable, SymbolHasInstance, {
      __proto__: null,
      value: function(object) {
        if (FunctionPrototypeSymbolHasInstance(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function _write(stream, chunk, encoding, cb) {
      const state = stream._writableState;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = state.defaultEncoding;
      } else {
        if (!encoding) encoding = state.defaultEncoding;
        else if (encoding !== "buffer" && !Buffer2.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
        if (typeof cb !== "function") cb = nop;
      }
      if (chunk === null) {
        throw new ERR_STREAM_NULL_VALUES();
      } else if (!state.objectMode) {
        if (typeof chunk === "string") {
          if (state.decodeStrings !== false) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "buffer";
          }
        } else if (chunk instanceof Buffer2) {
          encoding = "buffer";
        } else if (Stream._isUint8Array(chunk)) {
          chunk = Stream._uint8ArrayToBuffer(chunk);
          encoding = "buffer";
        } else {
          throw new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
        }
      }
      let err;
      if (state.ending) {
        err = new ERR_STREAM_WRITE_AFTER_END();
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("write");
      }
      if (err) {
        process.nextTick(cb, err);
        errorOrDestroy(stream, err, true);
        return err;
      }
      state.pendingcb++;
      return writeOrBuffer(stream, state, chunk, encoding, cb);
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      return _write(this, chunk, encoding, cb) === true;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      const state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = StringPrototypeToLowerCase(encoding);
      if (!Buffer2.isEncoding(encoding)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function writeOrBuffer(stream, state, chunk, encoding, callback) {
      const len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      const ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked || state.errored || !state.constructed) {
        state.buffered.push({
          chunk,
          encoding,
          callback
        });
        if (state.allBuffers && encoding !== "buffer") {
          state.allBuffers = false;
        }
        if (state.allNoop && callback !== nop) {
          state.allNoop = false;
        }
      } else {
        state.writelen = len;
        state.writecb = callback;
        state.writing = true;
        state.sync = true;
        stream._write(chunk, encoding, state.onwrite);
        state.sync = false;
      }
      return ret && !state.errored && !state.destroyed;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, er, cb) {
      --state.pendingcb;
      cb(er);
      errorBuffer(state);
      errorOrDestroy(stream, er);
    }
    function onwrite(stream, er) {
      const state = stream._writableState;
      const sync = state.sync;
      const cb = state.writecb;
      if (typeof cb !== "function") {
        errorOrDestroy(stream, new ERR_MULTIPLE_CALLBACK());
        return;
      }
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
      if (er) {
        er.stack;
        if (!state.errored) {
          state.errored = er;
        }
        if (stream._readableState && !stream._readableState.errored) {
          stream._readableState.errored = er;
        }
        if (sync) {
          process.nextTick(onwriteError, stream, state, er, cb);
        } else {
          onwriteError(stream, state, er, cb);
        }
      } else {
        if (state.buffered.length > state.bufferedIndex) {
          clearBuffer(stream, state);
        }
        if (sync) {
          if (state.afterWriteTickInfo !== null && state.afterWriteTickInfo.cb === cb) {
            state.afterWriteTickInfo.count++;
          } else {
            state.afterWriteTickInfo = {
              count: 1,
              cb,
              stream,
              state
            };
            process.nextTick(afterWriteTick, state.afterWriteTickInfo);
          }
        } else {
          afterWrite(stream, state, 1, cb);
        }
      }
    }
    function afterWriteTick({ stream, state, count, cb }) {
      state.afterWriteTickInfo = null;
      return afterWrite(stream, state, count, cb);
    }
    function afterWrite(stream, state, count, cb) {
      const needDrain = !state.ending && !stream.destroyed && state.length === 0 && state.needDrain;
      if (needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
      while (count-- > 0) {
        state.pendingcb--;
        cb();
      }
      if (state.destroyed) {
        errorBuffer(state);
      }
      finishMaybe(stream, state);
    }
    function errorBuffer(state) {
      if (state.writing) {
        return;
      }
      for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {
        var _state$errored;
        const { chunk, callback } = state.buffered[n];
        const len = state.objectMode ? 1 : chunk.length;
        state.length -= len;
        callback(
          (_state$errored = state.errored) !== null && _state$errored !== void 0 ? _state$errored : new ERR_STREAM_DESTROYED("write")
        );
      }
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        var _state$errored2;
        onfinishCallbacks[i](
          (_state$errored2 = state.errored) !== null && _state$errored2 !== void 0 ? _state$errored2 : new ERR_STREAM_DESTROYED("end")
        );
      }
      resetBuffer(state);
    }
    function clearBuffer(stream, state) {
      if (state.corked || state.bufferProcessing || state.destroyed || !state.constructed) {
        return;
      }
      const { buffered, bufferedIndex, objectMode } = state;
      const bufferedLength = buffered.length - bufferedIndex;
      if (!bufferedLength) {
        return;
      }
      let i = bufferedIndex;
      state.bufferProcessing = true;
      if (bufferedLength > 1 && stream._writev) {
        state.pendingcb -= bufferedLength - 1;
        const callback = state.allNoop ? nop : (err) => {
          for (let n = i; n < buffered.length; ++n) {
            buffered[n].callback(err);
          }
        };
        const chunks = state.allNoop && i === 0 ? buffered : ArrayPrototypeSlice(buffered, i);
        chunks.allBuffers = state.allBuffers;
        doWrite(stream, state, true, state.length, chunks, "", callback);
        resetBuffer(state);
      } else {
        do {
          const { chunk, encoding, callback } = buffered[i];
          buffered[i++] = null;
          const len = objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, callback);
        } while (i < buffered.length && !state.writing);
        if (i === buffered.length) {
          resetBuffer(state);
        } else if (i > 256) {
          buffered.splice(0, i);
          state.bufferedIndex = 0;
        } else {
          state.bufferedIndex = i;
        }
      }
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      if (this._writev) {
        this._writev(
          [
            {
              chunk,
              encoding
            }
          ],
          cb
        );
      } else {
        throw new ERR_METHOD_NOT_IMPLEMENTED("_write()");
      }
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      const state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      let err;
      if (chunk !== null && chunk !== void 0) {
        const ret = _write(this, chunk, encoding);
        if (ret instanceof Error2) {
          err = ret;
        }
      }
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (err) {
      } else if (!state.errored && !state.ending) {
        state.ending = true;
        finishMaybe(this, state, true);
        state.ended = true;
      } else if (state.finished) {
        err = new ERR_STREAM_ALREADY_FINISHED("end");
      } else if (state.destroyed) {
        err = new ERR_STREAM_DESTROYED("end");
      }
      if (typeof cb === "function") {
        if (err || state.finished) {
          process.nextTick(cb, err);
        } else {
          state[kOnFinished].push(cb);
        }
      }
      return this;
    };
    function needFinish(state) {
      return state.ending && !state.destroyed && state.constructed && state.length === 0 && !state.errored && state.buffered.length === 0 && !state.finished && !state.writing && !state.errorEmitted && !state.closeEmitted;
    }
    function callFinal(stream, state) {
      let called = false;
      function onFinish(err) {
        if (called) {
          errorOrDestroy(stream, err !== null && err !== void 0 ? err : ERR_MULTIPLE_CALLBACK());
          return;
        }
        called = true;
        state.pendingcb--;
        if (err) {
          const onfinishCallbacks = state[kOnFinished].splice(0);
          for (let i = 0; i < onfinishCallbacks.length; i++) {
            onfinishCallbacks[i](err);
          }
          errorOrDestroy(stream, err, state.sync);
        } else if (needFinish(state)) {
          state.prefinished = true;
          stream.emit("prefinish");
          state.pendingcb++;
          process.nextTick(finish, stream, state);
        }
      }
      state.sync = true;
      state.pendingcb++;
      try {
        stream._final(onFinish);
      } catch (err) {
        onFinish(err);
      }
      state.sync = false;
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.finalCalled = true;
          callFinal(stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state, sync) {
      if (needFinish(state)) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          if (sync) {
            state.pendingcb++;
            process.nextTick(
              (stream2, state2) => {
                if (needFinish(state2)) {
                  finish(stream2, state2);
                } else {
                  state2.pendingcb--;
                }
              },
              stream,
              state
            );
          } else if (needFinish(state)) {
            state.pendingcb++;
            finish(stream, state);
          }
        }
      }
    }
    function finish(stream, state) {
      state.pendingcb--;
      state.finished = true;
      const onfinishCallbacks = state[kOnFinished].splice(0);
      for (let i = 0; i < onfinishCallbacks.length; i++) {
        onfinishCallbacks[i]();
      }
      stream.emit("finish");
      if (state.autoDestroy) {
        const rState = stream._readableState;
        const autoDestroy = !rState || rState.autoDestroy && // We don't expect the readable to ever 'end'
        // if readable is explicitly set to false.
        (rState.endEmitted || rState.readable === false);
        if (autoDestroy) {
          stream.destroy();
        }
      }
    }
    ObjectDefineProperties(Writable.prototype, {
      closed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.closed : false;
        }
      },
      destroyed: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.destroyed : false;
        },
        set(value) {
          if (this._writableState) {
            this._writableState.destroyed = value;
          }
        }
      },
      writable: {
        __proto__: null,
        get() {
          const w = this._writableState;
          return !!w && w.writable !== false && !w.destroyed && !w.errored && !w.ending && !w.ended;
        },
        set(val) {
          if (this._writableState) {
            this._writableState.writable = !!val;
          }
        }
      },
      writableFinished: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.finished : false;
        }
      },
      writableObjectMode: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.objectMode : false;
        }
      },
      writableBuffer: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.getBuffer();
        }
      },
      writableEnded: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.ending : false;
        }
      },
      writableNeedDrain: {
        __proto__: null,
        get() {
          const wState = this._writableState;
          if (!wState) return false;
          return !wState.destroyed && !wState.ending && wState.needDrain;
        }
      },
      writableHighWaterMark: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.highWaterMark;
        }
      },
      writableCorked: {
        __proto__: null,
        get() {
          return this._writableState ? this._writableState.corked : 0;
        }
      },
      writableLength: {
        __proto__: null,
        get() {
          return this._writableState && this._writableState.length;
        }
      },
      errored: {
        __proto__: null,
        enumerable: false,
        get() {
          return this._writableState ? this._writableState.errored : null;
        }
      },
      writableAborted: {
        __proto__: null,
        enumerable: false,
        get: function() {
          return !!(this._writableState.writable !== false && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
        }
      }
    });
    var destroy = destroyImpl.destroy;
    Writable.prototype.destroy = function(err, cb) {
      const state = this._writableState;
      if (!state.destroyed && (state.bufferedIndex < state.buffered.length || state[kOnFinished].length)) {
        process.nextTick(errorBuffer, state);
      }
      destroy.call(this, err, cb);
      return this;
    };
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Writable.prototype[EE.captureRejectionSymbol] = function(err) {
      this.destroy(err);
    };
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Writable.fromWeb = function(writableStream, options) {
      return lazyWebStreams().newStreamWritableFromWritableStream(writableStream, options);
    };
    Writable.toWeb = function(streamWritable) {
      return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/duplexify.js
var require_duplexify = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplexify.js"(exports, module2) {
    var process = require_browser2();
    var bufferModule = require_buffer();
    var {
      isReadable,
      isWritable,
      isIterable,
      isNodeStream,
      isReadableNodeStream,
      isWritableNodeStream,
      isDuplexNodeStream,
      isReadableStream,
      isWritableStream
    } = require_utils();
    var eos = require_end_of_stream();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_TYPE, ERR_INVALID_RETURN_VALUE }
    } = require_errors();
    var { destroyer } = require_destroy();
    var Duplex = require_duplex();
    var Readable2 = require_readable();
    var Writable = require_writable();
    var { createDeferredPromise } = require_util();
    var from = require_from();
    var Blob2 = globalThis.Blob || bufferModule.Blob;
    var isBlob = typeof Blob2 !== "undefined" ? function isBlob2(b) {
      return b instanceof Blob2;
    } : function isBlob2(b) {
      return false;
    };
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var { FunctionPrototypeCall } = require_primordials();
    var Duplexify = class extends Duplex {
      constructor(options) {
        super(options);
        if ((options === null || options === void 0 ? void 0 : options.readable) === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if ((options === null || options === void 0 ? void 0 : options.writable) === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      }
    };
    module2.exports = function duplexify(body, name) {
      if (isDuplexNodeStream(body)) {
        return body;
      }
      if (isReadableNodeStream(body)) {
        return _duplexify({
          readable: body
        });
      }
      if (isWritableNodeStream(body)) {
        return _duplexify({
          writable: body
        });
      }
      if (isNodeStream(body)) {
        return _duplexify({
          writable: false,
          readable: false
        });
      }
      if (isReadableStream(body)) {
        return _duplexify({
          readable: Readable2.fromWeb(body)
        });
      }
      if (isWritableStream(body)) {
        return _duplexify({
          writable: Writable.fromWeb(body)
        });
      }
      if (typeof body === "function") {
        const { value, write, final, destroy } = fromAsyncGen(body);
        if (isIterable(value)) {
          return from(Duplexify, value, {
            // TODO (ronag): highWaterMark?
            objectMode: true,
            write,
            final,
            destroy
          });
        }
        const then2 = value === null || value === void 0 ? void 0 : value.then;
        if (typeof then2 === "function") {
          let d;
          const promise = FunctionPrototypeCall(
            then2,
            value,
            (val) => {
              if (val != null) {
                throw new ERR_INVALID_RETURN_VALUE("nully", "body", val);
              }
            },
            (err) => {
              destroyer(d, err);
            }
          );
          return d = new Duplexify({
            // TODO (ronag): highWaterMark?
            objectMode: true,
            readable: false,
            write,
            final(cb) {
              final(async () => {
                try {
                  await promise;
                  process.nextTick(cb, null);
                } catch (err) {
                  process.nextTick(cb, err);
                }
              });
            },
            destroy
          });
        }
        throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or AsyncFunction", name, value);
      }
      if (isBlob(body)) {
        return duplexify(body.arrayBuffer());
      }
      if (isIterable(body)) {
        return from(Duplexify, body, {
          // TODO (ronag): highWaterMark?
          objectMode: true,
          writable: false
        });
      }
      if (isReadableStream(body === null || body === void 0 ? void 0 : body.readable) && isWritableStream(body === null || body === void 0 ? void 0 : body.writable)) {
        return Duplexify.fromWeb(body);
      }
      if (typeof (body === null || body === void 0 ? void 0 : body.writable) === "object" || typeof (body === null || body === void 0 ? void 0 : body.readable) === "object") {
        const readable = body !== null && body !== void 0 && body.readable ? isReadableNodeStream(body === null || body === void 0 ? void 0 : body.readable) ? body === null || body === void 0 ? void 0 : body.readable : duplexify(body.readable) : void 0;
        const writable = body !== null && body !== void 0 && body.writable ? isWritableNodeStream(body === null || body === void 0 ? void 0 : body.writable) ? body === null || body === void 0 ? void 0 : body.writable : duplexify(body.writable) : void 0;
        return _duplexify({
          readable,
          writable
        });
      }
      const then = body === null || body === void 0 ? void 0 : body.then;
      if (typeof then === "function") {
        let d;
        FunctionPrototypeCall(
          then,
          body,
          (val) => {
            if (val != null) {
              d.push(val);
            }
            d.push(null);
          },
          (err) => {
            destroyer(d, err);
          }
        );
        return d = new Duplexify({
          objectMode: true,
          writable: false,
          read() {
          }
        });
      }
      throw new ERR_INVALID_ARG_TYPE(
        name,
        [
          "Blob",
          "ReadableStream",
          "WritableStream",
          "Stream",
          "Iterable",
          "AsyncIterable",
          "Function",
          "{ readable, writable } pair",
          "Promise"
        ],
        body
      );
    };
    function fromAsyncGen(fn) {
      let { promise, resolve } = createDeferredPromise();
      const ac = new AbortController2();
      const signal = ac.signal;
      const value = fn(
        async function* () {
          while (true) {
            const _promise = promise;
            promise = null;
            const { chunk, done, cb } = await _promise;
            process.nextTick(cb);
            if (done) return;
            if (signal.aborted)
              throw new AbortError(void 0, {
                cause: signal.reason
              });
            ({ promise, resolve } = createDeferredPromise());
            yield chunk;
          }
        }(),
        {
          signal
        }
      );
      return {
        value,
        write(chunk, encoding, cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            chunk,
            done: false,
            cb
          });
        },
        final(cb) {
          const _resolve = resolve;
          resolve = null;
          _resolve({
            done: true,
            cb
          });
        },
        destroy(err, cb) {
          ac.abort();
          cb(err);
        }
      };
    }
    function _duplexify(pair) {
      const r = pair.readable && typeof pair.readable.read !== "function" ? Readable2.wrap(pair.readable) : pair.readable;
      const w = pair.writable;
      let readable = !!isReadable(r);
      let writable = !!isWritable(w);
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        }
      }
      d = new Duplexify({
        // TODO (ronag): highWaterMark?
        readableObjectMode: !!(r !== null && r !== void 0 && r.readableObjectMode),
        writableObjectMode: !!(w !== null && w !== void 0 && w.writableObjectMode),
        readable,
        writable
      });
      if (writable) {
        eos(w, (err) => {
          writable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        d._write = function(chunk, encoding, callback) {
          if (w.write(chunk, encoding)) {
            callback();
          } else {
            ondrain = callback;
          }
        };
        d._final = function(callback) {
          w.end();
          onfinish = callback;
        };
        w.on("drain", function() {
          if (ondrain) {
            const cb = ondrain;
            ondrain = null;
            cb();
          }
        });
        w.on("finish", function() {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        eos(r, (err) => {
          readable = false;
          if (err) {
            destroyer(r, err);
          }
          onfinished(err);
        });
        r.on("readable", function() {
          if (onreadable) {
            const cb = onreadable;
            onreadable = null;
            cb();
          }
        });
        r.on("end", function() {
          d.push(null);
        });
        d._read = function() {
          while (true) {
            const buf = r.read();
            if (buf === null) {
              onreadable = d._read;
              return;
            }
            if (!d.push(buf)) {
              return;
            }
          }
        };
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          destroyer(w, err);
          destroyer(r, err);
        }
      };
      return d;
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/duplex.js
var require_duplex = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/duplex.js"(exports, module2) {
    "use strict";
    var {
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectKeys,
      ObjectSetPrototypeOf
    } = require_primordials();
    module2.exports = Duplex;
    var Readable2 = require_readable();
    var Writable = require_writable();
    ObjectSetPrototypeOf(Duplex.prototype, Readable2.prototype);
    ObjectSetPrototypeOf(Duplex, Readable2);
    {
      const keys = ObjectKeys(Writable.prototype);
      for (let i = 0; i < keys.length; i++) {
        const method = keys[i];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options) {
        this.allowHalfOpen = options.allowHalfOpen !== false;
        if (options.readable === false) {
          this._readableState.readable = false;
          this._readableState.ended = true;
          this._readableState.endEmitted = true;
        }
        if (options.writable === false) {
          this._writableState.writable = false;
          this._writableState.ending = true;
          this._writableState.ended = true;
          this._writableState.finished = true;
        }
      } else {
        this.allowHalfOpen = true;
      }
    }
    ObjectDefineProperties(Duplex.prototype, {
      writable: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writable")
      },
      writableHighWaterMark: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableHighWaterMark")
      },
      writableObjectMode: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableObjectMode")
      },
      writableBuffer: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableBuffer")
      },
      writableLength: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableLength")
      },
      writableFinished: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableFinished")
      },
      writableCorked: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableCorked")
      },
      writableEnded: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableEnded")
      },
      writableNeedDrain: {
        __proto__: null,
        ...ObjectGetOwnPropertyDescriptor(Writable.prototype, "writableNeedDrain")
      },
      destroyed: {
        __proto__: null,
        get() {
          if (this._readableState === void 0 || this._writableState === void 0) {
            return false;
          }
          return this._readableState.destroyed && this._writableState.destroyed;
        },
        set(value) {
          if (this._readableState && this._writableState) {
            this._readableState.destroyed = value;
            this._writableState.destroyed = value;
          }
        }
      }
    });
    var webStreamsAdapters;
    function lazyWebStreams() {
      if (webStreamsAdapters === void 0) webStreamsAdapters = {};
      return webStreamsAdapters;
    }
    Duplex.fromWeb = function(pair, options) {
      return lazyWebStreams().newStreamDuplexFromReadableWritablePair(pair, options);
    };
    Duplex.toWeb = function(duplex) {
      return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);
    };
    var duplexify;
    Duplex.from = function(body) {
      if (!duplexify) {
        duplexify = require_duplexify();
      }
      return duplexify(body, "body");
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/transform.js
var require_transform = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/transform.js"(exports, module2) {
    "use strict";
    var { ObjectSetPrototypeOf, Symbol: Symbol2 } = require_primordials();
    module2.exports = Transform3;
    var { ERR_METHOD_NOT_IMPLEMENTED } = require_errors().codes;
    var Duplex = require_duplex();
    var { getHighWaterMark } = require_state();
    ObjectSetPrototypeOf(Transform3.prototype, Duplex.prototype);
    ObjectSetPrototypeOf(Transform3, Duplex);
    var kCallback = Symbol2("kCallback");
    function Transform3(options) {
      if (!(this instanceof Transform3)) return new Transform3(options);
      const readableHighWaterMark = options ? getHighWaterMark(this, options, "readableHighWaterMark", true) : null;
      if (readableHighWaterMark === 0) {
        options = {
          ...options,
          highWaterMark: null,
          readableHighWaterMark,
          // TODO (ronag): 0 is not optimal since we have
          // a "bug" where we check needDrain before calling _write and not after.
          // Refs: https://github.com/nodejs/node/pull/32887
          // Refs: https://github.com/nodejs/node/pull/35941
          writableHighWaterMark: options.writableHighWaterMark || 0
        };
      }
      Duplex.call(this, options);
      this._readableState.sync = false;
      this[kCallback] = null;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function final(cb) {
      if (typeof this._flush === "function" && !this.destroyed) {
        this._flush((er, data) => {
          if (er) {
            if (cb) {
              cb(er);
            } else {
              this.destroy(er);
            }
            return;
          }
          if (data != null) {
            this.push(data);
          }
          this.push(null);
          if (cb) {
            cb();
          }
        });
      } else {
        this.push(null);
        if (cb) {
          cb();
        }
      }
    }
    function prefinish() {
      if (this._final !== final) {
        final.call(this);
      }
    }
    Transform3.prototype._final = final;
    Transform3.prototype._transform = function(chunk, encoding, callback) {
      throw new ERR_METHOD_NOT_IMPLEMENTED("_transform()");
    };
    Transform3.prototype._write = function(chunk, encoding, callback) {
      const rState = this._readableState;
      const wState = this._writableState;
      const length = rState.length;
      this._transform(chunk, encoding, (err, val) => {
        if (err) {
          callback(err);
          return;
        }
        if (val != null) {
          this.push(val);
        }
        if (wState.ended || // Backwards compat.
        length === rState.length || // Backwards compat.
        rState.length < rState.highWaterMark) {
          callback();
        } else {
          this[kCallback] = callback;
        }
      });
    };
    Transform3.prototype._read = function() {
      if (this[kCallback]) {
        const callback = this[kCallback];
        this[kCallback] = null;
        callback();
      }
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/passthrough.js"(exports, module2) {
    "use strict";
    var { ObjectSetPrototypeOf } = require_primordials();
    module2.exports = PassThrough;
    var Transform3 = require_transform();
    ObjectSetPrototypeOf(PassThrough.prototype, Transform3.prototype);
    ObjectSetPrototypeOf(PassThrough, Transform3);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform3.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports, module2) {
    var process = require_browser2();
    var { ArrayIsArray, Promise: Promise2, SymbolAsyncIterator, SymbolDispose } = require_primordials();
    var eos = require_end_of_stream();
    var { once } = require_util();
    var destroyImpl = require_destroy();
    var Duplex = require_duplex();
    var {
      aggregateTwoErrors,
      codes: {
        ERR_INVALID_ARG_TYPE,
        ERR_INVALID_RETURN_VALUE,
        ERR_MISSING_ARGS,
        ERR_STREAM_DESTROYED,
        ERR_STREAM_PREMATURE_CLOSE
      },
      AbortError
    } = require_errors();
    var { validateFunction, validateAbortSignal } = require_validators();
    var {
      isIterable,
      isReadable,
      isReadableNodeStream,
      isNodeStream,
      isTransformStream,
      isWebStream,
      isReadableStream,
      isReadableFinished
    } = require_utils();
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var PassThrough;
    var Readable2;
    var addAbortListener;
    function destroyer(stream, reading, writing) {
      let finished = false;
      stream.on("close", () => {
        finished = true;
      });
      const cleanup = eos(
        stream,
        {
          readable: reading,
          writable: writing
        },
        (err) => {
          finished = !err;
        }
      );
      return {
        destroy: (err) => {
          if (finished) return;
          finished = true;
          destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED("pipe"));
        },
        cleanup
      };
    }
    function popCallback(streams) {
      validateFunction(streams[streams.length - 1], "streams[stream.length - 1]");
      return streams.pop();
    }
    function makeAsyncIterable(val) {
      if (isIterable(val)) {
        return val;
      } else if (isReadableNodeStream(val)) {
        return fromReadable(val);
      }
      throw new ERR_INVALID_ARG_TYPE("val", ["Readable", "Iterable", "AsyncIterable"], val);
    }
    async function* fromReadable(val) {
      if (!Readable2) {
        Readable2 = require_readable();
      }
      yield* Readable2.prototype[SymbolAsyncIterator].call(val);
    }
    async function pumpToNode(iterable, writable, finish, { end }) {
      let error;
      let onresolve = null;
      const resume = (err) => {
        if (err) {
          error = err;
        }
        if (onresolve) {
          const callback = onresolve;
          onresolve = null;
          callback();
        }
      };
      const wait = () => new Promise2((resolve, reject) => {
        if (error) {
          reject(error);
        } else {
          onresolve = () => {
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          };
        }
      });
      writable.on("drain", resume);
      const cleanup = eos(
        writable,
        {
          readable: false
        },
        resume
      );
      try {
        if (writable.writableNeedDrain) {
          await wait();
        }
        for await (const chunk of iterable) {
          if (!writable.write(chunk)) {
            await wait();
          }
        }
        if (end) {
          writable.end();
          await wait();
        }
        finish();
      } catch (err) {
        finish(error !== err ? aggregateTwoErrors(error, err) : err);
      } finally {
        cleanup();
        writable.off("drain", resume);
      }
    }
    async function pumpToWeb(readable, writable, finish, { end }) {
      if (isTransformStream(writable)) {
        writable = writable.writable;
      }
      const writer = writable.getWriter();
      try {
        for await (const chunk of readable) {
          await writer.ready;
          writer.write(chunk).catch(() => {
          });
        }
        await writer.ready;
        if (end) {
          await writer.close();
        }
        finish();
      } catch (err) {
        try {
          await writer.abort(err);
          finish(err);
        } catch (err2) {
          finish(err2);
        }
      }
    }
    function pipeline(...streams) {
      return pipelineImpl(streams, once(popCallback(streams)));
    }
    function pipelineImpl(streams, callback, opts) {
      if (streams.length === 1 && ArrayIsArray(streams[0])) {
        streams = streams[0];
      }
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      const outerSignal = opts === null || opts === void 0 ? void 0 : opts.signal;
      const lastStreamCleanup = [];
      validateAbortSignal(outerSignal, "options.signal");
      function abort() {
        finishImpl(new AbortError());
      }
      addAbortListener = addAbortListener || require_util().addAbortListener;
      let disposable;
      if (outerSignal) {
        disposable = addAbortListener(outerSignal, abort);
      }
      let error;
      let value;
      const destroys = [];
      let finishCount = 0;
      function finish(err) {
        finishImpl(err, --finishCount === 0);
      }
      function finishImpl(err, final) {
        var _disposable;
        if (err && (!error || error.code === "ERR_STREAM_PREMATURE_CLOSE")) {
          error = err;
        }
        if (!error && !final) {
          return;
        }
        while (destroys.length) {
          destroys.shift()(error);
        }
        ;
        (_disposable = disposable) === null || _disposable === void 0 ? void 0 : _disposable[SymbolDispose]();
        ac.abort();
        if (final) {
          if (!error) {
            lastStreamCleanup.forEach((fn) => fn());
          }
          process.nextTick(callback, error, value);
        }
      }
      let ret;
      for (let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        const reading = i < streams.length - 1;
        const writing = i > 0;
        const end = reading || (opts === null || opts === void 0 ? void 0 : opts.end) !== false;
        const isLastStream = i === streams.length - 1;
        if (isNodeStream(stream)) {
          let onError2 = function(err) {
            if (err && err.name !== "AbortError" && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
              finish(err);
            }
          };
          var onError = onError2;
          if (end) {
            const { destroy, cleanup } = destroyer(stream, reading, writing);
            destroys.push(destroy);
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
          stream.on("error", onError2);
          if (isReadable(stream) && isLastStream) {
            lastStreamCleanup.push(() => {
              stream.removeListener("error", onError2);
            });
          }
        }
        if (i === 0) {
          if (typeof stream === "function") {
            ret = stream({
              signal
            });
            if (!isIterable(ret)) {
              throw new ERR_INVALID_RETURN_VALUE("Iterable, AsyncIterable or Stream", "source", ret);
            }
          } else if (isIterable(stream) || isReadableNodeStream(stream) || isTransformStream(stream)) {
            ret = stream;
          } else {
            ret = Duplex.from(stream);
          }
        } else if (typeof stream === "function") {
          if (isTransformStream(ret)) {
            var _ret;
            ret = makeAsyncIterable((_ret = ret) === null || _ret === void 0 ? void 0 : _ret.readable);
          } else {
            ret = makeAsyncIterable(ret);
          }
          ret = stream(ret, {
            signal
          });
          if (reading) {
            if (!isIterable(ret, true)) {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable", `transform[${i - 1}]`, ret);
            }
          } else {
            var _ret2;
            if (!PassThrough) {
              PassThrough = require_passthrough();
            }
            const pt = new PassThrough({
              objectMode: true
            });
            const then = (_ret2 = ret) === null || _ret2 === void 0 ? void 0 : _ret2.then;
            if (typeof then === "function") {
              finishCount++;
              then.call(
                ret,
                (val) => {
                  value = val;
                  if (val != null) {
                    pt.write(val);
                  }
                  if (end) {
                    pt.end();
                  }
                  process.nextTick(finish);
                },
                (err) => {
                  pt.destroy(err);
                  process.nextTick(finish, err);
                }
              );
            } else if (isIterable(ret, true)) {
              finishCount++;
              pumpToNode(ret, pt, finish, {
                end
              });
            } else if (isReadableStream(ret) || isTransformStream(ret)) {
              const toRead = ret.readable || ret;
              finishCount++;
              pumpToNode(toRead, pt, finish, {
                end
              });
            } else {
              throw new ERR_INVALID_RETURN_VALUE("AsyncIterable or Promise", "destination", ret);
            }
            ret = pt;
            const { destroy, cleanup } = destroyer(ret, false, true);
            destroys.push(destroy);
            if (isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          }
        } else if (isNodeStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount += 2;
            const cleanup = pipe(ret, stream, finish, {
              end
            });
            if (isReadable(stream) && isLastStream) {
              lastStreamCleanup.push(cleanup);
            }
          } else if (isTransformStream(ret) || isReadableStream(ret)) {
            const toRead = ret.readable || ret;
            finishCount++;
            pumpToNode(toRead, stream, finish, {
              end
            });
          } else if (isIterable(ret)) {
            finishCount++;
            pumpToNode(ret, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else if (isWebStream(stream)) {
          if (isReadableNodeStream(ret)) {
            finishCount++;
            pumpToWeb(makeAsyncIterable(ret), stream, finish, {
              end
            });
          } else if (isReadableStream(ret) || isIterable(ret)) {
            finishCount++;
            pumpToWeb(ret, stream, finish, {
              end
            });
          } else if (isTransformStream(ret)) {
            finishCount++;
            pumpToWeb(ret.readable, stream, finish, {
              end
            });
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "val",
              ["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],
              ret
            );
          }
          ret = stream;
        } else {
          ret = Duplex.from(stream);
        }
      }
      if (signal !== null && signal !== void 0 && signal.aborted || outerSignal !== null && outerSignal !== void 0 && outerSignal.aborted) {
        process.nextTick(abort);
      }
      return ret;
    }
    function pipe(src, dst, finish, { end }) {
      let ended = false;
      dst.on("close", () => {
        if (!ended) {
          finish(new ERR_STREAM_PREMATURE_CLOSE());
        }
      });
      src.pipe(dst, {
        end: false
      });
      if (end) {
        let endFn2 = function() {
          ended = true;
          dst.end();
        };
        var endFn = endFn2;
        if (isReadableFinished(src)) {
          process.nextTick(endFn2);
        } else {
          src.once("end", endFn2);
        }
      } else {
        finish();
      }
      eos(
        src,
        {
          readable: true,
          writable: false
        },
        (err) => {
          const rState = src._readableState;
          if (err && err.code === "ERR_STREAM_PREMATURE_CLOSE" && rState && rState.ended && !rState.errored && !rState.errorEmitted) {
            src.once("end", finish).once("error", finish);
          } else {
            finish(err);
          }
        }
      );
      return eos(
        dst,
        {
          readable: false,
          writable: true
        },
        finish
      );
    }
    module2.exports = {
      pipelineImpl,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/compose.js
var require_compose = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/compose.js"(exports, module2) {
    "use strict";
    var { pipeline } = require_pipeline();
    var Duplex = require_duplex();
    var { destroyer } = require_destroy();
    var {
      isNodeStream,
      isReadable,
      isWritable,
      isWebStream,
      isTransformStream,
      isWritableStream,
      isReadableStream
    } = require_utils();
    var {
      AbortError,
      codes: { ERR_INVALID_ARG_VALUE, ERR_MISSING_ARGS }
    } = require_errors();
    var eos = require_end_of_stream();
    module2.exports = function compose(...streams) {
      if (streams.length === 0) {
        throw new ERR_MISSING_ARGS("streams");
      }
      if (streams.length === 1) {
        return Duplex.from(streams[0]);
      }
      const orgStreams = [...streams];
      if (typeof streams[0] === "function") {
        streams[0] = Duplex.from(streams[0]);
      }
      if (typeof streams[streams.length - 1] === "function") {
        const idx = streams.length - 1;
        streams[idx] = Duplex.from(streams[idx]);
      }
      for (let n = 0; n < streams.length; ++n) {
        if (!isNodeStream(streams[n]) && !isWebStream(streams[n])) {
          continue;
        }
        if (n < streams.length - 1 && !(isReadable(streams[n]) || isReadableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be readable");
        }
        if (n > 0 && !(isWritable(streams[n]) || isWritableStream(streams[n]) || isTransformStream(streams[n]))) {
          throw new ERR_INVALID_ARG_VALUE(`streams[${n}]`, orgStreams[n], "must be writable");
        }
      }
      let ondrain;
      let onfinish;
      let onreadable;
      let onclose;
      let d;
      function onfinished(err) {
        const cb = onclose;
        onclose = null;
        if (cb) {
          cb(err);
        } else if (err) {
          d.destroy(err);
        } else if (!readable && !writable) {
          d.destroy();
        }
      }
      const head = streams[0];
      const tail = pipeline(streams, onfinished);
      const writable = !!(isWritable(head) || isWritableStream(head) || isTransformStream(head));
      const readable = !!(isReadable(tail) || isReadableStream(tail) || isTransformStream(tail));
      d = new Duplex({
        // TODO (ronag): highWaterMark?
        writableObjectMode: !!(head !== null && head !== void 0 && head.writableObjectMode),
        readableObjectMode: !!(tail !== null && tail !== void 0 && tail.readableObjectMode),
        writable,
        readable
      });
      if (writable) {
        if (isNodeStream(head)) {
          d._write = function(chunk, encoding, callback) {
            if (head.write(chunk, encoding)) {
              callback();
            } else {
              ondrain = callback;
            }
          };
          d._final = function(callback) {
            head.end();
            onfinish = callback;
          };
          head.on("drain", function() {
            if (ondrain) {
              const cb = ondrain;
              ondrain = null;
              cb();
            }
          });
        } else if (isWebStream(head)) {
          const writable2 = isTransformStream(head) ? head.writable : head;
          const writer = writable2.getWriter();
          d._write = async function(chunk, encoding, callback) {
            try {
              await writer.ready;
              writer.write(chunk).catch(() => {
              });
              callback();
            } catch (err) {
              callback(err);
            }
          };
          d._final = async function(callback) {
            try {
              await writer.ready;
              writer.close().catch(() => {
              });
              onfinish = callback;
            } catch (err) {
              callback(err);
            }
          };
        }
        const toRead = isTransformStream(tail) ? tail.readable : tail;
        eos(toRead, () => {
          if (onfinish) {
            const cb = onfinish;
            onfinish = null;
            cb();
          }
        });
      }
      if (readable) {
        if (isNodeStream(tail)) {
          tail.on("readable", function() {
            if (onreadable) {
              const cb = onreadable;
              onreadable = null;
              cb();
            }
          });
          tail.on("end", function() {
            d.push(null);
          });
          d._read = function() {
            while (true) {
              const buf = tail.read();
              if (buf === null) {
                onreadable = d._read;
                return;
              }
              if (!d.push(buf)) {
                return;
              }
            }
          };
        } else if (isWebStream(tail)) {
          const readable2 = isTransformStream(tail) ? tail.readable : tail;
          const reader = readable2.getReader();
          d._read = async function() {
            while (true) {
              try {
                const { value, done } = await reader.read();
                if (!d.push(value)) {
                  return;
                }
                if (done) {
                  d.push(null);
                  return;
                }
              } catch {
                return;
              }
            }
          };
        }
      }
      d._destroy = function(err, callback) {
        if (!err && onclose !== null) {
          err = new AbortError();
        }
        onreadable = null;
        ondrain = null;
        onfinish = null;
        if (onclose === null) {
          callback(err);
        } else {
          onclose = callback;
          if (isNodeStream(tail)) {
            destroyer(tail, err);
          }
        }
      };
      return d;
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/operators.js
var require_operators = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/operators.js"(exports, module2) {
    "use strict";
    var AbortController2 = globalThis.AbortController || require_browser().AbortController;
    var {
      codes: { ERR_INVALID_ARG_VALUE, ERR_INVALID_ARG_TYPE, ERR_MISSING_ARGS, ERR_OUT_OF_RANGE },
      AbortError
    } = require_errors();
    var { validateAbortSignal, validateInteger, validateObject } = require_validators();
    var kWeakHandler = require_primordials().Symbol("kWeak");
    var kResistStopPropagation = require_primordials().Symbol("kResistStopPropagation");
    var { finished } = require_end_of_stream();
    var staticCompose = require_compose();
    var { addAbortSignalNoValidate } = require_add_abort_signal();
    var { isWritable, isNodeStream } = require_utils();
    var { deprecate } = require_util();
    var {
      ArrayPrototypePush,
      Boolean: Boolean2,
      MathFloor,
      Number: Number2,
      NumberIsNaN,
      Promise: Promise2,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      Symbol: Symbol2
    } = require_primordials();
    var kEmpty = Symbol2("kEmpty");
    var kEof = Symbol2("kEof");
    function compose(stream, options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      if (isNodeStream(stream) && !isWritable(stream)) {
        throw new ERR_INVALID_ARG_VALUE("stream", stream, "must be writable");
      }
      const composedStream = staticCompose(this, stream);
      if (options !== null && options !== void 0 && options.signal) {
        addAbortSignalNoValidate(options.signal, composedStream);
      }
      return composedStream;
    }
    function map(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let concurrency = 1;
      if ((options === null || options === void 0 ? void 0 : options.concurrency) != null) {
        concurrency = MathFloor(options.concurrency);
      }
      let highWaterMark = concurrency - 1;
      if ((options === null || options === void 0 ? void 0 : options.highWaterMark) != null) {
        highWaterMark = MathFloor(options.highWaterMark);
      }
      validateInteger(concurrency, "options.concurrency", 1);
      validateInteger(highWaterMark, "options.highWaterMark", 0);
      highWaterMark += concurrency;
      return (async function* map2() {
        const signal = require_util().AbortSignalAny(
          [options === null || options === void 0 ? void 0 : options.signal].filter(Boolean2)
        );
        const stream = this;
        const queue = [];
        const signalOpt = {
          signal
        };
        let next;
        let resume;
        let done = false;
        let cnt = 0;
        function onCatch() {
          done = true;
          afterItemProcessed();
        }
        function afterItemProcessed() {
          cnt -= 1;
          maybeResume();
        }
        function maybeResume() {
          if (resume && !done && cnt < concurrency && queue.length < highWaterMark) {
            resume();
            resume = null;
          }
        }
        async function pump() {
          try {
            for await (let val of stream) {
              if (done) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              try {
                val = fn(val, signalOpt);
                if (val === kEmpty) {
                  continue;
                }
                val = PromiseResolve(val);
              } catch (err) {
                val = PromiseReject(err);
              }
              cnt += 1;
              PromisePrototypeThen(val, afterItemProcessed, onCatch);
              queue.push(val);
              if (next) {
                next();
                next = null;
              }
              if (!done && (queue.length >= highWaterMark || cnt >= concurrency)) {
                await new Promise2((resolve) => {
                  resume = resolve;
                });
              }
            }
            queue.push(kEof);
          } catch (err) {
            const val = PromiseReject(err);
            PromisePrototypeThen(val, afterItemProcessed, onCatch);
            queue.push(val);
          } finally {
            done = true;
            if (next) {
              next();
              next = null;
            }
          }
        }
        pump();
        try {
          while (true) {
            while (queue.length > 0) {
              const val = await queue[0];
              if (val === kEof) {
                return;
              }
              if (signal.aborted) {
                throw new AbortError();
              }
              if (val !== kEmpty) {
                yield val;
              }
              queue.shift();
              maybeResume();
            }
            await new Promise2((resolve) => {
              next = resolve;
            });
          }
        } finally {
          done = true;
          if (resume) {
            resume();
            resume = null;
          }
        }
      }).call(this);
    }
    function asIndexedPairs(options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      return (async function* asIndexedPairs2() {
        let index = 0;
        for await (const val of this) {
          var _options$signal;
          if (options !== null && options !== void 0 && (_options$signal = options.signal) !== null && _options$signal !== void 0 && _options$signal.aborted) {
            throw new AbortError({
              cause: options.signal.reason
            });
          }
          yield [index++, val];
        }
      }).call(this);
    }
    async function some(fn, options = void 0) {
      for await (const unused of filter.call(this, fn, options)) {
        return true;
      }
      return false;
    }
    async function every(fn, options = void 0) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      return !await some.call(
        this,
        async (...args) => {
          return !await fn(...args);
        },
        options
      );
    }
    async function find(fn, options) {
      for await (const result of filter.call(this, fn, options)) {
        return result;
      }
      return void 0;
    }
    async function forEach(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function forEachFn(value, options2) {
        await fn(value, options2);
        return kEmpty;
      }
      for await (const unused of map.call(this, forEachFn, options)) ;
    }
    function filter(fn, options) {
      if (typeof fn !== "function") {
        throw new ERR_INVALID_ARG_TYPE("fn", ["Function", "AsyncFunction"], fn);
      }
      async function filterFn(value, options2) {
        if (await fn(value, options2)) {
          return value;
        }
        return kEmpty;
      }
      return map.call(this, filterFn, options);
    }
    var ReduceAwareErrMissingArgs = class extends ERR_MISSING_ARGS {
      constructor() {
        super("reduce");
        this.message = "Reduce of an empty stream requires an initial value";
      }
    };
    async function reduce(reducer, initialValue, options) {
      var _options$signal2;
      if (typeof reducer !== "function") {
        throw new ERR_INVALID_ARG_TYPE("reducer", ["Function", "AsyncFunction"], reducer);
      }
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      let hasInitialValue = arguments.length > 1;
      if (options !== null && options !== void 0 && (_options$signal2 = options.signal) !== null && _options$signal2 !== void 0 && _options$signal2.aborted) {
        const err = new AbortError(void 0, {
          cause: options.signal.reason
        });
        this.once("error", () => {
        });
        await finished(this.destroy(err));
        throw err;
      }
      const ac = new AbortController2();
      const signal = ac.signal;
      if (options !== null && options !== void 0 && options.signal) {
        const opts = {
          once: true,
          [kWeakHandler]: this,
          [kResistStopPropagation]: true
        };
        options.signal.addEventListener("abort", () => ac.abort(), opts);
      }
      let gotAnyItemFromStream = false;
      try {
        for await (const value of this) {
          var _options$signal3;
          gotAnyItemFromStream = true;
          if (options !== null && options !== void 0 && (_options$signal3 = options.signal) !== null && _options$signal3 !== void 0 && _options$signal3.aborted) {
            throw new AbortError();
          }
          if (!hasInitialValue) {
            initialValue = value;
            hasInitialValue = true;
          } else {
            initialValue = await reducer(initialValue, value, {
              signal
            });
          }
        }
        if (!gotAnyItemFromStream && !hasInitialValue) {
          throw new ReduceAwareErrMissingArgs();
        }
      } finally {
        ac.abort();
      }
      return initialValue;
    }
    async function toArray(options) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      const result = [];
      for await (const val of this) {
        var _options$signal4;
        if (options !== null && options !== void 0 && (_options$signal4 = options.signal) !== null && _options$signal4 !== void 0 && _options$signal4.aborted) {
          throw new AbortError(void 0, {
            cause: options.signal.reason
          });
        }
        ArrayPrototypePush(result, val);
      }
      return result;
    }
    function flatMap(fn, options) {
      const values = map.call(this, fn, options);
      return (async function* flatMap2() {
        for await (const val of values) {
          yield* val;
        }
      }).call(this);
    }
    function toIntegerOrInfinity(number) {
      number = Number2(number);
      if (NumberIsNaN(number)) {
        return 0;
      }
      if (number < 0) {
        throw new ERR_OUT_OF_RANGE("number", ">= 0", number);
      }
      return number;
    }
    function drop(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* drop2() {
        var _options$signal5;
        if (options !== null && options !== void 0 && (_options$signal5 = options.signal) !== null && _options$signal5 !== void 0 && _options$signal5.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal6;
          if (options !== null && options !== void 0 && (_options$signal6 = options.signal) !== null && _options$signal6 !== void 0 && _options$signal6.aborted) {
            throw new AbortError();
          }
          if (number-- <= 0) {
            yield val;
          }
        }
      }).call(this);
    }
    function take(number, options = void 0) {
      if (options != null) {
        validateObject(options, "options");
      }
      if ((options === null || options === void 0 ? void 0 : options.signal) != null) {
        validateAbortSignal(options.signal, "options.signal");
      }
      number = toIntegerOrInfinity(number);
      return (async function* take2() {
        var _options$signal7;
        if (options !== null && options !== void 0 && (_options$signal7 = options.signal) !== null && _options$signal7 !== void 0 && _options$signal7.aborted) {
          throw new AbortError();
        }
        for await (const val of this) {
          var _options$signal8;
          if (options !== null && options !== void 0 && (_options$signal8 = options.signal) !== null && _options$signal8 !== void 0 && _options$signal8.aborted) {
            throw new AbortError();
          }
          if (number-- > 0) {
            yield val;
          }
          if (number <= 0) {
            return;
          }
        }
      }).call(this);
    }
    module2.exports.streamReturningOperators = {
      asIndexedPairs: deprecate(asIndexedPairs, "readable.asIndexedPairs will be removed in a future version."),
      drop,
      filter,
      flatMap,
      map,
      take,
      compose
    };
    module2.exports.promiseReturningOperators = {
      every,
      forEach,
      reduce,
      toArray,
      some,
      find
    };
  }
});

// node_modules/readable-stream/lib/stream/promises.js
var require_promises = __commonJS({
  "node_modules/readable-stream/lib/stream/promises.js"(exports, module2) {
    "use strict";
    var { ArrayPrototypePop, Promise: Promise2 } = require_primordials();
    var { isIterable, isNodeStream, isWebStream } = require_utils();
    var { pipelineImpl: pl } = require_pipeline();
    var { finished } = require_end_of_stream();
    require_stream();
    function pipeline(...streams) {
      return new Promise2((resolve, reject) => {
        let signal;
        let end;
        const lastArg = streams[streams.length - 1];
        if (lastArg && typeof lastArg === "object" && !isNodeStream(lastArg) && !isIterable(lastArg) && !isWebStream(lastArg)) {
          const options = ArrayPrototypePop(streams);
          signal = options.signal;
          end = options.end;
        }
        pl(
          streams,
          (err, value) => {
            if (err) {
              reject(err);
            } else {
              resolve(value);
            }
          },
          {
            signal,
            end
          }
        );
      });
    }
    module2.exports = {
      finished,
      pipeline
    };
  }
});

// node_modules/readable-stream/lib/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/stream.js"(exports, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var { ObjectDefineProperty, ObjectKeys, ReflectApply } = require_primordials();
    var {
      promisify: { custom: customPromisify }
    } = require_util();
    var { streamReturningOperators, promiseReturningOperators } = require_operators();
    var {
      codes: { ERR_ILLEGAL_CONSTRUCTOR }
    } = require_errors();
    var compose = require_compose();
    var { setDefaultHighWaterMark, getDefaultHighWaterMark } = require_state();
    var { pipeline } = require_pipeline();
    var { destroyer } = require_destroy();
    var eos = require_end_of_stream();
    var promises = require_promises();
    var utils = require_utils();
    var Stream = module2.exports = require_legacy().Stream;
    Stream.isDestroyed = utils.isDestroyed;
    Stream.isDisturbed = utils.isDisturbed;
    Stream.isErrored = utils.isErrored;
    Stream.isReadable = utils.isReadable;
    Stream.isWritable = utils.isWritable;
    Stream.Readable = require_readable();
    for (const key of ObjectKeys(streamReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return Stream.Readable.from(ReflectApply(op, this, args));
      };
      const op = streamReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    for (const key of ObjectKeys(promiseReturningOperators)) {
      let fn = function(...args) {
        if (new.target) {
          throw ERR_ILLEGAL_CONSTRUCTOR();
        }
        return ReflectApply(op, this, args);
      };
      const op = promiseReturningOperators[key];
      ObjectDefineProperty(fn, "name", {
        __proto__: null,
        value: op.name
      });
      ObjectDefineProperty(fn, "length", {
        __proto__: null,
        value: op.length
      });
      ObjectDefineProperty(Stream.Readable.prototype, key, {
        __proto__: null,
        value: fn,
        enumerable: false,
        configurable: true,
        writable: true
      });
    }
    Stream.Writable = require_writable();
    Stream.Duplex = require_duplex();
    Stream.Transform = require_transform();
    Stream.PassThrough = require_passthrough();
    Stream.pipeline = pipeline;
    var { addAbortSignal } = require_add_abort_signal();
    Stream.addAbortSignal = addAbortSignal;
    Stream.finished = eos;
    Stream.destroy = destroyer;
    Stream.compose = compose;
    Stream.setDefaultHighWaterMark = setDefaultHighWaterMark;
    Stream.getDefaultHighWaterMark = getDefaultHighWaterMark;
    ObjectDefineProperty(Stream, "promises", {
      __proto__: null,
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    ObjectDefineProperty(pipeline, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.pipeline;
      }
    });
    ObjectDefineProperty(eos, customPromisify, {
      __proto__: null,
      enumerable: true,
      get() {
        return promises.finished;
      }
    });
    Stream.Stream = Stream;
    Stream._isUint8Array = function isUint8Array(value) {
      return value instanceof Uint8Array;
    };
    Stream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    };
  }
});

// node_modules/readable-stream/lib/ours/browser.js
var require_browser3 = __commonJS({
  "node_modules/readable-stream/lib/ours/browser.js"(exports, module2) {
    "use strict";
    var CustomStream = require_stream();
    var promises = require_promises();
    var originalDestroy = CustomStream.Readable.destroy;
    module2.exports = CustomStream.Readable;
    module2.exports._uint8ArrayToBuffer = CustomStream._uint8ArrayToBuffer;
    module2.exports._isUint8Array = CustomStream._isUint8Array;
    module2.exports.isDisturbed = CustomStream.isDisturbed;
    module2.exports.isErrored = CustomStream.isErrored;
    module2.exports.isReadable = CustomStream.isReadable;
    module2.exports.Readable = CustomStream.Readable;
    module2.exports.Writable = CustomStream.Writable;
    module2.exports.Duplex = CustomStream.Duplex;
    module2.exports.Transform = CustomStream.Transform;
    module2.exports.PassThrough = CustomStream.PassThrough;
    module2.exports.addAbortSignal = CustomStream.addAbortSignal;
    module2.exports.finished = CustomStream.finished;
    module2.exports.destroy = CustomStream.destroy;
    module2.exports.destroy = originalDestroy;
    module2.exports.pipeline = CustomStream.pipeline;
    module2.exports.compose = CustomStream.compose;
    Object.defineProperty(CustomStream, "promises", {
      configurable: true,
      enumerable: true,
      get() {
        return promises;
      }
    });
    module2.exports.Stream = CustomStream.Stream;
    module2.exports.default = module2.exports;
  }
});

// node_modules/cross-fetch/dist/browser-ponyfill.js
var require_browser_ponyfill = __commonJS({
  "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module2) {
    var __global__ = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global !== "undefined" && global;
    var __globalThis__ = function() {
      function F() {
        this.fetch = false;
        this.DOMException = __global__.DOMException;
      }
      F.prototype = __global__;
      return new F();
    }();
    (function(globalThis2) {
      var irrelevant = function(exports2) {
        var g = typeof globalThis2 !== "undefined" && globalThis2 || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
        typeof global !== "undefined" && global || {};
        var support = {
          searchParams: "URLSearchParams" in g,
          iterable: "Symbol" in g && "iterator" in Symbol,
          blob: "FileReader" in g && "Blob" in g && function() {
            try {
              new Blob();
              return true;
            } catch (e) {
              return false;
            }
          }(),
          formData: "FormData" in g,
          arrayBuffer: "ArrayBuffer" in g
        };
        function isDataView(obj) {
          return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
          var viewClasses = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]"
          ];
          var isArrayBufferView = ArrayBuffer.isView || function(obj) {
            return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
          };
        }
        function normalizeName(name) {
          if (typeof name !== "string") {
            name = String(name);
          }
          if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
            throw new TypeError('Invalid character in header field name: "' + name + '"');
          }
          return name.toLowerCase();
        }
        function normalizeValue(value) {
          if (typeof value !== "string") {
            value = String(value);
          }
          return value;
        }
        function iteratorFor(items) {
          var iterator = {
            next: function() {
              var value = items.shift();
              return { done: value === void 0, value };
            }
          };
          if (support.iterable) {
            iterator[Symbol.iterator] = function() {
              return iterator;
            };
          }
          return iterator;
        }
        function Headers2(headers) {
          this.map = {};
          if (headers instanceof Headers2) {
            headers.forEach(function(value, name) {
              this.append(name, value);
            }, this);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(header) {
              if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
              }
              this.append(header[0], header[1]);
            }, this);
          } else if (headers) {
            Object.getOwnPropertyNames(headers).forEach(function(name) {
              this.append(name, headers[name]);
            }, this);
          }
        }
        Headers2.prototype.append = function(name, value) {
          name = normalizeName(name);
          value = normalizeValue(value);
          var oldValue = this.map[name];
          this.map[name] = oldValue ? oldValue + ", " + value : value;
        };
        Headers2.prototype["delete"] = function(name) {
          delete this.map[normalizeName(name)];
        };
        Headers2.prototype.get = function(name) {
          name = normalizeName(name);
          return this.has(name) ? this.map[name] : null;
        };
        Headers2.prototype.has = function(name) {
          return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers2.prototype.set = function(name, value) {
          this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers2.prototype.forEach = function(callback, thisArg) {
          for (var name in this.map) {
            if (this.map.hasOwnProperty(name)) {
              callback.call(thisArg, this.map[name], name, this);
            }
          }
        };
        Headers2.prototype.keys = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push(name);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.values = function() {
          var items = [];
          this.forEach(function(value) {
            items.push(value);
          });
          return iteratorFor(items);
        };
        Headers2.prototype.entries = function() {
          var items = [];
          this.forEach(function(value, name) {
            items.push([name, value]);
          });
          return iteratorFor(items);
        };
        if (support.iterable) {
          Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
        }
        function consumed(body) {
          if (body._noBody) return;
          if (body.bodyUsed) {
            return Promise.reject(new TypeError("Already read"));
          }
          body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
          return new Promise(function(resolve, reject) {
            reader.onload = function() {
              resolve(reader.result);
            };
            reader.onerror = function() {
              reject(reader.error);
            };
          });
        }
        function readBlobAsArrayBuffer(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          reader.readAsArrayBuffer(blob);
          return promise;
        }
        function readBlobAsText(blob) {
          var reader = new FileReader();
          var promise = fileReaderReady(reader);
          var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
          var encoding = match ? match[1] : "utf-8";
          reader.readAsText(blob, encoding);
          return promise;
        }
        function readArrayBufferAsText(buf) {
          var view = new Uint8Array(buf);
          var chars = new Array(view.length);
          for (var i = 0; i < view.length; i++) {
            chars[i] = String.fromCharCode(view[i]);
          }
          return chars.join("");
        }
        function bufferClone(buf) {
          if (buf.slice) {
            return buf.slice(0);
          } else {
            var view = new Uint8Array(buf.byteLength);
            view.set(new Uint8Array(buf));
            return view.buffer;
          }
        }
        function Body() {
          this.bodyUsed = false;
          this._initBody = function(body) {
            this.bodyUsed = this.bodyUsed;
            this._bodyInit = body;
            if (!body) {
              this._noBody = true;
              this._bodyText = "";
            } else if (typeof body === "string") {
              this._bodyText = body;
            } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
              this._bodyBlob = body;
            } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
              this._bodyFormData = body;
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
              this._bodyText = body.toString();
            } else if (support.arrayBuffer && support.blob && isDataView(body)) {
              this._bodyArrayBuffer = bufferClone(body.buffer);
              this._bodyInit = new Blob([this._bodyArrayBuffer]);
            } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
              this._bodyArrayBuffer = bufferClone(body);
            } else {
              this._bodyText = body = Object.prototype.toString.call(body);
            }
            if (!this.headers.get("content-type")) {
              if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
              } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
              }
            }
          };
          if (support.blob) {
            this.blob = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
              } else {
                return Promise.resolve(new Blob([this._bodyText]));
              }
            };
          }
          this.arrayBuffer = function() {
            if (this._bodyArrayBuffer) {
              var isConsumed = consumed(this);
              if (isConsumed) {
                return isConsumed;
              } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(
                  this._bodyArrayBuffer.buffer.slice(
                    this._bodyArrayBuffer.byteOffset,
                    this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                  )
                );
              } else {
                return Promise.resolve(this._bodyArrayBuffer);
              }
            } else if (support.blob) {
              return this.blob().then(readBlobAsArrayBuffer);
            } else {
              throw new Error("could not read as ArrayBuffer");
            }
          };
          this.text = function() {
            var rejected = consumed(this);
            if (rejected) {
              return rejected;
            }
            if (this._bodyBlob) {
              return readBlobAsText(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
              return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
            } else if (this._bodyFormData) {
              throw new Error("could not read FormData body as text");
            } else {
              return Promise.resolve(this._bodyText);
            }
          };
          if (support.formData) {
            this.formData = function() {
              return this.text().then(decode);
            };
          }
          this.json = function() {
            return this.text().then(JSON.parse);
          };
          return this;
        }
        var methods = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];
        function normalizeMethod(method) {
          var upcased = method.toUpperCase();
          return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
          if (!(this instanceof Request)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          options = options || {};
          var body = options.body;
          if (input instanceof Request) {
            if (input.bodyUsed) {
              throw new TypeError("Already read");
            }
            this.url = input.url;
            this.credentials = input.credentials;
            if (!options.headers) {
              this.headers = new Headers2(input.headers);
            }
            this.method = input.method;
            this.mode = input.mode;
            this.signal = input.signal;
            if (!body && input._bodyInit != null) {
              body = input._bodyInit;
              input.bodyUsed = true;
            }
          } else {
            this.url = String(input);
          }
          this.credentials = options.credentials || this.credentials || "same-origin";
          if (options.headers || !this.headers) {
            this.headers = new Headers2(options.headers);
          }
          this.method = normalizeMethod(options.method || this.method || "GET");
          this.mode = options.mode || this.mode || null;
          this.signal = options.signal || this.signal || function() {
            if ("AbortController" in g) {
              var ctrl = new AbortController();
              return ctrl.signal;
            }
          }();
          this.referrer = null;
          if ((this.method === "GET" || this.method === "HEAD") && body) {
            throw new TypeError("Body not allowed for GET or HEAD requests");
          }
          this._initBody(body);
          if (this.method === "GET" || this.method === "HEAD") {
            if (options.cache === "no-store" || options.cache === "no-cache") {
              var reParamSearch = /([?&])_=[^&]*/;
              if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + (/* @__PURE__ */ new Date()).getTime());
              } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
              }
            }
          }
        }
        Request.prototype.clone = function() {
          return new Request(this, { body: this._bodyInit });
        };
        function decode(body) {
          var form = new FormData();
          body.trim().split("&").forEach(function(bytes) {
            if (bytes) {
              var split = bytes.split("=");
              var name = split.shift().replace(/\+/g, " ");
              var value = split.join("=").replace(/\+/g, " ");
              form.append(decodeURIComponent(name), decodeURIComponent(value));
            }
          });
          return form;
        }
        function parseHeaders(rawHeaders) {
          var headers = new Headers2();
          var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
          preProcessedHeaders.split("\r").map(function(header) {
            return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
          }).forEach(function(line) {
            var parts = line.split(":");
            var key = parts.shift().trim();
            if (key) {
              var value = parts.join(":").trim();
              try {
                headers.append(key, value);
              } catch (error) {
                console.warn("Response " + error.message);
              }
            }
          });
          return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
          if (!(this instanceof Response)) {
            throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
          }
          if (!options) {
            options = {};
          }
          this.type = "default";
          this.status = options.status === void 0 ? 200 : options.status;
          if (this.status < 200 || this.status > 599) {
            throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
          }
          this.ok = this.status >= 200 && this.status < 300;
          this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
          this.headers = new Headers2(options.headers);
          this.url = options.url || "";
          this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
          return new Response(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new Headers2(this.headers),
            url: this.url
          });
        };
        Response.error = function() {
          var response = new Response(null, { status: 200, statusText: "" });
          response.ok = false;
          response.status = 0;
          response.type = "error";
          return response;
        };
        var redirectStatuses = [301, 302, 303, 307, 308];
        Response.redirect = function(url, status) {
          if (redirectStatuses.indexOf(status) === -1) {
            throw new RangeError("Invalid status code");
          }
          return new Response(null, { status, headers: { location: url } });
        };
        exports2.DOMException = g.DOMException;
        try {
          new exports2.DOMException();
        } catch (err) {
          exports2.DOMException = function(message, name) {
            this.message = message;
            this.name = name;
            var error = Error(message);
            this.stack = error.stack;
          };
          exports2.DOMException.prototype = Object.create(Error.prototype);
          exports2.DOMException.prototype.constructor = exports2.DOMException;
        }
        function fetch(input, init) {
          return new Promise(function(resolve, reject) {
            var request = new Request(input, init);
            if (request.signal && request.signal.aborted) {
              return reject(new exports2.DOMException("Aborted", "AbortError"));
            }
            var xhr = new XMLHttpRequest();
            function abortXhr() {
              xhr.abort();
            }
            xhr.onload = function() {
              var options = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
              };
              if (request.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options.status = 200;
              } else {
                options.status = xhr.status;
              }
              options.url = "responseURL" in xhr ? xhr.responseURL : options.headers.get("X-Request-URL");
              var body = "response" in xhr ? xhr.response : xhr.responseText;
              setTimeout(function() {
                resolve(new Response(body, options));
              }, 0);
            };
            xhr.onerror = function() {
              setTimeout(function() {
                reject(new TypeError("Network request failed"));
              }, 0);
            };
            xhr.ontimeout = function() {
              setTimeout(function() {
                reject(new TypeError("Network request timed out"));
              }, 0);
            };
            xhr.onabort = function() {
              setTimeout(function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              }, 0);
            };
            function fixUrl(url) {
              try {
                return url === "" && g.location.href ? g.location.href : url;
              } catch (e) {
                return url;
              }
            }
            xhr.open(request.method, fixUrl(request.url), true);
            if (request.credentials === "include") {
              xhr.withCredentials = true;
            } else if (request.credentials === "omit") {
              xhr.withCredentials = false;
            }
            if ("responseType" in xhr) {
              if (support.blob) {
                xhr.responseType = "blob";
              } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
              }
            }
            if (init && typeof init.headers === "object" && !(init.headers instanceof Headers2 || g.Headers && init.headers instanceof g.Headers)) {
              var names = [];
              Object.getOwnPropertyNames(init.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
              });
              request.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                  xhr.setRequestHeader(name, value);
                }
              });
            } else {
              request.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
              });
            }
            if (request.signal) {
              request.signal.addEventListener("abort", abortXhr);
              xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                  request.signal.removeEventListener("abort", abortXhr);
                }
              };
            }
            xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
          });
        }
        fetch.polyfill = true;
        if (!g.fetch) {
          g.fetch = fetch;
          g.Headers = Headers2;
          g.Request = Request;
          g.Response = Response;
        }
        exports2.Headers = Headers2;
        exports2.Request = Request;
        exports2.Response = Response;
        exports2.fetch = fetch;
        return exports2;
      }({});
    })(__globalThis__);
    __globalThis__.fetch.ponyfill = true;
    delete __globalThis__.fetch.polyfill;
    var ctx = __global__.fetch ? __global__ : __globalThis__;
    exports = ctx.fetch;
    exports.default = ctx.fetch;
    exports.fetch = ctx.fetch;
    exports.Headers = ctx.Headers;
    exports.Request = ctx.Request;
    exports.Response = ctx.Response;
    module2.exports = exports;
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e, r, t) {
  return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}

// node_modules/rdflib/esm/class-order.js
var ClassOrder = {
  "Literal": 1,
  "Collection": 3,
  "Graph": 4,
  "NamedNode": 5,
  "BlankNode": 6,
  "Variable": 7
};
var class_order_default = ClassOrder;

// node_modules/rdflib/esm/node-internal.js
var Node2 = class {
  constructor(value) {
    _defineProperty(this, "termType", void 0);
    _defineProperty(this, "classOrder", void 0);
    _defineProperty(this, "value", void 0);
    this.value = value;
  }
  /**
   * Creates the substituted node for this one, according to the specified bindings
   * @param bindings - Bindings of identifiers to nodes
   */
  substitute(bindings) {
    return this;
  }
  /**
   * Compares this node with another
   * @see {equals} to check if two nodes are equal
   * @param other - The other node
   */
  compareTerm(other) {
    if (this.classOrder < other.classOrder) {
      return -1;
    }
    if (this.classOrder > other.classOrder) {
      return 1;
    }
    if (this.value < other.value) {
      return -1;
    }
    if (this.value > other.value) {
      return 1;
    }
    return 0;
  }
  /**
   * Compares whether the two nodes are equal
   * @param other The other node
   */
  equals(other) {
    if (!other) {
      return false;
    }
    return this.termType === other.termType && this.value === other.value;
  }
  /**
   * Creates a hash for this node
   * @deprecated use {rdfFactory.id} instead if possible
   */
  hashString() {
    return this.toCanonical();
  }
  /**
   * Compares whether this node is the same as the other one
   * @param other - Another node
   */
  sameTerm(other) {
    return this.equals(other);
  }
  /**
   * Creates a canonical string representation of this node
   */
  toCanonical() {
    return this.toNT();
  }
  /**
   * Creates a n-triples string representation of this node
   */
  toNT() {
    return this.toString();
  }
  /**
   * Creates a n-quads string representation of this node
   */
  toNQ() {
    return this.toNT();
  }
  /**
   * Creates a string representation of this node
   */
  toString() {
    throw new Error("Node.toString() is abstract - see the subclasses instead");
  }
};
_defineProperty(Node2, "fromValue", void 0);
_defineProperty(Node2, "toJS", void 0);

// node_modules/rdflib/esm/types.js
var NamedNodeTermType = "NamedNode";
var BlankNodeTermType = "BlankNode";
var LiteralTermType = "Literal";
var VariableTermType = "Variable";
var DefaultGraphTermType = "DefaultGraph";
var CollectionTermType = "Collection";
var EmptyTermType = "Empty";
var GraphTermType = "Graph";
var HTMLContentType = "text/html";
var JSONLDContentType = "application/ld+json";
var N3ContentType = "text/n3";
var N3LegacyContentType = "application/n3";
var NQuadsAltContentType = "application/nquads";
var NQuadsContentType = "application/n-quads";
var NTriplesContentType = "application/n-triples";
var RDFXMLContentType = "application/rdf+xml";
var SPARQLUpdateContentType = "application/sparql-update";
var SPARQLUpdateSingleMatchContentType = "application/sparql-update-single-match";
var TurtleContentType = "text/turtle";
var TurtleLegacyContentType = "application/x-turtle";
var XHTMLContentType = "application/xhtml+xml";

// node_modules/rdflib/esm/blank-node.js
var BlankNode = class _BlankNode extends Node2 {
  static getId(id) {
    if (id) {
      if (typeof id !== "string") {
        throw new Error("Bad id argument to new blank node: " + id);
      }
      if (id.includes("#")) {
        let fragments = id.split("#");
        return fragments[fragments.length - 1];
      }
      return id;
    }
    return "n" + _BlankNode.nextId++;
  }
  /**
   * Initializes this node
   * @param [id] The identifier for the blank node
   */
  constructor(id) {
    super(_BlankNode.getId(id));
    _defineProperty(this, "termType", BlankNodeTermType);
    _defineProperty(this, "classOrder", class_order_default.BlankNode);
    _defineProperty(this, "isBlank", 1);
    _defineProperty(this, "isVar", 1);
  }
  /**
   * The identifier for the blank node
   */
  get id() {
    return this.value;
  }
  set id(value) {
    this.value = value;
  }
  compareTerm(other) {
    if (this.classOrder < other.classOrder) {
      return -1;
    }
    if (this.classOrder > other.classOrder) {
      return 1;
    }
    if (this.id < other.id) {
      return -1;
    }
    if (this.id > other.id) {
      return 1;
    }
    return 0;
  }
  /**
   * Gets a copy of this blank node in the specified formula
   * @param formula The formula
   */
  copy(formula2) {
    var bnodeNew = new _BlankNode();
    formula2.copyTo(this, bnodeNew);
    return bnodeNew;
  }
  toCanonical() {
    return _BlankNode.NTAnonymousNodePrefix + this.value;
  }
  toString() {
    return _BlankNode.NTAnonymousNodePrefix + this.id;
  }
};
_defineProperty(BlankNode, "nextId", 0);
_defineProperty(BlankNode, "NTAnonymousNodePrefix", "_:");

// node_modules/rdflib/esm/utils/termValue.js
function termValue(node) {
  if (typeof node === "string") {
    return node;
  }
  return node.value;
}

// node_modules/rdflib/esm/utils/terms.js
function isStatement(obj) {
  return typeof obj === "object" && obj !== null && "subject" in obj;
}
function isStore(obj) {
  return typeof obj === "object" && obj !== null && "statements" in obj;
}
function isCollection(obj) {
  return isTerm(obj) && obj.termType === CollectionTermType;
}
function isRDFlibObject(obj) {
  return obj && Object.prototype.hasOwnProperty.call(obj, "termType") && (obj.termType === NamedNodeTermType || obj.termType === VariableTermType || obj.termType === BlankNodeTermType || obj.termType === CollectionTermType || obj.termType === LiteralTermType || obj.termType === GraphTermType);
}
function isRDFlibSubject(obj) {
  return obj && Object.prototype.hasOwnProperty.call(obj, "termType") && (obj.termType === NamedNodeTermType || obj.termType === VariableTermType || obj.termType === BlankNodeTermType || obj.termType === CollectionTermType || obj.termType === LiteralTermType || obj.termType === GraphTermType);
}
function isRDFlibPredicate(obj) {
  return isTerm(obj) && (obj.termType === NamedNodeTermType || obj.termType === BlankNodeTermType || obj.termType === VariableTermType);
}
function isVariable(obj) {
  return isTerm(obj) && obj.termType === VariableTermType;
}
function isTerm(obj) {
  return typeof obj === "object" && obj !== null && "termType" in obj;
}
function isLiteral(value) {
  return value.termType === LiteralTermType;
}
function isQuad(obj) {
  return typeof obj === "object" && obj !== null && "subject" in obj && "predicate" in obj && "object" in obj;
}
function isNamedNode(obj) {
  return isTerm(obj) && obj.termType === "NamedNode";
}
function isBlankNode(obj) {
  return isTerm(obj) && "termType" in obj && obj.termType === "BlankNode";
}
function isSubject(obj) {
  return isTerm(obj) && (obj.termType === NamedNodeTermType || obj.termType === VariableTermType || obj.termType === BlankNodeTermType);
}
function isPredicate(obj) {
  return isTerm(obj) && (obj.termType === NamedNodeTermType || obj.termType === VariableTermType);
}
function isRDFObject(obj) {
  return isTerm(obj) && (obj.termType === NamedNodeTermType || obj.termType === VariableTermType || obj.termType === BlankNodeTermType || obj.termType === LiteralTermType);
}
function isGraph(obj) {
  return isTerm(obj) && (obj.termType === NamedNodeTermType || obj.termType === VariableTermType || obj.termType === BlankNodeTermType || obj.termType === DefaultGraphTermType);
}

// node_modules/rdflib/esm/named-node.js
var NamedNode = class _NamedNode extends Node2 {
  /**
   * Create a named (IRI) RDF Node
   * @constructor
   * @param iri - The IRI for this node
   */
  constructor(iri) {
    super(termValue(iri));
    _defineProperty(this, "termType", NamedNodeTermType);
    _defineProperty(this, "classOrder", class_order_default.NamedNode);
    if (!this.value) {
      throw new Error("Missing IRI for NamedNode");
    }
    if (!this.value.includes(":")) {
      throw new Error('NamedNode IRI "' + iri + '" must be absolute.');
    }
    if (this.value.includes(" ")) {
      var message = 'Error: NamedNode IRI "' + iri + '" must not contain unencoded spaces.';
      throw new Error(message);
    }
  }
  /**
   * Returns an $rdf node for the containing directory, ending in slash.
   */
  dir() {
    var str = this.value.split("#")[0];
    var p = str.slice(0, -1).lastIndexOf("/");
    var q = str.indexOf("//");
    if (q >= 0 && p < q + 2 || p < 0) return null;
    return new _NamedNode(str.slice(0, p + 1));
  }
  /**
   * Returns an NN for the whole web site, ending in slash.
   * Contrast with the "origin" which does NOT have a trailing slash
   */
  site() {
    var str = this.value.split("#")[0];
    var p = str.indexOf("//");
    if (p < 0) throw new Error("This URI does not have a web site part (origin)");
    var q = str.indexOf("/", p + 2);
    if (q < 0) {
      return new _NamedNode(str.slice(0) + "/");
    } else {
      return new _NamedNode(str.slice(0, q + 1));
    }
  }
  /**
   * Creates the fetchable named node for the document.
   * Removes everything from the # anchor tag.
   */
  doc() {
    if (this.value.indexOf("#") < 0) {
      return this;
    } else {
      return new _NamedNode(this.value.split("#")[0]);
    }
  }
  /**
   * Returns the URI including <brackets>
   */
  toString() {
    return "<" + this.value + ">";
  }
  /** The local identifier with the document */
  id() {
    return this.value.split("#")[1];
  }
  /** Alias for value, favored by Tim */
  get uri() {
    return this.value;
  }
  set uri(uri) {
    this.value = uri;
  }
  /**
   * Creates a named node from the specified input value
   * @param value - An input value
   */
  static fromValue(value) {
    if (typeof value === "undefined" || value === null) {
      return value;
    }
    if (isTerm(value)) {
      return value;
    }
    return new _NamedNode(value);
  }
};

// node_modules/rdflib/esm/xsd-internal.js
var xsd_internal_default = {
  boolean: new NamedNode("http://www.w3.org/2001/XMLSchema#boolean"),
  dateTime: new NamedNode("http://www.w3.org/2001/XMLSchema#dateTime"),
  decimal: new NamedNode("http://www.w3.org/2001/XMLSchema#decimal"),
  double: new NamedNode("http://www.w3.org/2001/XMLSchema#double"),
  integer: new NamedNode("http://www.w3.org/2001/XMLSchema#integer"),
  langString: new NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"),
  string: new NamedNode("http://www.w3.org/2001/XMLSchema#string")
};

// node_modules/rdflib/esm/literal.js
var Literal = class _Literal extends Node2 {
  /**
   * Initializes a literal
   * @param value - The literal's lexical value
   * @param language - The language for the literal. Defaults to ''.
   * @param datatype - The literal's datatype as a named node. Defaults to xsd:string.
   */
  constructor(value, language, datatype) {
    super(value);
    _defineProperty(this, "termType", LiteralTermType);
    _defineProperty(this, "classOrder", class_order_default.Literal);
    _defineProperty(this, "datatype", xsd_internal_default.string);
    _defineProperty(this, "isVar", 0);
    _defineProperty(this, "language", "");
    if (language) {
      this.language = language;
      this.datatype = xsd_internal_default.langString;
    } else if (datatype) {
      this.datatype = NamedNode.fromValue(datatype);
    } else {
      this.datatype = xsd_internal_default.string;
    }
  }
  /**
   * Gets a copy of this literal
   */
  copy() {
    return new _Literal(this.value, this.lang, this.datatype);
  }
  /**
   * Gets whether two literals are the same
   * @param other The other statement
   */
  equals(other) {
    if (!other) {
      return false;
    }
    return this.termType === other.termType && this.value === other.value && this.language === other.language && (!this.datatype && !other.datatype || this.datatype && this.datatype.equals(other.datatype));
  }
  /**
   * The language for the literal
   * @deprecated use {language} instead
   */
  get lang() {
    return this.language;
  }
  set lang(language) {
    this.language = language || "";
  }
  toNT() {
    return _Literal.toNT(this);
  }
  /** Serializes a literal to an N-Triples string */
  static toNT(literal3) {
    if (typeof literal3.value === "number") {
      return "" + literal3.value;
    } else if (typeof literal3.value !== "string") {
      throw new Error("Value of RDF literal is not string or number: " + literal3.value);
    }
    var str = literal3.value;
    str = str.replace(/\\/g, "\\\\");
    str = str.replace(/\"/g, '\\"');
    str = str.replace(/\n/g, "\\n");
    str = str.replace(/\r/g, "\\r");
    str = '"' + str + '"';
    if (literal3.language) {
      str += "@" + literal3.language;
    } else if (!literal3.datatype.equals(xsd_internal_default.string)) {
      str += "^^" + literal3.datatype.toCanonical();
    }
    return str;
  }
  toString() {
    return "" + this.value;
  }
  /**
   * Builds a literal node from a boolean value
   * @param value - The value
   */
  static fromBoolean(value) {
    let strValue = value ? "1" : "0";
    return new _Literal(strValue, null, xsd_internal_default.boolean);
  }
  /**
   * Builds a literal node from a date value
   * @param value The value
   */
  static fromDate(value) {
    if (!(value instanceof Date)) {
      throw new TypeError("Invalid argument to Literal.fromDate()");
    }
    let d2 = function(x) {
      return ("" + (100 + x)).slice(1, 3);
    };
    let date = "" + value.getUTCFullYear() + "-" + d2(value.getUTCMonth() + 1) + "-" + d2(value.getUTCDate()) + "T" + d2(value.getUTCHours()) + ":" + d2(value.getUTCMinutes()) + ":" + d2(value.getUTCSeconds()) + "Z";
    return new _Literal(date, null, xsd_internal_default.dateTime);
  }
  /**
   * Builds a literal node from a number value
   * @param value - The value
   */
  static fromNumber(value) {
    if (typeof value !== "number") {
      throw new TypeError("Invalid argument to Literal.fromNumber()");
    }
    let datatype;
    const strValue = value.toString();
    if (strValue.indexOf("e") < 0 && Math.abs(value) <= Number.MAX_SAFE_INTEGER) {
      datatype = Number.isInteger(value) ? xsd_internal_default.integer : xsd_internal_default.decimal;
    } else {
      datatype = xsd_internal_default.double;
    }
    return new _Literal(strValue, null, datatype);
  }
  /**
   * Builds a literal node from an input value
   * @param value - The input value
   */
  static fromValue(value) {
    if (isLiteral(value)) {
      return value;
    }
    switch (typeof value) {
      case "object":
        if (value instanceof Date) {
          return _Literal.fromDate(value);
        }
      case "boolean":
        return _Literal.fromBoolean(value);
      case "number":
        return _Literal.fromNumber(value);
      case "string":
        return new _Literal(value);
    }
    throw new Error("Can't make literal from " + value + " of type " + typeof value);
  }
};

// node_modules/rdflib/esm/collection.js
function fromValue(value) {
  if (typeof value === "undefined" || value === null) {
    return value;
  }
  if (isTerm(value)) {
    return value;
  }
  if (Array.isArray(value)) {
    return new Collection(value);
  }
  return Literal.fromValue(value);
}
var Collection = class _Collection extends Node2 {
  constructor(initial) {
    super((BlankNode.nextId++).toString());
    _defineProperty(this, "termType", CollectionTermType);
    _defineProperty(this, "classOrder", class_order_default.Collection);
    _defineProperty(this, "closed", false);
    _defineProperty(this, "compareTerm", BlankNode.prototype.compareTerm);
    _defineProperty(this, "elements", []);
    _defineProperty(this, "isVar", 0);
    if (initial && initial.length > 0) {
      initial.forEach((element) => {
        this.elements.push(fromValue(element));
      });
    }
  }
  get id() {
    return this.value;
  }
  set id(value) {
    this.value = value;
  }
  /**
   * Appends an element to this collection
   * @param element - The new element
   */
  append(element) {
    return this.elements.push(element);
  }
  /**
   * Closes this collection
   */
  close() {
    this.closed = true;
    return this.closed;
  }
  /**
   * Removes the first element from the collection (and return it)
   */
  shift() {
    return this.elements.shift();
  }
  /**
   * Creates a new Collection with the substituting bindings applied
   * @param bindings - The bindings to substitute
   */
  substitute(bindings) {
    const elementsCopy = this.elements.map((ea) => ea.substitute(bindings));
    return new _Collection(elementsCopy);
  }
  toNT() {
    return _Collection.toNT(this);
  }
  static toNT(collection) {
    return BlankNode.NTAnonymousNodePrefix + collection.id;
  }
  /**
   * Serializes the collection to a string.
   * Surrounded by (parentheses) and separated by spaces.
   */
  toString() {
    return "(" + this.elements.join(" ") + ")";
  }
  /**
   * Prepends the specified element to the collection's front
   * @param element - The element to prepend
   */
  unshift(element) {
    return this.elements.unshift(element);
  }
};
_defineProperty(Collection, "termType", CollectionTermType);

// node_modules/rdflib/esm/empty.js
var Empty = class extends Node2 {
  constructor() {
    super("");
    _defineProperty(this, "termType", EmptyTermType);
  }
  toString() {
    return "()";
  }
};

// node_modules/rdflib/esm/utils/default-graph-uri.js
var defaultGraphURI = "chrome:theSession";
var defaultGraphNode = new NamedNode(defaultGraphURI);

// node_modules/rdflib/esm/default-graph.js
var DefaultGraph = class extends Node2 {
  constructor() {
    super("");
    _defineProperty(this, "value", "");
    _defineProperty(this, "termType", DefaultGraphTermType);
    _defineProperty(this, "uri", defaultGraphURI);
  }
  toCanonical() {
    return this.value;
  }
  toString() {
    return "DefaultGraph";
  }
};
function isDefaultGraph(object) {
  return !!object && object.termType === DefaultGraphTermType;
}

// node_modules/rdflib/esm/statement.js
var defaultGraph = new DefaultGraph();
var Statement = class _Statement {
  /**
   * Construct a new statement
   *
   * @param subject - The subject of the triple.  What the fact is about
   * @param predicate - The relationship which is asserted between the subject and object
   * @param object - The thing or data value which is asserted to be related to the subject
   * @param {NamedNode} graph - The document where the triple is or was or will be stored on the web.
   *
   * The graph param is a named node of the document in which the triple when it is stored
   *  on the web. It exists because when you have read data from various places in the web,
   *  the “graph” tells you _why_ you have the triple. (At the moment, it is just the
   *  document, in future it could be an inference step)
   *
   * When you do UpdateManager.update() then the graph’s of all the statements must be the same,
   *  and give the document you are patching. In future, we may have a more
   *  powerful update() which can update more than one document.
   */
  constructor(subject, predicate, object, graph2) {
    _defineProperty(this, "subject", void 0);
    _defineProperty(this, "predicate", void 0);
    _defineProperty(this, "object", void 0);
    _defineProperty(this, "graph", void 0);
    this.subject = Node2.fromValue(subject);
    this.predicate = Node2.fromValue(predicate);
    this.object = Node2.fromValue(object);
    this.graph = graph2 == void 0 ? defaultGraph : Node2.fromValue(graph2);
  }
  /** Alias for graph, favored by Tim */
  get why() {
    return this.graph;
  }
  set why(g) {
    this.graph = g;
  }
  /**
   * Checks whether two statements are the same
   * @param other - The other statement
   */
  equals(other) {
    return other.subject.equals(this.subject) && other.predicate.equals(this.predicate) && other.object.equals(this.object) && other.graph.equals(this.graph);
  }
  /**
   * Creates a statement with the bindings substituted
   * @param bindings The bindings
   */
  substitute(bindings) {
    const y = new _Statement(this.subject.substitute(bindings), this.predicate.substitute(bindings), this.object.substitute(bindings), isDefaultGraph(this.graph) ? this.graph : this.graph.substitute(bindings));
    return y;
  }
  /** Creates a canonical string representation of this statement. */
  toCanonical() {
    let terms = [this.subject.toCanonical(), this.predicate.toCanonical(), this.object.toCanonical()];
    if (this.graph && this.graph.termType !== DefaultGraphTermType) {
      terms.push(this.graph.toCanonical());
    }
    return terms.join(" ") + " .";
  }
  /** Creates a n-triples string representation of this statement */
  toNT() {
    return [this.subject.toNT(), this.predicate.toNT(), this.object.toNT()].join(" ") + " .";
  }
  /** Creates a n-quads string representation of this statement */
  toNQ() {
    return [this.subject.toNT(), this.predicate.toNT(), this.object.toNT(), isDefaultGraph(this.graph) ? "" : this.graph.toNT()].join(" ") + " .";
  }
  /** Creates a string representation of this statement */
  toString() {
    return this.toNT();
  }
};

// node_modules/rdflib/esm/uri.js
var uri_exports = {};
__export(uri_exports, {
  docpart: () => docpart,
  document: () => document2,
  hostpart: () => hostpart,
  join: () => join,
  protocol: () => protocol,
  refTo: () => refTo
});
var alert = alert || console.log;
function docpart(uri) {
  var i;
  i = uri.indexOf("#");
  if (i < 0) {
    return uri;
  } else {
    return uri.slice(0, i);
  }
}
function document2(x) {
  return new NamedNode(docpart(x));
}
function hostpart(u) {
  var m = /[^\/]*\/\/([^\/]*)\//.exec(u);
  if (m) {
    return m[1];
  } else {
    return "";
  }
}
function join(given, base) {
  var baseColon, baseScheme, baseSingle;
  var colon, lastSlash, path;
  var baseHash = base.indexOf("#");
  if (baseHash > 0) {
    base = base.slice(0, baseHash);
  }
  if (given.length === 0) {
    return base;
  }
  if (given.indexOf("#") === 0) {
    return base + given;
  }
  colon = given.indexOf(":");
  if (colon >= 0) {
    return given;
  }
  baseColon = base.indexOf(":");
  if (base.length === 0) {
    return given;
  }
  if (baseColon < 0) {
    alert("Invalid base: " + base + " in join with given: " + given);
    return given;
  }
  baseScheme = base.slice(0, +baseColon + 1 || 9e9);
  if (given.indexOf("//") === 0) {
    return baseScheme + given;
  }
  if (base.indexOf("//", baseColon) === baseColon + 1) {
    baseSingle = base.indexOf("/", baseColon + 3);
    if (baseSingle < 0) {
      if (base.length - baseColon - 3 > 0) {
        return base + "/" + given;
      } else {
        return baseScheme + given;
      }
    }
  } else {
    baseSingle = base.indexOf("/", baseColon + 1);
    if (baseSingle < 0) {
      if (base.length - baseColon - 1 > 0) {
        return base + "/" + given;
      } else {
        return baseScheme + given;
      }
    }
  }
  if (given.indexOf("/") === 0) {
    return base.slice(0, baseSingle) + given;
  }
  path = base.slice(baseSingle);
  lastSlash = path.lastIndexOf("/");
  if (lastSlash < 0) {
    return baseScheme + given;
  }
  if (lastSlash >= 0 && lastSlash < path.length - 1) {
    path = path.slice(0, +lastSlash + 1 || 9e9);
  }
  path += given;
  while (path.match(/[^\/]*\/\.\.\//)) {
    path = path.replace(/[^\/]*\/\.\.\//, "");
  }
  path = path.replace(/\.\//g, "");
  path = path.replace(/\/\.$/, "/");
  return base.slice(0, baseSingle) + path;
}
function protocol(uri) {
  const i = uri.indexOf(":");
  if (i < 0) {
    return null;
  } else {
    return uri.slice(0, i);
  }
}
function refTo(base, uri) {
  var c, i, k, l, len, len1, n, o, p, q, ref, ref1, s;
  var commonHost = new RegExp("^[-_a-zA-Z0-9.]+:(//[^/]*)?/[^/]*$");
  if (!base) {
    return uri;
  }
  if (base === uri) {
    return "";
  }
  for (i = o = 0, len = uri.length; o < len; i = ++o) {
    const c2 = uri[i];
    if (c2 !== base[i]) {
      break;
    }
  }
  if (base.slice(0, i).match(commonHost)) {
    k = uri.indexOf("//");
    if (k < 0) {
      k = -2;
    }
    l = uri.indexOf("/", k + 2);
    if (uri[l + 1] !== "/" && base[l + 1] !== "/" && uri.slice(0, l) === base.slice(0, l)) {
      return uri.slice(l);
    }
  }
  if (uri[i] === "#" && base.length === i) {
    return uri.slice(i);
  }
  while (i > 0 && uri[i - 1] !== "/") {
    i--;
  }
  if (i < 3) {
    return uri;
  }
  if (base.indexOf("//", i - 2) > 0 || uri.indexOf("//", i - 2) > 0) {
    return uri;
  }
  if (base.indexOf(":", i) > 0) {
    return uri;
  }
  n = 0;
  ref = base.slice(i);
  for (p = 0, len1 = ref.length; p < len1; p++) {
    c = ref[p];
    if (c === "/") {
      n++;
    }
  }
  if (n === 0 && i < uri.length && uri[i] === "#") {
    return "./" + uri.slice(i);
  }
  if (n === 0 && i === uri.length) {
    return "./";
  }
  s = "";
  if (n > 0) {
    for (q = 1, ref1 = n; ref1 >= 1 ? q <= ref1 : q >= ref1; ref1 >= 1 ? ++q : --q) {
      s += "../";
    }
  }
  return s + uri.slice(i);
}

// node_modules/rdflib/esm/variable.js
var Variable = class _Variable extends Node2 {
  /**
   * Initializes this variable
   * @param name The variable's name
   */
  constructor(name = "") {
    super(name);
    _defineProperty(this, "termType", VariableTermType);
    _defineProperty(this, "base", "varid:");
    _defineProperty(this, "classOrder", class_order_default.Variable);
    _defineProperty(this, "isVar", 1);
    _defineProperty(this, "uri", void 0);
    this.base = "varid:";
    this.uri = join(name, this.base);
  }
  equals(other) {
    if (!other) {
      return false;
    }
    return this.termType === other.termType && this.value === other.value;
  }
  hashString() {
    return this.toString();
  }
  substitute(bindings) {
    var ref;
    return (ref = bindings[this.toNT()]) != null ? ref : this;
  }
  toString() {
    return _Variable.toString(this);
  }
  static toString(variable3) {
    if (variable3.uri.slice(0, variable3.base.length) === variable3.base) {
      return `?${variable3.uri.slice(variable3.base.length)}`;
    }
    return `?${variable3.uri}`;
  }
};

// node_modules/rdflib/esm/factories/factory-types.js
var Feature = function(Feature2) {
  Feature2["collections"] = "COLLECTIONS";
  Feature2["defaultGraphType"] = "DEFAULT_GRAPH_TYPE";
  Feature2["equalsMethod"] = "EQUALS_METHOD";
  Feature2["id"] = "ID";
  Feature2["identity"] = "IDENTITY";
  Feature2["reversibleId"] = "REVERSIBLE_ID";
  Feature2["variableType"] = "VARIABLE_TYPE";
  return Feature2;
}({});

// node_modules/rdflib/esm/factories/canonical-data-factory.js
var defaultGraph2 = new DefaultGraph();
var CanonicalDataFactory = {
  supports: {
    [Feature.collections]: false,
    [Feature.defaultGraphType]: false,
    [Feature.equalsMethod]: true,
    [Feature.identity]: false,
    [Feature.id]: true,
    [Feature.reversibleId]: false,
    [Feature.variableType]: true
  },
  /**
   * Creates a new blank node
   * @param value - The blank node's identifier
   */
  blankNode(value) {
    return new BlankNode(value);
  },
  defaultGraph: () => defaultGraph2,
  /**
   * Compares to (rdf) objects for equality.
   */
  equals(a, b) {
    if (a === b || !a || !b) {
      return true;
    }
    if (isQuad(a) || isQuad(b)) {
      if (isQuad(a) && isQuad(b)) {
        return this.equals(a.subject, b.subject) && this.equals(a.predicate, b.predicate) && this.equals(a.object, b.object) && this.equals(a.graph, b.graph);
      }
      return false;
    }
    if (isTerm(a) && isTerm(b)) {
      return this.id(a) === this.id(b);
    }
    return false;
  },
  /**
   * Generates a uniquely identifiably *idempotent* string for the given {term}.
   *
   * Equivalent to [[Term.hashString]]
   *
   * @example Use this to associate data with a term in an object
   *   { obj[id(term)] = "myData" }
   */
  id(term2) {
    if (!term2) {
      return "undefined";
    }
    if (isQuad(term2)) {
      return this.quadToNQ(term2);
    }
    switch (term2.termType) {
      case DefaultGraphTermType:
        return "defaultGraph";
      case VariableTermType:
        return Variable.toString(term2);
      default:
        const nq = this.termToNQ(term2);
        if (nq) {
          return nq;
        }
        throw new Error(`Can't id term with type '${term2.termType}'`);
    }
  },
  isQuad(obj) {
    return obj instanceof Statement;
  },
  /**
   * Creates a new literal node. Does some JS literal parsing for ease of use.
   * @param value - The lexical value
   * @param languageOrDatatype - Either the language or the datatype
   */
  literal(value, languageOrDatatype) {
    if (typeof value !== "string" && !languageOrDatatype) {
      return Literal.fromValue(value);
    }
    const strValue = typeof value === "string" ? value : "" + value;
    if (typeof languageOrDatatype === "string") {
      if (languageOrDatatype.indexOf(":") === -1) {
        return new Literal(strValue, languageOrDatatype);
      } else {
        return new Literal(strValue, null, this.namedNode(languageOrDatatype));
      }
    } else {
      return new Literal(strValue, null, languageOrDatatype);
    }
  },
  /**
   * Creates a new named node
   * @param value - The new named node
   */
  namedNode(value) {
    return new NamedNode(value);
  },
  /**
   * Creates a new statement
   * @param subject - The subject
   * @param predicate - The predicate
   * @param object - The object
   * @param graph - The containing graph
   */
  quad(subject, predicate, object, graph2) {
    return new Statement(subject, predicate, object, graph2 || defaultGraph2);
  },
  /**
   * Creates a new statement
   * @param subject - The subject
   * @param predicate - The predicate
   * @param object - The object
   * @param graph - The containing graph
   */
  triple(subject, predicate, object, graph2) {
    return this.quad(subject, predicate, object, graph2);
  },
  quadToNQ(q) {
    return `${this.termToNQ(q.subject)} ${this.termToNQ(q.predicate)} ${this.termToNQ(q.object)} ${this.termToNQ(q.graph)} .`;
  },
  /** Stringify a {term} to n-quads serialization. */
  termToNQ(term2) {
    switch (term2.termType) {
      case BlankNodeTermType:
        return "_:" + term2.value;
      case DefaultGraphTermType:
        return "";
      case EmptyTermType:
        return "<http://www.w3.org/1999/02/22-rdf-syntax-ns#nil>";
      case LiteralTermType:
        return Literal.toNT(term2);
      case GraphTermType:
      case NamedNodeTermType:
        return "<" + term2.value + ">";
      case CollectionTermType:
        return "(" + term2.elements.map((t) => this.termToNQ(t)).join(" ") + ")";
      default:
        throw new Error(`Can't serialize nonstandard term type (was '${term2.termType}')`);
    }
  },
  /** Convert an rdf object (term or quad) to n-quads serialization. */
  toNQ(term2) {
    if (this.isQuad(term2)) {
      return this.quadToNQ(term2);
    }
    return this.termToNQ(term2);
  },
  /**
   * Creates a new variable
   * @param name - The name for the variable
   */
  variable(name) {
    return new Variable(name);
  }
};
var canonical_data_factory_default = CanonicalDataFactory;

// node_modules/rdflib/esm/log.js
var log = {
  debug(x) {
  },
  warn(x) {
  },
  info(x) {
  },
  error(x) {
  },
  success(x) {
  },
  msg(x) {
  }
};
var log_default = log;

// node_modules/rdflib/esm/namespace.js
function Namespace(nsuri, factory) {
  const dataFactory = factory || {
    namedNode: (value) => new NamedNode(value)
  };
  return function(ln) {
    return dataFactory.namedNode(nsuri + (ln || ""));
  };
}

// node_modules/rdflib/esm/serializer.js
var ttl2jsonld = __toESM(require_ttl2jsonld());
var import_solid_namespace = __toESM(require_solid_namespace());

// node_modules/rdflib/esm/utils-js.js
var utils_js_exports = {};
__export(utils_js_exports, {
  DOMParserFactory: () => DOMParserFactory,
  RDFArrayRemove: () => RDFArrayRemove,
  callbackify: () => callbackify,
  domToString: () => domToString,
  dtstamp: () => dtstamp,
  dumpNode: () => dumpNode,
  heavyCompare: () => heavyCompare,
  heavyCompareSPO: () => heavyCompareSPO,
  linkRelationProperty: () => linkRelationProperty,
  log: () => log_default,
  mediaTypeClass: () => mediaTypeClass,
  output: () => output,
  parseXML: () => parseXML,
  stackString: () => stackString,
  string: () => string,
  string_startswith: () => string_startswith,
  uri: () => uri_exports
});
var import_xmldom = __toESM(require_lib());
var string = {
  template: stringTemplate
};
function mediaTypeClass(mediaType) {
  mediaType = mediaType.split(";")[0].trim();
  return new NamedNode("http://www.w3.org/ns/iana/media-types/" + mediaType + "#Resource");
}
function linkRelationProperty(relation) {
  return new NamedNode("http://www.w3.org/ns/iana/link-relations/relation#" + relation.trim());
}
function callbackify(obj, callbacks) {
  obj.callbacks = {};
  for (var x = callbacks.length - 1; x >= 0; x--) {
    obj.callbacks[callbacks[x]] = [];
  }
  obj.addHook = function(hook) {
    if (!obj.callbacks[hook]) {
      obj.callbacks[hook] = [];
    }
  };
  obj.addCallback = function(hook, func) {
    obj.callbacks[hook].push(func);
  };
  obj.removeCallback = function(hook, funcName) {
    for (var i = 0; i < obj.callbacks[hook].length; i++) {
      if (obj.callbacks[hook][i].name === funcName) {
        obj.callbacks[hook].splice(i, 1);
        return true;
      }
    }
    return false;
  };
  obj.insertCallback = function(hook, func) {
    obj.callbacks[hook].unshift(func);
  };
  obj.fireCallbacks = function fireCallbacks(hook, args) {
    var newCallbacks = [];
    var replaceCallbacks = [];
    var len = obj.callbacks[hook].length;
    var x2;
    let callback;
    for (x2 = len - 1; x2 >= 0; x2--) {
      callback = obj.callbacks[hook][x2];
      if (callback && callback.apply(obj, args)) {
        newCallbacks.push(callback);
      }
    }
    for (x2 = newCallbacks.length - 1; x2 >= 0; x2--) {
      replaceCallbacks.push(newCallbacks[x2]);
    }
    for (x2 = len; x2 < obj.callbacks[hook].length; x2++) {
      replaceCallbacks.push(obj.callbacks[hook][x2]);
    }
    obj.callbacks[hook] = replaceCallbacks;
  };
}
function DOMParserFactory() {
  if (window.DOMParser) {
    return new import_xmldom.DOMParser();
  } else if (window.ActiveXObject) {
    return new ActiveXObject("Microsoft.XMLDOM");
  } else {
    return false;
  }
}
function domToString(node, options) {
  options = options || {};
  var selfClosing = [];
  if (options && options.selfClosing) {
    options.selfClosing.split(" ").forEach(function(n) {
      selfClosing[n] = true;
    });
  }
  var skipAttributes = [];
  if (options && options.skipAttributes) {
    options.skipAttributes.split(" ").forEach(function(n) {
      skipAttributes[n] = true;
    });
  }
  return dumpNode(node, options, selfClosing, skipAttributes);
}
function dumpNode(node, options, selfClosing, skipAttributes) {
  var i;
  var out = "";
  var noEsc = [false];
  if (typeof node.nodeType === "undefined") return out;
  if (node.nodeType === 1) {
    if (node.hasAttribute("class") && options && options.classWithChildText && node.matches(options.classWithChildText.class)) {
      out += node.querySelector(options.classWithChildText.element).textContent;
    } else if (!(options && options.skipNodeWithClass && node.matches("." + options.skipNodeWithClass))) {
      var ename = node.nodeName.toLowerCase();
      out += "<" + ename;
      var attrList = [];
      for (i = node.attributes.length - 1; i >= 0; i--) {
        var atn = node.attributes[i];
        if (skipAttributes && skipAttributes.length > 0 && skipAttributes[atn.name]) continue;
        if (/^\d+$/.test(atn.name)) continue;
        if (atn.name === "class" && options && options.replaceClassItemWith && atn.value.split(" ").indexOf(options.replaceClassItemWith.source) > -1) {
          var re = new RegExp(options.replaceClassItemWith.source, "g");
          atn.value = atn.value.replace(re, options.replaceClassItemWith.target).trim();
        }
        if (!(atn.name === "class" && options && options.skipClassWithValue && options.skipClassWithValue === atn.value)) {
          attrList.push(atn.name + "='" + atn.value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&quot;") + "'");
        }
      }
      if (attrList.length > 0) {
        if (options && options.sortAttributes) {
          attrList.sort(function(a, b) {
            return a.toLowerCase().localeCompare(b.toLowerCase());
          });
        }
        out += " " + attrList.join(" ");
      }
      if (selfClosing && selfClosing.ename) {
        out += " />";
      } else {
        out += ">";
        out += ename === "html" ? "\n  " : "";
        noEsc.push(ename === "style" || ename === "script");
        for (i = 0; i < node.childNodes.length; i++) out += dumpNode(node.childNodes[i]);
        noEsc.pop();
        out += ename === "body" ? "</" + ename + ">\n" : "</" + ename + ">";
      }
    }
  } else if (node.nodeType === 8) {
    out += "<!--" + node.nodeValue + "-->";
  } else if (node.nodeType === 3 || node.nodeType === 4) {
    var nl = node.nodeValue.replace(/\n+$/, "");
    out += noEsc[noEsc.length - 1] ? nl : nl.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  } else {
    console.log("Warning; Cannot handle serialising nodes of type: " + node.nodeType);
    console.log(node);
  }
  return out;
}
function dtstamp() {
  var now = /* @__PURE__ */ new Date();
  var year = now.getYear() + 1900;
  var month = now.getMonth() + 1;
  var day = now.getDate();
  var hour = now.getUTCHours();
  var minute = now.getUTCMinutes();
  var second = now.getSeconds();
  if (month < 10) month = "0" + month;
  if (day < 10) day = "0" + day;
  if (hour < 10) hour = "0" + hour;
  if (minute < 10) minute = "0" + minute;
  if (second < 10) second = "0" + second;
  return year + "-" + month + "-" + day + "T" + hour + ":" + minute + ":" + second + "Z";
}
function heavyCompare(x, y, g, uriMap) {
  var nonBlank = function(x2) {
    return x2.termType === "BlankNode" ? null : x2;
  };
  var signature = function(x2) {
    var lis = g.statementsMatching(x2).map(function(st2) {
      return "" + nonBlank(st2.subject) + " " + nonBlank(st2.predicate) + " " + nonBlank(st2.object);
    }).concat(g.statementsMatching(void 0, void 0, x2).map(function(st2) {
      return "" + nonBlank(st2.subject) + " " + nonBlank(st2.predicate) + " " + nonBlank(st2.object);
    }));
    lis.sort();
    return lis.join("\n");
  };
  const comparison = Object.prototype.hasOwnProperty.call(g, "compareTerms") ? g.compareTerms(x, y) : x.compareTerm(y);
  if (x.termType === "BlankNode" && y.termType === "BlankNode") {
    if (comparison === 0) return 0;
    if (signature(x) > signature(y)) return 1;
    if (signature(x) < signature(y)) return -1;
    return comparison;
  } else {
    if (uriMap && x.uri && y.uri) {
      return (uriMap[x.uri] || x.uri).localeCompare(uriMap[y.uri] || y.uri);
    }
    return comparison;
  }
}
function heavyCompareSPO(x, y, g, uriMap) {
  return heavyCompare(x.subject, y.subject, g, uriMap) || heavyCompare(x.predicate, y.predicate, g, uriMap) || heavyCompare(x.object, y.object, g, uriMap);
}
function output(o) {
  var k = document.createElement("div");
  k.textContent = o;
  document.body.appendChild(k);
}
function parseXML(str, options) {
  var dparser;
  options = options || {};
  if (typeof module !== "undefined" && module && module.exports) {
    var dom = new import_xmldom.DOMParser().parseFromString(str, options.contentType || "application/xhtml+xml");
    return dom;
  } else {
    if (typeof window !== "undefined" && window.DOMParser) {
      dparser = new window.DOMParser();
    } else {
      dparser = new import_xmldom.DOMParser();
    }
  }
  return dparser.parseFromString(str, "application/xml");
}
function RDFArrayRemove(a, x) {
  for (var i = 0; i < a.length; i++) {
    if (a[i].subject.equals(x.subject) && a[i].predicate.equals(x.predicate) && a[i].object.equals(x.object) && a[i].why.equals(x.why)) {
      a.splice(i, 1);
      return;
    }
  }
  throw new Error("RDFArrayRemove: Array did not contain " + x + " " + x.why);
}
function string_startswith(str, pref) {
  return str.slice(0, pref.length) === pref;
}
function stringTemplate(base, subs) {
  var baseA = base.split("%s");
  var result = "";
  for (var i = 0; i < subs.length; i++) {
    subs[i] += "";
    result += baseA[i] + subs[i];
  }
  return result + baseA.slice(subs.length).join();
}
function stackString(e) {
  var str = "" + e + "\n";
  if (!e.stack) {
    return str + "No stack available.\n";
  }
  var lines = e.stack.toString().split("\n");
  var toprint = [];
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i];
    if (line.indexOf("ecmaunit.js") > -1) {
      break;
    }
    if (line.charAt(0) == "(") {
      line = "function" + line;
    }
    var chunks = line.split("@");
    toprint.push(chunks);
  }
  for (var i = 0; i < toprint.length; i++) {
    str += "  " + toprint[i][1] + "\n    " + toprint[i][0];
  }
  return str;
}

// node_modules/rdflib/esm/xsd.js
function createXSD(localFactory = canonical_data_factory_default) {
  return {
    boolean: localFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean"),
    dateTime: localFactory.namedNode("http://www.w3.org/2001/XMLSchema#dateTime"),
    decimal: localFactory.namedNode("http://www.w3.org/2001/XMLSchema#decimal"),
    double: localFactory.namedNode("http://www.w3.org/2001/XMLSchema#double"),
    integer: localFactory.namedNode("http://www.w3.org/2001/XMLSchema#integer"),
    langString: localFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"),
    string: localFactory.namedNode("http://www.w3.org/2001/XMLSchema#string")
  };
}
var defaultXSD = createXSD(canonical_data_factory_default);

// node_modules/rdflib/esm/serializer.js
function createSerializer(store) {
  return new Serializer(store);
}
var Serializer = class _Serializer {
  constructor(store) {
    _defineProperty(this, "_notQNameChars", "	\r\n !\"#$%&'()*,+/;<=>?@[\\]^`{|}~");
    _defineProperty(this, "_notNameChars", this._notQNameChars + ":");
    _defineProperty(this, "validPrefix", new RegExp(/^[a-zA-Z][a-zA-Z0-9]*$/));
    _defineProperty(this, "forbidden1", new RegExp(/[\\"\b\f\r\v\t\n\u0080-\uffff]/gm));
    _defineProperty(this, "forbidden3", new RegExp(/[\\"\b\f\r\v\u0080-\uffff]/gm));
    this.flags = "";
    this.base = null;
    this.prefixes = [];
    this.namespaces = [];
    const nsKeys = Object.keys((0, import_solid_namespace.default)());
    for (const i in nsKeys) {
      const uri = (0, import_solid_namespace.default)()[nsKeys[i]]("");
      const prefix = nsKeys[i];
      this.prefixes[uri] = prefix;
      this.namespaces[prefix] = uri;
    }
    this.suggestPrefix("rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
    this.suggestPrefix("xml", "reserved:reservedForFutureUse");
    this.namespacesUsed = [];
    this.keywords = ["a"];
    this.prefixchars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    this.incoming = null;
    this.formulas = [];
    this.store = store;
    this.rdfFactory = store.rdfFactory || canonical_data_factory_default;
    this.xsd = createXSD(this.rdfFactory);
  }
  setBase(base) {
    this.base = base;
    return this;
  }
  /**
   * Set serializer behavior flags. Letters can be combined with spaces.
   * Examples: 'si', 'deinprstux', 'si dr', 'o'.
   * Notable flags:
   *  - 'o': do not abbreviate to a prefixed name when the local part contains a dot
   */
  setFlags(flags) {
    this.flags = flags || "";
    return this;
  }
  toStr(x) {
    var s = x.toNT();
    if (x.termType === "Graph") {
      this.formulas[s] = x;
    }
    return s;
  }
  fromStr(s) {
    if (s[0] === "{") {
      var x = this.formulas[s];
      if (!x) console.log("No formula object for " + s);
      return x;
    }
    return this.store.fromNT(s);
  }
  /**
   * Defines a set of [prefix, namespace] pairs to be used by this Serializer instance.
   * Overrides previous prefixes if any
   * @param namespaces
   * @return {Serializer}
   */
  setNamespaces(namespaces) {
    for (var px in namespaces) {
      this.setPrefix(px, namespaces[px]);
    }
    return this;
  }
  /**
   * Defines a namespace prefix, overriding any existing prefix for that URI
   * @param prefix
   * @param uri
   */
  setPrefix(prefix, uri) {
    if (prefix.slice(0, 7) === "default") return;
    if (prefix.slice(0, 2) === "ns") return;
    if (!prefix || !uri) return;
    for (let existingNs in this.prefixes) {
      if (this.prefixes[existingNs] == prefix) delete this.prefixes[existingNs];
    }
    this.prefixes[uri] = prefix;
    this.namespaces[prefix] = uri;
  }
  /* Accumulate Namespaces
  **
  ** These are only hints.  If two overlap, only one gets used
  ** There is therefore no guarantee in general.
  */
  suggestPrefix(prefix, uri) {
    if (prefix.slice(0, 7) === "default") return;
    if (prefix.slice(0, 2) === "ns") return;
    if (!prefix || !uri) return;
    if (prefix in this.namespaces || uri in this.prefixes) return;
    this.prefixes[uri] = prefix;
    this.namespaces[prefix] = uri;
  }
  // Takes a namespace -> prefix map
  suggestNamespaces(namespaces) {
    for (var px in namespaces) {
      this.suggestPrefix(px, namespaces[px]);
    }
    return this;
  }
  checkIntegrity() {
    var p, ns3;
    for (p in this.namespaces) {
      if (this.prefixes[this.namespaces[p]] !== p) {
        throw new Error("Serializer integity error 1: " + p + ", " + this.namespaces[p] + ", " + this.prefixes[this.namespaces[p]] + "!");
      }
    }
    for (ns3 in this.prefixes) {
      if (this.namespaces[this.prefixes[ns3]] !== ns3) {
        throw new Error("Serializer integity error 2: " + ns3 + ", " + this.prefixs[ns3] + ", " + this.namespaces[this.prefixes[ns3]] + "!");
      }
    }
  }
  // Make up an unused prefix for a random namespace
  makeUpPrefix(uri) {
    var p = uri;
    function canUseMethod(pp) {
      if (!this.validPrefix.test(pp)) return false;
      if (pp === "ns") return false;
      if (pp in this.namespaces) return false;
      this.prefixes[uri] = pp;
      this.namespaces[pp] = uri;
      return pp;
    }
    var canUse = canUseMethod.bind(this);
    if ("#/".indexOf(p[p.length - 1]) >= 0) p = p.slice(0, -1);
    var slash = p.lastIndexOf("/");
    if (slash >= 0) p = p.slice(slash + 1);
    var i = 0;
    while (i < p.length) {
      if (this.prefixchars.indexOf(p[i]) >= 0) {
        i++;
      } else {
        break;
      }
    }
    p = p.slice(0, i);
    if (p.length < 6 && canUse(p)) return p;
    if (canUse(p.slice(0, 3))) return p.slice(0, 3);
    if (canUse(p.slice(0, 2))) return p.slice(0, 2);
    if (canUse(p.slice(0, 4))) return p.slice(0, 4);
    if (canUse(p.slice(0, 1))) return p.slice(0, 1);
    if (canUse(p.slice(0, 5))) return p.slice(0, 5);
    if (!this.validPrefix.test(p)) {
      p = "n";
    }
    for (var j = 0; ; j++) if (canUse(p.slice(0, 3) + j)) return p.slice(0, 3) + j;
  }
  rootSubjects(sts) {
    var incoming = {};
    var subjects = {};
    var allBnodes = {};
    for (var i = 0; i < sts.length; i++) {
      var st2 = sts[i];
      var checkMentions = function(x) {
        if (!incoming.hasOwnProperty(x)) incoming[x] = [];
        incoming[x].push(st2.subject);
      };
      var st22 = [st2.subject, st2.predicate, st2.object];
      st22.map(function(y2) {
        if (y2.termType === "BlankNode") {
          allBnodes[y2.toNT()] = true;
        } else if (y2.termType === "Collection") {
          y2.elements.forEach(function(z) {
            checkMentions(z);
          });
        }
      });
      checkMentions(sts[i].object);
      var ss = subjects[this.toStr(st2.subject)];
      if (!ss) ss = [];
      ss.push(st2);
      subjects[this.toStr(st2.subject)] = ss;
    }
    var roots = [];
    for (var xNT in subjects) {
      if (!subjects.hasOwnProperty(xNT)) continue;
      var y = this.fromStr(xNT);
      if (y.termType !== "BlankNode" || !incoming[y] || incoming[y].length !== 1) {
        roots.push(y);
        continue;
      }
    }
    this.incoming = incoming;
    var rootsHash = {};
    for (var k = 0; k < roots.length; k++) {
      rootsHash[roots[k].toNT()] = true;
    }
    return {
      "roots": roots,
      "subjects": subjects,
      "rootsHash": rootsHash,
      "incoming": incoming
    };
  }
  // //////////////////////////////////////////////////////
  toN3(f) {
    return this.statementsToN3(f.statements);
  }
  // Validate if a string is a valid PN_LOCAL per Turtle 1.1 spec
  // Allows dots inside the local name but not as trailing character
  // Also allows empty local names (for URIs ending in / or #)
  isValidPNLocal(local) {
    if (local.length === 0) return true;
    if (local[local.length - 1] === ".") return false;
    for (var i = 0; i < local.length; i++) {
      var ch = local[i];
      if (ch === ".") continue;
      if (this._notNameChars.indexOf(ch) >= 0) {
        return false;
      }
    }
    return true;
  }
  explicitURI(uri) {
    if (this.flags.indexOf("r") < 0 && this.base) {
      uri = refTo(this.base, uri);
    } else if (this.flags.indexOf("u") >= 0) {
      uri = backslashUify(uri);
    } else {
      uri = hexify(decodeURI(uri));
    }
    return "<" + uri + ">";
  }
  statementsToNTriples(sts) {
    var sorted = sts.slice();
    sorted.sort();
    var str = "";
    var rdfns = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
    var self2 = this;
    var kb = this.store;
    var factory = this.rdfFactory;
    var termToNT = function(x) {
      if (x.termType !== "Collection") {
        return self2.atomicTermToN3(x);
      }
      var list = x.elements;
      var rest = kb.sym(rdfns + "nill");
      for (var i2 = list.length - 1; i2 >= 0; i2--) {
        var bnode = factory.blankNode();
        str += termToNT(bnode) + " " + termToNT(kb.sym(rdfns + "first")) + " " + termToNT(list[i2]) + ".\n";
        str += termToNT(bnode) + " " + termToNT(kb.sym(rdfns + "rest")) + " " + termToNT(rest) + ".\n";
        rest = bnode;
      }
      return self2.atomicTermToN3(rest);
    };
    for (var i = 0; i < sorted.length; i++) {
      var st2 = sorted[i];
      var s = "";
      s += termToNT(st2.subject) + " ";
      s += termToNT(st2.predicate) + " ";
      s += termToNT(st2.object) + " ";
      if (this.flags.indexOf("q") >= 0) {
        s += termToNT(st2.why) + " ";
      }
      s += ".\n";
      str += s;
    }
    return str;
  }
  statementsToN3(sts) {
    var indent = 4;
    var width = 80;
    var kb = this.store;
    var uriMap = {
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#type": "aaa:00"
    };
    var SPO = function(x, y) {
      return heavyCompareSPO(x, y, kb, uriMap);
    };
    sts.sort(SPO);
    if (this.base && !this.defaultNamespace) {
      this.defaultNamespace = this.base + "#";
    }
    var predMap = {};
    if (this.flags.indexOf("s") < 0) {
      predMap["http://www.w3.org/2002/07/owl#sameAs"] = "=";
    }
    if (this.flags.indexOf("t") < 0) {
      predMap["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"] = "a";
    }
    if (this.flags.indexOf("i") < 0) {
      predMap["http://www.w3.org/2000/10/swap/log#implies"] = "=>";
    }
    var spaces = function(n) {
      var s = "";
      for (var i = 0; i < n; i++) s += " ";
      return s;
    };
    var treeToLine = function(tree2) {
      var str = "";
      for (var i = 0; i < tree2.length; i++) {
        var branch = tree2[i];
        var s2 = typeof branch === "string" ? branch : treeToLine(branch);
        if (i !== 0) {
          var ch = str.slice(-1) || " ";
          if (s2 === "," || s2 === ";") {
          } else if (s2 === "." && !"0123456789.:".includes(ch)) {
          } else {
            str += " ";
          }
        }
        str += s2;
      }
      return str;
    };
    var treeToString = function(tree2, level) {
      var str = "";
      var lastLength = 1e5;
      if (level === void 0) level = -1;
      for (var i = 0; i < tree2.length; i++) {
        var branch = tree2[i];
        if (typeof branch !== "string") {
          var substr = treeToString(branch, level + 1);
          if (substr.length < 10 * (width - indent * level) && substr.indexOf('"""') < 0) {
            var line = treeToLine(branch);
            if (line.length < width - indent * level) {
              branch = line;
              substr = "";
            }
          }
          if (substr) lastLength = 1e4;
          str += substr;
        }
        if (typeof branch === "string") {
          if (branch.length === 1 && str.slice(-1) === "\n") {
            if (",.;".indexOf(branch) >= 0) {
              str = str.slice(0, -1);
              if (branch == "." && "0123456789.:".includes(str.charAt(str.length - 1))) {
                str += " ";
                lastLength += 1;
              }
              str += branch + "\n";
              lastLength += 1;
              continue;
            }
          }
          if (lastLength < indent * level + 4 || // if new line not necessary
          lastLength + branch.length + 1 < width && ";.".indexOf(str[str.length - 2]) < 0) {
            str = str.slice(0, -1) + " " + branch + "\n";
            lastLength += branch.length + 1;
          } else {
            let line2 = spaces(indent * level) + branch;
            str += line2 + "\n";
            lastLength = line2.length;
            if (level < 0) {
              str += "\n";
              lastLength = 1e5;
            }
          }
        }
      }
      return str;
    };
    function statementListToTreeMethod(statements) {
      var stats = this.rootSubjects(statements);
      var roots = stats.roots;
      var results = [];
      for (var i = 0; i < roots.length; i++) {
        var root = roots[i];
        results.push(subjectTree(root, stats));
      }
      return results;
    }
    var statementListToTree = statementListToTreeMethod.bind(this);
    function subjectTree(subject, stats) {
      if (subject.termType === "BlankNode" && !stats.incoming[subject]) {
        return objectTree(subject, stats, true).concat(["."]);
      }
      return [termToN3(subject, stats)].concat([propertyTree(subject, stats)]).concat(["."]);
    }
    function propertyTreeMethod(subject, stats) {
      var results = [];
      var lastPred = null;
      var sts2 = stats.subjects[this.toStr(subject)] || [];
      if (typeof sts2 === "undefined") {
        throw new Error("Cant find statements for " + subject);
      }
      var objects = [];
      for (var i = 0; i < sts2.length; i++) {
        var st2 = sts2[i];
        if (st2.predicate.uri === lastPred) {
          objects.push(",");
        } else {
          if (lastPred) {
            results = results.concat([objects]).concat([";"]);
            objects = [];
          }
          results.push(predMap[st2.predicate.uri] ? predMap[st2.predicate.uri] : termToN3(st2.predicate, stats));
        }
        lastPred = st2.predicate.uri;
        objects.push(objectTree(st2.object, stats));
      }
      results = results.concat([objects]);
      return results;
    }
    var propertyTree = propertyTreeMethod.bind(this);
    function objectTreeMethod(obj, stats, force) {
      if (obj.termType === "BlankNode" && (force || stats.rootsHash[obj.toNT()] === void 0)) {
        if (stats.subjects[this.toStr(obj)]) {
          return ["[", propertyTree(obj, stats), "]"];
        } else {
          return "[]";
        }
      }
      return termToN3(obj, stats);
    }
    var objectTree = objectTreeMethod.bind(this);
    function termToN3Method(expr, stats) {
      var i, res;
      switch (expr.termType) {
        case "Graph":
          res = ["{"];
          res = res.concat(statementListToTree(expr.statements));
          return res.concat(["}"]);
        case "Collection":
          res = ["("];
          for (i = 0; i < expr.elements.length; i++) {
            res.push([objectTree(expr.elements[i], stats)]);
          }
          res.push(")");
          return res;
        default:
          return this.atomicTermToN3(expr);
      }
    }
    _Serializer.prototype.termToN3 = termToN3;
    var termToN3 = termToN3Method.bind(this);
    function prefixDirectivesMethod() {
      var str = "";
      if (this.flags.indexOf("d") < 0 && this.defaultNamespace) {
        str += "@prefix : " + this.explicitURI(this.defaultNamespace) + ".\n";
      }
      for (var ns3 in this.prefixes) {
        if (!this.prefixes.hasOwnProperty(ns3)) continue;
        if (!this.namespacesUsed[ns3]) continue;
        str += "@prefix " + this.prefixes[ns3] + ": " + this.explicitURI(ns3) + ".\n";
      }
      return str + "\n";
    }
    var prefixDirectives = prefixDirectivesMethod.bind(this);
    var tree = statementListToTree(sts);
    return prefixDirectives() + treeToString(tree);
  }
  // //////////////////////////////////////////// Atomic Terms
  //  Deal with term level things and nesting with no bnode structure
  atomicTermToN3(expr, stats) {
    switch (expr.termType) {
      case "BlankNode":
      case "Variable":
        return expr.toNT();
      case "Literal":
        var val = expr.value;
        if (typeof val !== "string") {
          throw new TypeError("Value of RDF literal node must be a string");
        }
        if (expr.datatype && this.flags.indexOf("x") < 0) {
          switch (expr.datatype.uri) {
            case "http://www.w3.org/2001/XMLSchema#integer":
              return val;
            case "http://www.w3.org/2001/XMLSchema#decimal":
              if (val.indexOf(".") < 0) val += ".0";
              return val;
            case "http://www.w3.org/2001/XMLSchema#double": {
              const eNotation = val.toLowerCase().indexOf("e") > 0;
              if (val.indexOf(".") < 0 && !eNotation) val += ".0";
              if (!eNotation) val += "e0";
              return val;
            }
            case "http://www.w3.org/2001/XMLSchema#boolean":
              return expr.value === "1" ? "true" : "false";
          }
        }
        var str = this.stringToN3(expr.value, this.flags);
        if (expr.language) {
          str += "@" + expr.language;
        } else if (!expr.datatype.equals(this.xsd.string)) {
          str += "^^" + this.atomicTermToN3(expr.datatype, stats);
        }
        return str;
      case "NamedNode":
        return this.symbolToN3(expr);
      case "DefaultGraph":
        return "";
      default:
        throw new Error("Internal: atomicTermToN3 cannot handle " + expr + " of termType: " + expr.termType);
    }
  }
  stringToN3(str, flags) {
    if (!flags) flags = "e";
    var res = "";
    var i, j, k;
    var delim;
    var forbidden;
    if (str.length > 20 && // Long enough to make sense
    str.slice(-1) !== '"' && // corner case'
    flags.indexOf("n") < 0 && // Force single line
    (str.indexOf("\n") > 0 || str.indexOf('"') > 0)) {
      delim = '"""';
      forbidden = this.forbidden3;
    } else {
      delim = '"';
      forbidden = this.forbidden1;
    }
    for (i = 0; i < str.length; ) {
      forbidden.lastIndex = 0;
      var m = forbidden.exec(str.slice(i));
      if (m == null) break;
      j = i + forbidden.lastIndex - 1;
      res += str.slice(i, j);
      var ch = str[j];
      if (ch === '"' && delim === '"""' && str.slice(j, j + 3) !== '"""') {
        res += ch;
      } else {
        k = '\b\f\r	\v\n\\"'.indexOf(ch);
        if (k >= 0) {
          res += "\\" + 'bfrtvn\\"'[k];
        } else {
          if (flags.indexOf("e") >= 0) {
            res += "\\u" + ("000" + ch.charCodeAt(0).toString(16).toLowerCase()).slice(-4);
          } else {
            res += ch;
          }
        }
      }
      i = j + 1;
    }
    return delim + res + str.slice(i) + delim;
  }
  //  A single symbol, either in  <> or namespace notation
  symbolToN3(x) {
    var uri = x.uri;
    var j = uri.indexOf("#");
    if (j < 0 && this.flags.indexOf("/") < 0) {
      j = uri.lastIndexOf("/");
    }
    if (j >= 0 && this.flags.indexOf("p") < 0 && // Can split at namespace but only if http[s]: URI or file: or ws[s] (why not others?)
    (uri.indexOf("http") === 0 || uri.indexOf("ws") === 0 || uri.indexOf("file") === 0)) {
      var localid = uri.slice(j + 1);
      var namesp = uri.slice(0, j + 1);
      var minNamespaceLength = uri.indexOf("://") + 4;
      var baseDir = this.base ? this.base.slice(0, Math.max(this.base.lastIndexOf("/"), this.base.lastIndexOf("#")) + 1) : null;
      var namespaceIsBaseDir = baseDir && namesp === baseDir;
      var forbidDotLocal = this.flags.indexOf("o") >= 0 && localid.indexOf(".") >= 0;
      var canSplit = !namespaceIsBaseDir && !forbidDotLocal && namesp.length > minNamespaceLength && this.isValidPNLocal(localid);
      if (canSplit) {
        if (this.defaultNamespace && this.defaultNamespace === namesp && this.flags.indexOf("d") < 0) {
          if (this.flags.indexOf("k") >= 0 && this.keyords.indexOf(localid) < 0) {
            return localid;
          }
          return ":" + localid;
        }
        var prefix = this.prefixes[namesp];
        if (!prefix) prefix = this.makeUpPrefix(namesp);
        if (prefix) {
          this.namespacesUsed[namesp] = true;
          return prefix + ":" + localid;
        }
      }
    }
    return this.explicitURI(uri);
  }
  // /////////////////////////// Quad store serialization
  // @para. write  - a function taking a single string to be output
  //
  writeStore(write) {
    var kb = this.store;
    var fetcher2 = kb.fetcher;
    var session = fetcher2 && fetcher2.appNode;
    var sources = this.store.index[3];
    for (var s in sources) {
      var source = kb.fromNT(s);
      if (session && source.equals(session)) continue;
      write("\n" + this.atomicTermToN3(source) + " " + this.atomicTermToN3(kb.sym("http://www.w3.org/2000/10/swap/log#semantics")) + " { " + this.statementsToN3(kb.statementsMatching(void 0, void 0, void 0, source)) + " }.\n");
    }
    kb.statementsMatching(void 0, kb.sym("http://www.w3.org/2007/ont/link#requestedURI")).map(function(st2) {
      write("\n<" + st2.object.value + "> log:metadata {\n");
      var sts = kb.statementsMatching(void 0, void 0, void 0, st2.subject);
      write(this.statementsToN3(this.statementsToN3(sts)));
      write("}.\n");
    });
    var metaSources = [];
    if (session) metaSources.push(session);
    var metadata = [];
    metaSources.map(function(source2) {
      metadata = metadata.concat(kb.statementsMatching(void 0, void 0, void 0, source2));
    });
    write(this.statementsToN3(metadata));
  }
  // ////////////////////////////////////////////// XML serialization
  statementsToXML(sts) {
    var indent = 4;
    var width = 80;
    var namespaceCounts = [];
    namespaceCounts["http://www.w3.org/1999/02/22-rdf-syntax-ns#"] = true;
    var liPrefix = "http://www.w3.org/1999/02/22-rdf-syntax-ns#_";
    var spaces = function(n) {
      var s = "";
      for (var i = 0; i < n; i++) s += " ";
      return s;
    };
    var XMLtreeToLine = function(tree3) {
      var str2 = "";
      for (var i = 0; i < tree3.length; i++) {
        var branch = tree3[i];
        var s2 = typeof branch === "string" ? branch : XMLtreeToLine(branch);
        str2 += s2;
      }
      return str2;
    };
    var XMLtreeToString = function(tree3, level) {
      var str2 = "";
      var line;
      var lastLength = 1e5;
      if (!level) level = 0;
      for (var i = 0; i < tree3.length; i++) {
        var branch = tree3[i];
        if (typeof branch !== "string") {
          var substr = XMLtreeToString(branch, level + 1);
          if (substr.length < 10 * (width - indent * level) && substr.indexOf('"""') < 0) {
            line = XMLtreeToLine(branch);
            if (line.length < width - indent * level) {
              branch = "   " + line;
              substr = "";
            }
          }
          if (substr) lastLength = 1e4;
          str2 += substr;
        }
        if (typeof branch === "string") {
          if (lastLength < indent * level + 4) {
            str2 = str2.slice(0, -1) + " " + branch + "\n";
            lastLength += branch.length + 1;
          } else {
            line = spaces(indent * level) + branch;
            str2 += line + "\n";
            lastLength = line.length;
          }
        } else {
        }
      }
      return str2;
    };
    function statementListToXMLTreeMethod(statements) {
      this.suggestPrefix("rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
      var stats = this.rootSubjects(statements);
      var roots = stats.roots;
      var results = [];
      for (var i = 0; i < roots.length; i++) {
        var root = roots[i];
        results.push(subjectXMLTree(root, stats));
      }
      return results;
    }
    var statementListToXMLTree = statementListToXMLTreeMethod.bind(this);
    function escapeForXML(str2) {
      if (typeof str2 === "undefined") return "@@@undefined@@@@";
      return str2.replace(/[&<"]/g, function(m) {
        switch (m[0]) {
          case "&":
            return "&amp;";
          case "<":
            return "&lt;";
          case '"':
            return "&quot;";
        }
      });
    }
    function relURIMethod(term2) {
      return escapeForXML(this.base ? uri_exports.refTo(this.base, term2.uri) : term2.uri);
    }
    var relURI = relURIMethod.bind(this);
    function subjectXMLTreeMethod(subject, stats) {
      var results = [];
      var type, t, st2, pred;
      var sts2 = stats.subjects[this.toStr(subject)];
      if (typeof sts2 === "undefined") {
        return propertyXMLTree(subject, stats);
      }
      sts2.sort(function(a, b) {
        var ap = a.predicate.uri;
        var bp = b.predicate.uri;
        if (ap.substring(0, liPrefix.length) === liPrefix || bp.substring(0, liPrefix.length) === liPrefix) {
          return ap.localeCompare(bp);
        }
        var as = ap.substring(liPrefix.length);
        var bs = bp.substring(liPrefix.length);
        var an = parseInt(as, 10);
        var bn = parseInt(bs, 10);
        if (isNaN(an) || isNaN(bn) || an !== as || bn !== bs) {
          return ap.localeCompare(bp);
        }
        return an - bn;
      });
      for (var i = 0; i < sts2.length; i++) {
        st2 = sts2[i];
        if (st2.predicate.uri === "http://www.w3.org/1999/02/22-rdf-syntax-ns#type" && !type && st2.object.termType === "NamedNode") {
          type = st2.object;
          continue;
        }
        pred = st2.predicate;
        if (pred.uri.substr(0, liPrefix.length) === liPrefix) {
          var number = pred.uri.substr(liPrefix.length);
          var intNumber = parseInt(number, 10);
          if (number === intNumber.toString()) {
            pred = this.rdfFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#li");
          }
        }
        t = qname(pred);
        switch (st2.object.termType) {
          case "BlankNode":
            if (stats.incoming[st2.object].length === 1) {
              results = results.concat(["<" + t + ' rdf:parseType="Resource">', subjectXMLTree(st2.object, stats), "</" + t + ">"]);
            } else {
              results = results.concat(["<" + t + ' rdf:nodeID="' + st2.object.toNT().slice(2) + '"/>']);
            }
            break;
          case "NamedNode":
            results = results.concat(["<" + t + ' rdf:resource="' + relURI(st2.object) + '"/>']);
            break;
          case "Literal":
            results = results.concat(["<" + t + (st2.object.language ? ' xml:lang="' + st2.object.language + '"' : st2.object.datatype.equals(this.xsd.string) ? "" : ' rdf:datatype="' + escapeForXML(st2.object.datatype.uri) + '"') + ">" + escapeForXML(st2.object.value) + "</" + t + ">"]);
            break;
          case "Collection":
            results = results.concat(["<" + t + ' rdf:parseType="Collection">', collectionXMLTree(st2.object, stats), "</" + t + ">"]);
            break;
          default:
            throw new Error("Can't serialize object of type " + st2.object.termType + " into XML");
        }
      }
      var tag = type ? qname(type) : "rdf:Description";
      var attrs = "";
      if (subject.termType === "BlankNode") {
        if (!stats.incoming[subject] || stats.incoming[subject].length !== 1) {
          attrs = ' rdf:nodeID="' + subject.toNT().slice(2) + '"';
        }
      } else {
        attrs = ' rdf:about="' + relURI(subject) + '"';
      }
      return ["<" + tag + attrs + ">"].concat([results]).concat(["</" + tag + ">"]);
    }
    var subjectXMLTree = subjectXMLTreeMethod.bind(this);
    function collectionXMLTree(subject, stats) {
      var res = [];
      for (var i = 0; i < subject.elements.length; i++) {
        res.push(subjectXMLTree(subject.elements[i], stats));
      }
      return res;
    }
    function propertyXMLTreeMethod(subject, stats) {
      var results = [];
      var sts2 = stats.subjects[this.toStr(subject)];
      if (!sts2) return results;
      sts2.sort();
      for (var i = 0; i < sts2.length; i++) {
        var st2 = sts2[i];
        switch (st2.object.termType) {
          case "BlankNode":
            if (stats.rootsHash[st2.object.toNT()]) {
              results = results.concat(["<" + qname(st2.predicate) + ' rdf:nodeID="' + st2.object.toNT().slice(2) + '">', "</" + qname(st2.predicate) + ">"]);
            } else {
              results = results.concat(["<" + qname(st2.predicate) + ' rdf:parseType="Resource">', propertyXMLTree(st2.object, stats), "</" + qname(st2.predicate) + ">"]);
            }
            break;
          case "NamedNode":
            results = results.concat(["<" + qname(st2.predicate) + ' rdf:resource="' + relURI(st2.object) + '"/>']);
            break;
          case "Literal":
            results = results.concat(["<" + qname(st2.predicate) + (st2.object.language ? ' xml:lang="' + st2.object.language + '"' : st2.object.datatype.equals(this.xsd.string) ? "" : ' rdf:datatype="' + escapeForXML(st2.object.datatype.value) + '"') + ">" + escapeForXML(st2.object.value) + "</" + qname(st2.predicate) + ">"]);
            break;
          case "Collection":
            results = results.concat(["<" + qname(st2.predicate) + ' rdf:parseType="Collection">', collectionXMLTree(st2.object, stats), "</" + qname(st2.predicate) + ">"]);
            break;
          default:
            throw new Error("Can't serialize object of type " + st2.object.termType + " into XML");
        }
      }
      return results;
    }
    var propertyXMLTree = propertyXMLTreeMethod.bind(this);
    function qnameMethod(term2) {
      var uri = term2.uri;
      var j = uri.indexOf("#");
      if (j < 0 && this.flags.indexOf("/") < 0) {
        j = uri.lastIndexOf("/");
      }
      if (j < 0) throw new Error("Cannot make qname out of <" + uri + ">");
      for (var k = j + 1; k < uri.length; k++) {
        if (this._notNameChars.indexOf(uri[k]) >= 0) {
          throw new Error('Invalid character "' + uri[k] + '" cannot be in XML qname for URI: ' + uri);
        }
      }
      var localid = uri.slice(j + 1);
      var namesp = uri.slice(0, j + 1);
      if (this.defaultNamespace && this.defaultNamespace === namesp && this.flags.indexOf("d") < 0) {
        return localid;
      }
      var prefix = this.prefixes[namesp];
      if (!prefix) prefix = this.makeUpPrefix(namesp);
      namespaceCounts[namesp] = true;
      return prefix + ":" + localid;
    }
    var qname = qnameMethod.bind(this);
    var tree = statementListToXMLTree(sts);
    var str = "<rdf:RDF";
    if (this.defaultNamespace) {
      str += ' xmlns="' + escapeForXML(this.defaultNamespace) + '"';
    }
    for (var ns3 in namespaceCounts) {
      if (!namespaceCounts.hasOwnProperty(ns3)) continue;
      var ns22 = this.base && this.flags.includes("z") ? uri_exports.refTo(this.base, ns3) : ns3;
      str += "\n xmlns:" + this.prefixes[ns3] + '="' + escapeForXML(ns22) + '"';
    }
    str += ">";
    var tree2 = [str, tree, "</rdf:RDF>"];
    return XMLtreeToString(tree2, -1);
  }
  // End @@ body
  statementsToJsonld(sts) {
    const turtleDoc = this.statementsToN3(sts);
    const jsonldObj = ttl2jsonld.parse(turtleDoc);
    return JSON.stringify(jsonldObj, null, 2);
  }
};
function hexify(str) {
  return encodeURI(str);
}
function backslashUify(str) {
  var res = "";
  var k;
  for (var i = 0; i < str.length; i++) {
    k = str.charCodeAt(i);
    if (k > 65535) {
      res += "\\U" + ("00000000" + k.toString(16)).slice(-8);
    } else if (k > 126) {
      res += "\\u" + ("0000" + k.toString(16)).slice(-4);
    } else {
      res += str[i];
    }
  }
  return res;
}

// node_modules/rdflib/esm/serialize.js
function serialize(target, kb, base, contentType, callback, options) {
  base = base || (target == null ? void 0 : target.value);
  const opts = options || {};
  contentType = contentType || TurtleContentType;
  var documentString = void 0;
  try {
    var sz = createSerializer(kb);
    if (opts.flags) sz.setFlags(opts.flags);
    var newSts = kb.statementsMatching(void 0, void 0, void 0, target);
    if ("namespaces" in kb) {
      sz.suggestNamespaces(kb.namespaces);
    }
    if (opts.namespaces) {
      sz.setNamespaces(opts.namespaces);
    }
    sz.setBase(base);
    switch (contentType) {
      case RDFXMLContentType:
        documentString = sz.statementsToXML(newSts);
        return executeCallback(null, documentString);
      case N3ContentType:
      case N3LegacyContentType:
        documentString = sz.statementsToN3(newSts);
        return executeCallback(null, documentString);
      case TurtleContentType:
      case TurtleLegacyContentType:
        sz.setFlags("si" + (opts.flags ? " " + opts.flags : ""));
        documentString = sz.statementsToN3(newSts);
        return executeCallback(null, documentString);
      case NTriplesContentType:
        sz.setFlags("deinprstux");
        documentString = sz.statementsToNTriples(newSts);
        return executeCallback(null, documentString);
      case JSONLDContentType:
        sz.setFlags("si dr" + (opts.flags ? " " + opts.flags : ""));
        documentString = sz.statementsToJsonld(newSts);
        return executeCallback(null, documentString);
      case NQuadsContentType:
      case NQuadsAltContentType:
        sz.setFlags("deinprstux q");
        documentString = sz.statementsToNTriples(newSts);
        return executeCallback(null, documentString);
      default:
        throw new Error("Serialize: Content-type " + contentType + " not supported for data write.");
    }
  } catch (err) {
    if (callback) {
      return callback(err, void 0);
    }
    throw err;
  }
  function executeCallback(err, result) {
    if (callback) {
      callback(err, result);
      return;
    } else {
      return result;
    }
  }
}

// node_modules/rdflib/esm/utils.js
var appliedFactoryMethods = ["blankNode", "defaultGraph", "literal", "namedNode", "quad", "variable", "supports"];
var rdf = {
  first: "http://www.w3.org/1999/02/22-rdf-syntax-ns#first",
  rest: "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest",
  nil: "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"
};
function arrayToStatements(rdfFactory, subject, data) {
  const statements = [];
  data.reduce((id, _listObj, i, listData) => {
    statements.push(rdfFactory.quad(id, rdfFactory.namedNode(rdf.first), listData[i]));
    let nextNode;
    if (i < listData.length - 1) {
      nextNode = rdfFactory.blankNode();
      statements.push(rdfFactory.quad(id, rdfFactory.namedNode(rdf.rest), nextNode));
    } else {
      statements.push(rdfFactory.quad(id, rdfFactory.namedNode(rdf.rest), rdfFactory.namedNode(rdf.nil)));
    }
    return nextNode;
  }, subject);
  return statements;
}
function ArrayIndexOf(arr, item, i = 0) {
  var length = arr.length;
  if (i < 0) i = length + i;
  for (; i < length; i++) {
    if (arr[i] === item) {
      return i;
    }
  }
  return -1;
}

// node_modules/rdflib/esm/formula.js
var Formula = class _Formula extends Node2 {
  /**
   * Initializes this formula
   * @constructor
   * @param statements - Initial array of statements
   * @param constraints - initial array of constraints
   * @param initBindings - initial bindings used in Query
   * @param optional - optional
   * @param opts
   * @param opts.rdfFactory - The rdf factory that should be used by the store
  */
  constructor(statements = [], constraints = [], initBindings = [], optional = [], opts = {}) {
    super("");
    this.statements = statements;
    this.constraints = constraints;
    this.initBindings = initBindings;
    this.optional = optional;
    _defineProperty(this, "termType", GraphTermType);
    _defineProperty(this, "classOrder", class_order_default.Graph);
    _defineProperty(this, "fetcher", void 0);
    _defineProperty(this, "isVar", 0);
    _defineProperty(this, "ns", Namespace);
    _defineProperty(this, "rdfFactory", void 0);
    this.rdfFactory = opts && opts.rdfFactory || canonical_data_factory_default;
    for (const factoryMethod of appliedFactoryMethods) {
      this[factoryMethod] = (...args) => this.rdfFactory[factoryMethod](...args);
    }
  }
  /** Add a statement from its parts
   * @param subject - the first part of the statement
   * @param predicate - the second part of the statement
   * @param object - the third part of the statement
   * @param graph - the last part of the statement
   */
  add(subject, predicate, object, graph2) {
    if (arguments.length === 1) {
      subject.forEach((st2) => this.add(st2.subject, st2.predicate, st2.object, st2.graph));
    }
    return this.statements.push(this.rdfFactory.quad(subject, predicate, object, graph2));
  }
  /** Add a statment object
   * @param {Statement} statement - An existing constructed statement to add
   */
  addStatement(statement) {
    return this.add(statement);
  }
  /**
   * Shortcut for adding blankNodes
   * @param [id]
   */
  bnode(id) {
    return this.rdfFactory.blankNode(id);
  }
  /**
   * Adds all the statements to this formula
   * @param statements - A collection of statements
   */
  addAll(statements) {
    statements.forEach((quad3) => {
      this.add(quad3.subject, quad3.predicate, quad3.object, quad3.graph);
    });
  }
  /** Follow link from one node, using one wildcard, looking for one
  *
  * For example, any(me, knows, null, profile)  - a person I know accoring to my profile .
  * any(me, knows, null, null)  - a person I know accoring to anything in store .
  * any(null, knows, me, null)  - a person who know me accoring to anything in store .
  *
  * @param s - A node to search for as subject, or if null, a wildcard
  * @param p - A node to search for as predicate, or if null, a wildcard
  * @param o - A node to search for as object, or if null, a wildcard
  * @param g - A node to search for as graph, or if null, a wildcard
  * @returns A node which match the wildcard position, or null
  */
  any(s, p, o, g) {
    const st2 = this.anyStatementMatching(s, p, o, g);
    if (st2 == null) {
      return null;
    } else if (s == null) {
      return st2.subject;
    } else if (p == null) {
      return st2.predicate;
    } else if (o == null) {
      return st2.object;
    }
    return null;
  }
  /**
   * Gets the value of a node that matches the specified pattern
   * @param s The subject
   * @param p The predicate
   * @param o The object
   * @param g The graph that contains the statement
   */
  anyValue(s, p, o, g) {
    const y = this.any(s, p, o, g);
    return y ? y.value : void 0;
  }
  /**
   * Gets the first JavaScript object equivalent to a node based on the specified pattern
   * @param s The subject
   * @param p The predicate
   * @param o The object
   * @param g The graph that contains the statement
   */
  anyJS(s, p, o, g) {
    const y = this.any(s, p, o, g);
    return y ? Node2.toJS(y) : void 0;
  }
  /**
   * Gets the first statement that matches the specified pattern
   */
  anyStatementMatching(s, p, o, g) {
    let x = this.statementsMatching(s, p, o, g, true);
    if (!x || x.length === 0) {
      return void 0;
    }
    return x[0];
  }
  /**
   * Returns a unique index-safe identifier for the given term.
   *
   * Falls back to the rdflib hashString implementation if the given factory doesn't support id.
   */
  id(term2) {
    return this.rdfFactory.id(term2);
  }
  /**
   * Search the Store
   * This is really a teaching method as to do this properly you would use IndexedFormula
   *
   * @param s - A node to search for as subject, or if null, a wildcard
   * @param p - A node to search for as predicate, or if null, a wildcard
   * @param o - A node to search for as object, or if null, a wildcard
   * @param g - A node to search for as graph, or if null, a wildcard
   * @param justOne - flag - stop when found one rather than get all of them?
   * @returns {Array<Node>} - An array of nodes which match the wildcard position
   */
  statementsMatching(s, p, o, g, justOne) {
    const sts = this.statements.filter((st2) => (!s || s.equals(st2.subject)) && (!p || p.equals(st2.predicate)) && (!o || o.equals(st2.object)) && (!g || g.equals(st2.graph)));
    if (justOne) {
      return sts.length === 0 ? [] : [sts[0]];
    }
    return sts;
  }
  /**
   * Finds the types in the list which have no *stored* subtypes
   * These are a set of classes which provide by themselves complete
   * information -- the other classes are redundant for those who
   * know the class DAG.
   * @param types A map of the types
   */
  bottomTypeURIs(types) {
    let bots;
    let bottom;
    let elt;
    let i;
    let len;
    let ref;
    let subs;
    let v;
    bots = [];
    for (let k in types) {
      if (!types.hasOwnProperty(k)) continue;
      v = types[k];
      subs = this.each(void 0, this.rdfFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#subClassOf"), this.rdfFactory.namedNode(k));
      bottom = true;
      i = 0;
      for (len = subs.length; i < len; i++) {
        elt = subs[i];
        ref = elt.uri;
        if (ref in types) {
          bottom = false;
          break;
        }
      }
      if (bottom) {
        bots[k] = v;
      }
    }
    return bots;
  }
  /** Creates a new collection */
  collection() {
    return new Collection();
  }
  /** Follow links from one node, using one wildcard.
  *
  * For example, each(me, knows, null, profile)  - people I know accoring to my profile .
  * each(me, knows, null, null)  - people I know accoring to anything in store .
  * each(null, knows, me, null)  - people who know me accoring to anything in store .
  *
  * @param s - A node to search for as subject, or if null, a wildcard
  * @param p - A node to search for as predicate, or if null, a wildcard
  * @param o - A node to search for as object, or if null, a wildcard
  * @param g - A node to search for as graph, or if null, a wildcard
  * @returns {Array<Node>} - An array of nodes which match the wildcard position
  */
  each(s, p, o, g) {
    const results = [];
    let sts = this.statementsMatching(s, p, o, g, false);
    if (s == null) {
      for (let i = 0, len = sts.length; i < len; i++) {
        results.push(sts[i].subject);
      }
    } else if (p == null) {
      for (let l = 0, len1 = sts.length; l < len1; l++) {
        results.push(sts[l].predicate);
      }
    } else if (o == null) {
      for (let m = 0, len2 = sts.length; m < len2; m++) {
        results.push(sts[m].object);
      }
    } else if (g == null) {
      for (let q = 0, len3 = sts.length; q < len3; q++) {
        results.push(new NamedNode(sts[q].graph.value));
      }
    }
    return results;
  }
  /**
   * Test whether this formula is equals to {other}
   * @param other - The other formula
   */
  equals(other) {
    if (!other) {
      return false;
    }
    return this.hashString() === other.hashString();
  }
  /**
   * For thisClass or any subclass, anything which has it is its type
   * or is the object of something which has the type as its range, or subject
   * of something which has the type as its domain
   * We don't bother doing subproperty (yet?)as it doesn't seeem to be used
   * much.
   * Get all the Classes of which we can RDFS-infer the subject is a member
   * @return a hash of URIs
   */
  findMembersNT(thisClass) {
    let len2;
    let len4;
    let m;
    let members;
    let pred;
    let ref;
    let ref1;
    let ref2;
    let ref3;
    let ref4;
    let ref5;
    let seeds;
    let st2;
    let u;
    seeds = {};
    seeds[thisClass.toNT()] = true;
    members = {};
    ref = this.transitiveClosure(seeds, this.rdfFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#subClassOf"), true);
    for (let t in ref) {
      if (!ref.hasOwnProperty(t)) continue;
      ref1 = this.statementsMatching(void 0, this.rdfFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), this.fromNT(t));
      for (let i = 0, len = ref1.length; i < len; i++) {
        st2 = ref1[i];
        members[st2.subject.toNT()] = st2;
      }
      ref2 = this.each(void 0, this.rdfFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#domain"), this.fromNT(t));
      for (let l = 0, len1 = ref2.length; l < len1; l++) {
        pred = ref2[l];
        ref3 = this.statementsMatching(void 0, pred);
        for (m = 0, len2 = ref3.length; m < len2; m++) {
          st2 = ref3[m];
          members[st2.subject.toNT()] = st2;
        }
      }
      ref4 = this.each(void 0, this.rdfFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#range"), this.fromNT(t));
      for (let q = 0, len3 = ref4.length; q < len3; q++) {
        pred = ref4[q];
        ref5 = this.statementsMatching(void 0, pred);
        for (u = 0, len4 = ref5.length; u < len4; u++) {
          st2 = ref5[u];
          members[st2.object.toNT()] = st2;
        }
      }
    }
    return members;
  }
  /**
   * For thisClass or any subclass, anything which has it is its type
   * or is the object of something which has the type as its range, or subject
   * of something which has the type as its domain
   * We don't bother doing subproperty (yet?)as it doesn't seeem to be used
   * much.
   * Get all the Classes of which we can RDFS-infer the subject is a member
   * @param subject - A named node
   */
  findMemberURIs(subject) {
    return this.NTtoURI(this.findMembersNT(subject));
  }
  /**
   * Get all the Classes of which we can RDFS-infer the subject is a superclass
   * Returns a hash table where key is NT of type and value is statement why we
   * think so.
   * Does NOT return terms, returns URI strings.
   * We use NT representations in this version because they handle blank nodes.
   */
  findSubClassesNT(subject) {
    let types = {};
    types[subject.toNT()] = true;
    return this.transitiveClosure(types, this.rdfFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#subClassOf"), true);
  }
  /**
   * Get all the Classes of which we can RDFS-infer the subject is a subclass
   * @param {RDFlibNamedNode} subject - The thing whose classes are to be found
   * @returns a hash table where key is NT of type and value is statement why we
   * think so.
   * Does NOT return terms, returns URI strings.
   * We use NT representations in this version because they handle blank nodes.
   */
  findSuperClassesNT(subject) {
    let types = {};
    types[subject.toNT()] = true;
    return this.transitiveClosure(types, this.rdfFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#subClassOf"), false);
  }
  /**
   * Get all the Classes of which we can RDFS-infer the subject is a member
   * todo: This will loop is there is a class subclass loop (Sublass loops are
   * not illegal)
   * @param {RDFlibNamedNode} subject - The thing whose classes are to be found
   * @returns a hash table where key is NT of type and value is statement why we think so.
   * Does NOT return terms, returns URI strings.
   * We use NT representations in this version because they handle blank nodes.
   */
  findTypesNT(subject) {
    let domain;
    let range;
    let rdftype;
    let ref;
    let ref1;
    let ref2;
    let ref3;
    let st2;
    let types;
    rdftype = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
    types = [];
    ref = this.statementsMatching(subject, void 0, void 0);
    for (let i = 0, len = ref.length; i < len; i++) {
      st2 = ref[i];
      if (st2.predicate.uri === rdftype) {
        types[st2.object.toNT()] = st2;
      } else {
        ref1 = this.each(st2.predicate, this.rdfFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#domain"));
        for (let l = 0, len1 = ref1.length; l < len1; l++) {
          range = ref1[l];
          types[range.toNT()] = st2;
        }
      }
    }
    ref2 = this.statementsMatching(void 0, void 0, subject);
    for (let m = 0, len2 = ref2.length; m < len2; m++) {
      st2 = ref2[m];
      ref3 = this.each(st2.predicate, this.rdfFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#range"));
      for (let q = 0, len3 = ref3.length; q < len3; q++) {
        domain = ref3[q];
        types[domain.toNT()] = st2;
      }
    }
    return this.transitiveClosure(types, this.rdfFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#subClassOf"), false);
  }
  /**
   * Get all the Classes of which we can RDFS-infer the subject is a member
   * todo: This will loop is there is a class subclass loop (Sublass loops are
   * not illegal)
   * Returns a hash table where key is NT of type and value is statement why we
   * think so.
   * Does NOT return terms, returns URI strings.
   * We use NT representations in this version because they handle blank nodes.
   * @param subject - A subject node
   */
  findTypeURIs(subject) {
    return this.NTtoURI(this.findTypesNT(subject));
  }
  /** Trace statements which connect directly, or through bnodes
   *
   * @param subject - The node to start looking for statments
   * @param doc - The document to be searched, or null to search all documents
   * @returns an array of statements, duplicate statements are suppresssed.
   */
  connectedStatements(subject, doc, excludePredicateURIs) {
    excludePredicateURIs = excludePredicateURIs || [];
    let todo = [subject];
    let done = {};
    let doneArcs = {};
    let result = [];
    let self2 = this;
    let follow = function(x) {
      let queue = function(x2) {
        if (x2.termType === "BlankNode" && !done[x2.value]) {
          done[x2.value] = true;
          todo.push(x2);
        }
      };
      let sts = self2.statementsMatching(null, null, x, doc).concat(self2.statementsMatching(x, null, null, doc));
      sts = sts.filter(function(st2) {
        if (excludePredicateURIs[st2.predicate.value]) return false;
        let hash = st2.toNT();
        if (doneArcs[hash]) return false;
        doneArcs[hash] = true;
        return true;
      });
      sts.forEach(function(st2) {
        queue(st2.subject);
        queue(st2.object);
      });
      result = result.concat(sts);
    };
    while (todo.length) {
      follow(todo.shift());
    }
    return result;
  }
  /**
   * Creates a new empty formula
   *
   * @param _features - Not applicable, but necessary for typing to pass
   */
  formula(_features) {
    return new _Formula();
  }
  /**
   * Transforms an NTriples string format into a Node.
   * The blank node bit should not be used on program-external values; designed
   * for internal work such as storing a blank node id in an HTML attribute.
   * This will only parse the strings generated by the various toNT() methods.
   */
  fromNT(str) {
    let dt, k, lang;
    switch (str[0]) {
      case "<":
        return this.sym(str.slice(1, -1));
      case '"':
        lang = void 0;
        dt = void 0;
        k = str.lastIndexOf('"');
        if (k < str.length - 1) {
          if (str[k + 1] === "@") {
            lang = str.slice(k + 2);
          } else if (str.slice(k + 1, k + 3) === "^^") {
            dt = this.fromNT(str.slice(k + 3));
          } else {
            throw new Error("Can't convert string from NT: " + str);
          }
        }
        str = str.slice(1, k);
        str = str.replace(/\\"/g, '"');
        str = str.replace(/\\n/g, "\n");
        str = str.replace(/\\\\/g, "\\");
        return this.rdfFactory.literal(str, lang || dt);
      case "_":
        return this.rdfFactory.blankNode(str.slice(2));
      case "?":
        return new Variable(str.slice(1));
    }
    throw new Error("Can't convert from NT: " + str);
  }
  /** Returns true if this formula holds the specified statement(s) */
  holds(s, p, o, g) {
    let i;
    if (arguments.length === 1) {
      if (!s) {
        return true;
      }
      if (s instanceof Array) {
        for (i = 0; i < s.length; i++) {
          if (!this.holds(s[i])) {
            return false;
          }
        }
        return true;
      } else if (isStatement(s)) {
        return this.holds(s.subject, s.predicate, s.object, s.graph);
      } else if (s.statements) {
        return this.holds(s.statements);
      }
    }
    let st2 = this.anyStatementMatching(s, p, o, g);
    return st2 != null;
  }
  /**
   * Returns true if this formula holds the specified {statement}
   */
  holdsStatement(statement) {
    return this.holds(statement.subject, statement.predicate, statement.object, statement.graph);
  }
  /**
   * Used by the n3parser to generate list elements
   * @param values - The values of the collection
   * @param context - The store
   * @return {BlankNode|Collection} - The term for the statement
   */
  list(values, context) {
    if (context.rdfFactory.supports["COLLECTIONS"]) {
      const collection = context.rdfFactory.collection();
      values.forEach(function(val) {
        collection.append(val);
      });
      return collection;
    } else {
      const node = context.rdfFactory.blankNode();
      const statements = arrayToStatements(context.rdfFactory, node, values);
      context.addAll(statements);
      return node;
    }
  }
  /**
   * Transform a collection of NTriple URIs into their URI strings
   * @param t - Some iterable collection of NTriple URI strings
   * @return A collection of the URIs as strings
   * todo: explain why it is important to go through NT
   */
  NTtoURI(t) {
    let k, v;
    let uris = {};
    for (k in t) {
      if (!t.hasOwnProperty(k)) continue;
      v = t[k];
      if (k[0] === "<") {
        uris[k.slice(1, -1)] = v;
      }
    }
    return uris;
  }
  /**
   * Serializes this formula
   * @param base - The base string
   * @param contentType - The content type of the syntax to use
   * @param provenance - The provenance URI
   * @param options  - options to pass to the serializer, as defined in serialize method
   */
  serialize(base, contentType, provenance, options) {
    return serialize(provenance, this, base, contentType, void 0, options);
  }
  /**
   * Creates a new formula with the substituting bindings applied
   * @param bindings - The bindings to substitute
   */
  substitute(bindings) {
    let statementsCopy = this.statements.map(function(ea) {
      return ea.substitute(bindings);
    });
    const y = new _Formula();
    y.addAll(statementsCopy);
    return y;
  }
  sym(uri, name) {
    if (name) {
      throw new Error("This feature (kb.sym with 2 args) is removed. Do not assume prefix mappings.");
    }
    return this.rdfFactory.namedNode(uri);
  }
  /**
   * Gets the node matching the specified pattern. Throws when no match could be made.
   * @param s - The subject
   * @param p - The predicate
   * @param o - The object
   * @param g - The graph that contains the statement
   */
  the(s, p, o, g) {
    let x = this.any(s, p, o, g);
    if (x == null) {
      log_default.error("No value found for the() {" + s + " " + p + " " + o + "}.");
    }
    return x;
  }
  /**
   * RDFS Inference
   * These are hand-written implementations of a backward-chaining reasoner
   * over the RDFS axioms.
   * @param seeds - A hash of NTs of classes to start with
   * @param predicate - The property to trace though
   * @param inverse - Trace inverse direction
   */
  transitiveClosure(seeds, predicate, inverse) {
    let elt, i, len, s, sups, t;
    let agenda = {};
    Object.assign(agenda, seeds);
    let done = {};
    while (true) {
      t = function() {
        for (let p in agenda) {
          if (!agenda.hasOwnProperty(p)) continue;
          return p;
        }
      }();
      if (t == null) {
        return done;
      }
      sups = inverse ? this.each(void 0, predicate, this.fromNT(t)) : this.each(this.fromNT(t), predicate);
      for (i = 0, len = sups.length; i < len; i++) {
        elt = sups[i];
        s = elt.toNT();
        if (s in done) {
          continue;
        }
        if (s in agenda) {
          continue;
        }
        agenda[s] = agenda[t];
      }
      done[t] = agenda[t];
      delete agenda[t];
    }
  }
  /**
   * Finds the types in the list which have no *stored* supertypes
   * We exclude the universal class, owl:Things and rdf:Resource, as it is
   * information-free.
   * @param types - The types
   */
  topTypeURIs(types) {
    let i;
    let j;
    let k;
    let len;
    let n;
    let ref;
    let tops;
    let v;
    tops = [];
    for (k in types) {
      if (!types.hasOwnProperty(k)) continue;
      v = types[k];
      n = 0;
      ref = this.each(this.rdfFactory.namedNode(k), this.rdfFactory.namedNode("http://www.w3.org/2000/01/rdf-schema#subClassOf"));
      for (i = 0, len = ref.length; i < len; i++) {
        j = ref[i];
        if (j.uri !== "http://www.w3.org/2000/01/rdf-schema#Resource") {
          n++;
          break;
        }
      }
      if (!n) {
        tops[k] = v;
      }
    }
    if (tops["http://www.w3.org/2000/01/rdf-schema#Resource"]) {
      delete tops["http://www.w3.org/2000/01/rdf-schema#Resource"];
    }
    if (tops["http://www.w3.org/2002/07/owl#Thing"]) {
      delete tops["http://www.w3.org/2002/07/owl#Thing"];
    }
    return tops;
  }
  /**
   * Serializes this formula to a string
   */
  toString() {
    return "{" + this.statements.join("\n") + "}";
  }
  /**
   * Gets a new variable
   * @param name - The variable's name
   */
  variable(name) {
    return new Variable(name);
  }
  /**
   * Gets the number of statements in this formula that matches the specified pattern
   * @param s - The subject
   * @param p - The predicate
   * @param o - The object
   * @param g - The graph that contains the statement
   */
  whether(s, p, o, g) {
    return this.statementsMatching(s, p, o, g, false).length;
  }
};

// node_modules/rdflib/esm/node.js
Node2.fromValue = fromValue;
var node_default = Node2;
var ns = {
  xsd: Namespace("http://www.w3.org/2001/XMLSchema#")
};
Node2.toJS = function(term2) {
  if (isCollection(term2)) {
    return term2.elements.map(Node2.toJS);
  }
  if (!isLiteral(term2)) return term2;
  if (term2.datatype.equals(ns.xsd("boolean"))) {
    return term2.value === "1" || term2.value === "true";
  }
  if (term2.datatype.equals(ns.xsd("dateTime")) || term2.datatype.equals(ns.xsd("date"))) {
    return new Date(term2.value);
  }
  if (term2.datatype.equals(ns.xsd("integer")) || term2.datatype.equals(ns.xsd("float")) || term2.datatype.equals(ns.xsd("decimal"))) {
    return Number(term2.value);
  }
  return term2.value;
};

// node_modules/rdflib/esm/query.js
var Query = class {
  constructor(name, id) {
    this.pat = new IndexedFormula();
    this.vars = [];
    this.name = name;
    this.id = id;
  }
};
function indexedFormulaQuery(myQuery, callback, fetcher2, onDone) {
  function bindingDebug(b) {
    var str = "";
    var v;
    for (v in b) {
      if (b.hasOwnProperty(v)) {
        str += "    " + v + " -> " + b[v];
      }
    }
    return str;
  }
  function bindingsDebug(nbs) {
    var str = "Bindings: ";
    var i;
    var n = nbs.length;
    for (i = 0; i < n; i++) {
      str += bindingDebug(nbs[i][0]) + ";\n	";
    }
    return str;
  }
  function unifyTerm(self2, other, bindings, formula2) {
    var actual = bindings[self2];
    if (actual === void 0) {
      if (self2.isVar) {
        var b = [];
        b[self2] = other;
        return [[b, null]];
      }
      actual = self2;
    }
    if (!actual.complexType) {
      if (formula2.redirections[actual]) {
        actual = formula2.redirections[actual];
      }
      if (formula2.redirections[other]) {
        other = formula2.redirections[other];
      }
      if (actual.equals(other) || actual.uri && actual.uri === defaultGraphURI) {
        return [[[], null]];
      }
      return [];
    }
    if (self2 instanceof Array) {
      if (!(other instanceof Array)) {
        return [];
      }
      return unifyContents(self2, other, bindings);
    }
    throw new Error("query.js: oops - code not written yet");
  }
  function unifyContents(self2, other, bindings, formula2) {
    var nbs2;
    if (self2.length !== other.length) {
      return [];
    }
    if (!self2.length) {
      return [[[], null]];
    }
    var nbs = unifyTerm(self2[0], other[0], bindings, formula2);
    if (nbs.length === 0) {
      return nbs;
    }
    var res = [];
    var i;
    var n = nbs.length;
    var nb;
    var j;
    var m;
    var v;
    var nb2;
    var bindings2;
    for (i = 0; i < n; i++) {
      nb = nbs[i][0];
      bindings2 = [];
      for (v in nb) {
        if (nb.hasOwnProperty(v)) {
          bindings2[v] = nb[v];
        }
      }
      for (v in bindings) {
        if (bindings.hasOwnProperty(v)) {
          bindings2[v] = bindings[v];
        }
      }
      nbs2 = unifyContents(self2.slice(1), other.slice(1), bindings2, formula2);
      m = nbs2.length;
      for (j = 0; j < m; j++) {
        nb2 = nbs2[j][0];
        for (v in nb) {
          if (nb.hasOwnProperty(v)) {
            nb2[v] = nb[v];
          }
        }
        res.push([nb2, null]);
      }
    }
    return res;
  }
  function bind(x, binding) {
    var y = binding[x];
    if (y === void 0) {
      return x;
    }
    return y;
  }
  function union(a, b) {
    var c = {};
    var x;
    for (x in a) {
      if (a.hasOwnProperty(x)) {
        c[x] = a[x];
      }
    }
    for (x in b) {
      if (b.hasOwnProperty(x)) {
        c[x] = b[x];
      }
    }
    return c;
  }
  function OptionalBranchJunction(originalCallback, trunkBindings) {
    this.trunkBindings = trunkBindings;
    this.originalCallback = originalCallback;
    this.branches = [];
    return this;
  }
  OptionalBranchJunction.prototype.checkAllDone = function() {
    var i;
    for (i = 0; i < this.branches.length; i++) {
      if (!this.branches[i].done) {
        return;
      }
    }
    log_default.debug("OPTIONAL BIDNINGS ALL DONE:");
    this.doCallBacks(this.branches.length - 1, this.trunkBindings);
  };
  OptionalBranchJunction.prototype.doCallBacks = function(b, bindings) {
    var j;
    if (b < 0) {
      return this.originalCallback(bindings);
    }
    for (j = 0; j < this.branches[b].results.length; j++) {
      this.doCallBacks(b - 1, union(bindings, this.branches[b].results[j]));
    }
  };
  function MandatoryBranch(callback2, onDone2) {
    this.count = 0;
    this.success = false;
    this.done = false;
    this.callback = callback2;
    this.onDone = onDone2;
    return this;
  }
  MandatoryBranch.prototype.reportMatch = function(bindings) {
    this.callback(bindings);
    this.success = true;
  };
  MandatoryBranch.prototype.reportDone = function() {
    this.done = true;
    log_default.info("Mandatory query branch finished.***");
    if (this.onDone !== void 0) {
      this.onDone();
    }
  };
  var OptionalBranch = function(junction) {
    this.count = 0;
    this.done = false;
    this.results = [];
    this.junction = junction;
    junction.branches.push(this);
    return this;
  };
  OptionalBranch.prototype.reportMatch = function(bindings) {
    this.results.push(bindings);
  };
  OptionalBranch.prototype.reportDone = function() {
    log_default.debug("Optional branch finished - results.length = " + this.results.length);
    if (this.results.length === 0) {
      this.results.push({});
      log_default.debug("Optional branch FAILED - that's OK.");
    }
    this.done = true;
    this.junction.checkAllDone();
  };
  function prepare(f2, item, bindings) {
    var terms, termIndex, i, ind;
    item.nvars = 0;
    item.index = null;
    terms = [item.subject, item.predicate, item.object, item.why];
    ind = [f2.subjectIndex, f2.predicateIndex, f2.objectIndex, f2.whyIndex];
    for (i = 0; i < 4; i++) {
      let t = terms[i];
      if (t.uri && t.uri === defaultGraphURI) {
      } else if (t.isVar && !(bindings[t] !== void 0)) {
        item.nvars++;
      } else {
        t = bind(terms[i], bindings);
        if (f2.redirections[f2.id(t)]) {
          t = f2.redirections[f2.id(t)];
        }
        termIndex = ind[i][f2.id(t)];
        if (!termIndex) {
          item.index = [];
          return false;
        }
        if (item.index === null || item.index.length > termIndex.length) {
          item.index = termIndex;
        }
      }
    }
    if (item.index === null) {
      item.index = f2.statements;
    }
    return true;
  }
  function easiestQuery(self2, other) {
    if (self2.nvars !== other.nvars) {
      return self2.nvars - other.nvars;
    }
    return self2.index.length - other.index.length;
  }
  var matchIndex = 0;
  var match = function(f2, g, bindingsSoFar, level, fetcher3, localCallback, branch) {
    log_default.debug("Match begins, Branch count now: " + branch.count + " for " + branch.pattern_debug);
    var pattern = g.statements;
    if (pattern.length === 0) {
      log_default.debug("FOUND MATCH WITH BINDINGS:" + bindingDebug(bindingsSoFar));
      if (g.optional.length === 0) {
        branch.reportMatch(bindingsSoFar);
      } else {
        log_default.debug("OPTIONAL: " + g.optional);
        var junction = new OptionalBranchJunction(callback, bindingsSoFar);
        var br = [];
        var b;
        for (b = 0; b < g.optional.length; b++) {
          br[b] = new OptionalBranch(junction);
          br[b].pattern_debug = g.optional[b];
        }
        for (b = 0; b < g.optional.length; b++) {
          br[b].count = br[b].count + 1;
          match(f2, g.optional[b], bindingsSoFar, "", fetcher3, callback, br[b]);
        }
      }
      branch.count--;
      log_default.debug("Match ends -- success , Branch count now: " + branch.count + " for " + branch.pattern_debug);
      return;
    }
    var item;
    var i;
    var n = pattern.length;
    if (fetcher3) {
      var id = "match" + matchIndex++;
      var fetchResource = function(requestedTerm, id2) {
        var docuri = requestedTerm.uri.split("#")[0];
        fetcher3.nowOrWhenFetched(docuri, void 0, function(ok, body, xhr) {
          if (!ok) {
            console.log("Error following link to <" + requestedTerm.uri + "> in query: " + body);
          }
          match(
            f2,
            g,
            bindingsSoFar,
            level,
            fetcher3,
            // match not match2 to look up any others necessary.
            localCallback,
            branch
          );
        });
      };
      for (i = 0; i < n; i++) {
        item = pattern[i];
        if (bindingsSoFar[item.subject] !== void 0 && bindingsSoFar[item.subject].uri && fetcher3 && fetcher3.getState(docpart(bindingsSoFar[item.subject].uri)) === "unrequested") {
          fetchResource(bindingsSoFar[item.subject], id);
          return;
        }
        if (bindingsSoFar[item.object] !== void 0 && bindingsSoFar[item.object].uri && fetcher3 && fetcher3.getState(docpart(bindingsSoFar[item.object].uri)) === "unrequested") {
          fetchResource(bindingsSoFar[item.object], id);
          return;
        }
      }
    }
    match2(f2, g, bindingsSoFar, level, fetcher3, localCallback, branch);
  };
  var constraintsSatisfied = function(bindings, constraints) {
    var res = true;
    var x;
    var test;
    for (x in bindings) {
      if (bindings.hasOwnProperty(x)) {
        if (constraints[x]) {
          test = constraints[x].test;
          if (test && !test(bindings[x])) {
            res = false;
          }
        }
      }
    }
    return res;
  };
  var match2 = function(f2, g, bindingsSoFar, level, fetcher3, callback2, branch) {
    var pattern = g.statements;
    var n = pattern.length;
    var i;
    var k;
    var nk;
    var v;
    var bindings2;
    var newBindings1;
    var item;
    for (i = 0; i < n; i++) {
      item = pattern[i];
      prepare(f2, item, bindingsSoFar);
    }
    pattern.sort(easiestQuery);
    item = pattern[0];
    var rest = f2.formula();
    rest.optional = g.optional;
    rest.constraints = g.constraints;
    rest.statements = pattern.slice(1);
    log_default.debug(level + "match2 searching " + item.index.length + " for " + item + "; bindings so far=" + bindingDebug(bindingsSoFar));
    var c;
    var nc = item.index.length;
    var nbs1;
    var st2;
    var onward = 0;
    for (c = 0; c < nc; c++) {
      st2 = item.index[c];
      nbs1 = unifyContents([item.subject, item.predicate, item.object, item.why], [st2.subject, st2.predicate, st2.object, st2.why], bindingsSoFar, f2);
      log_default.info(level + " From first: " + nbs1.length + ": " + bindingsDebug(nbs1));
      nk = nbs1.length;
      for (k = 0; k < nk; k++) {
        bindings2 = [];
        newBindings1 = nbs1[k][0];
        if (!constraintsSatisfied(newBindings1, g.constraints)) {
          log_default.debug("Branch count CS: " + branch.count);
        } else {
          for (v in newBindings1) {
            if (newBindings1.hasOwnProperty(v)) {
              bindings2[v] = newBindings1[v];
            }
          }
          for (v in bindingsSoFar) {
            if (bindingsSoFar.hasOwnProperty(v)) {
              bindings2[v] = bindingsSoFar[v];
            }
          }
          branch.count++;
          onward++;
          match(f2, rest, bindings2, level + "  ", fetcher3, callback2, branch);
        }
      }
    }
    branch.count--;
    if (onward === 0) {
      log_default.debug("Match2 fails completely on " + item);
    }
    log_default.debug("Match2 ends, Branch count: " + branch.count + " for " + branch.pattern_debug);
    if (branch.count === 0) {
      log_default.debug("Branch finished.");
      branch.reportDone();
    }
  };
  var f = this;
  log_default.debug("Query on " + this.statements.length);
  var trunck = new MandatoryBranch(callback, onDone);
  trunck.count++;
  if (myQuery.sync) {
    match(f, myQuery.pat, myQuery.pat.initBindings, "", fetcher2, callback, trunck);
  } else {
    setTimeout(function() {
      match(f, myQuery.pat, myQuery.pat.initBindings, "", fetcher2, callback, trunck);
    }, 0);
  }
}

// node_modules/rdflib/esm/store.js
var owlNamespaceURI = "http://www.w3.org/2002/07/owl#";
function handleFP(formula2, subj, pred, obj) {
  var o1 = formula2.any(subj, pred, void 0);
  if (!o1) {
    return false;
  }
  formula2.equate(o1, obj);
  return true;
}
function handleIFP(formula2, subj, pred, obj) {
  var s1 = formula2.any(void 0, pred, obj);
  if (!s1) {
    return false;
  }
  formula2.equate(s1, subj);
  return true;
}
function handleRDFType(formula2, subj, pred, obj, why) {
  if (formula2.typeCallback) {
    formula2.typeCallback(formula2, obj, why);
  }
  var x = formula2.classActions[formula2.id(obj)];
  var done = false;
  if (x) {
    for (var i = 0; i < x.length; i++) {
      done = done || x[i](formula2, subj, pred, obj, why);
    }
  }
  return done;
}
var IndexedFormula = class _IndexedFormula extends Formula {
  /**
   * Creates a new formula
   * @param features - What sort of automatic processing to do? Array of string
   * @param features.sameAs - Smush together A and B nodes whenever { A sameAs B }
   * @param opts
   * @param [opts.rdfFactory] - The data factory that should be used by the store
   * @param [opts.rdfArrayRemove] - Function which removes statements from the store
   * @param [opts.dataCallback] - Callback when a statement is added to the store, will not trigger when adding duplicates
   */
  constructor(features, opts = {}) {
    super(void 0, void 0, void 0, void 0, opts);
    _defineProperty(this, "updater", void 0);
    _defineProperty(this, "namespaces", void 0);
    _defineProperty(this, "classActions", void 0);
    _defineProperty(this, "propertyActions", void 0);
    _defineProperty(this, "redirections", void 0);
    _defineProperty(this, "aliases", void 0);
    _defineProperty(this, "HTTPRedirects", void 0);
    _defineProperty(this, "subjectIndex", void 0);
    _defineProperty(this, "predicateIndex", void 0);
    _defineProperty(this, "objectIndex", void 0);
    _defineProperty(this, "whyIndex", void 0);
    _defineProperty(this, "index", void 0);
    _defineProperty(this, "features", void 0);
    _defineProperty(this, "_universalVariables", void 0);
    _defineProperty(this, "_existentialVariables", void 0);
    _defineProperty(this, "rdfArrayRemove", void 0);
    _defineProperty(this, "dataCallbacks", []);
    _defineProperty(this, "dataRemovalCallbacks", []);
    this.propertyActions = {};
    this.classActions = {};
    this.redirections = [];
    this.aliases = [];
    this.HTTPRedirects = [];
    this.subjectIndex = [];
    this.predicateIndex = [];
    this.objectIndex = [];
    this.whyIndex = [];
    this.index = [this.subjectIndex, this.predicateIndex, this.objectIndex, this.whyIndex];
    this.namespaces = {};
    this.features = features || [
      // By default, devs do not expect these features.
      // See https://github.com/linkeddata/rdflib.js/issues/458
      //      'sameAs',
      //      'InverseFunctionalProperty',
      //      'FunctionalProperty',
    ];
    this.rdfArrayRemove = opts.rdfArrayRemove || RDFArrayRemove;
    if (opts.dataCallback) {
      this.dataCallbacks = [opts.dataCallback];
    }
    if (opts.dataRemovalCallback) {
      this.dataRemovalCallbacks = [opts.dataRemovalCallback];
    }
    this.initPropertyActions(this.features);
  }
  /**
   * Gets the URI of the default graph
   */
  static get defaultGraphURI() {
    return defaultGraphURI;
  }
  /**
   * Gets this graph with the bindings substituted
   * @param bindings The bindings
   */
  substitute(bindings) {
    var statementsCopy = this.statements.map(function(ea) {
      return ea.substitute(bindings);
    });
    var y = new _IndexedFormula();
    y.add(statementsCopy);
    return y;
  }
  /**
   * Add a callback which will be triggered after a statement has been added to the store.
   * @param cb
   */
  addDataCallback(cb) {
    this.dataCallbacks.push(cb);
  }
  addDataRemovalCallback(cb) {
    this.dataRemovalCallbacks.push(cb);
  }
  /**
   * Apply a set of statements to be deleted and to be inserted
   *
   * @param patch - The set of statements to be deleted and to be inserted
   * @param target - The name of the document to patch
   * @param patchCallback - Callback to be called when patching is complete
   */
  applyPatch(patch, target, patchCallback) {
    var targetKB = this;
    var ds;
    var binding = null;
    function doPatch(onDonePatch) {
      if (patch["delete"]) {
        ds = patch["delete"];
        if (binding) ds = ds.substitute(binding);
        ds = ds.statements;
        var bad = [];
        var ds2 = ds.map(function(st2) {
          var sts = targetKB.statementsMatching(st2.subject, st2.predicate, st2.object, target);
          if (sts.length === 0) {
            bad.push(st2);
            return null;
          } else {
            return sts[0];
          }
        });
        if (bad.length) {
          return patchCallback("Could not find to delete: " + bad.join("\n or "));
        }
        ds2.map(function(st2) {
          targetKB.remove(st2);
        });
      }
      if (patch["insert"]) {
        ds = patch["insert"];
        if (binding) ds = ds.substitute(binding);
        ds = ds.statements;
        ds.map(function(st2) {
          st2.graph = target;
          targetKB.add(st2.subject, st2.predicate, st2.object, st2.graph);
        });
      }
      onDonePatch();
    }
    if (patch.where) {
      var query = new Query("patch");
      query.pat = patch.where;
      query.pat.statements.map(function(st2) {
        st2.graph = namedNode(target.value);
      });
      query.sync = true;
      var bindingsFound = [];
      targetKB.query(query, function onBinding(binding2) {
        bindingsFound.push(binding2);
      }, targetKB.fetcher, function onDone() {
        if (bindingsFound.length === 0) {
          return patchCallback("No match found to be patched:" + patch.where);
        }
        if (bindingsFound.length > 1) {
          return patchCallback("Patch ambiguous. No patch done.");
        }
        binding = bindingsFound[0];
        doPatch(patchCallback);
      });
    } else {
      doPatch(patchCallback);
    }
  }
  /**
   * N3 allows for declaring blank nodes, this function enables that support
   *
   * @param x The blank node to be declared, supported in N3
   */
  declareExistential(x) {
    if (!this._existentialVariables) this._existentialVariables = [];
    this._existentialVariables.push(x);
    return x;
  }
  /**
   * @param features
   */
  initPropertyActions(features) {
    this.propertyActions[this.rdfFactory.id(this.rdfFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"))] = [handleRDFType];
    if (ArrayIndexOf(features, "sameAs") >= 0) {
      this.propertyActions[this.rdfFactory.id(this.rdfFactory.namedNode(`${owlNamespaceURI}sameAs`))] = [function(formula2, subj, pred, obj, why) {
        formula2.equate(subj, obj);
        return true;
      }];
    }
    if (ArrayIndexOf(features, "InverseFunctionalProperty") >= 0) {
      this.classActions[this.rdfFactory.id(this.rdfFactory.namedNode(`${owlNamespaceURI}InverseFunctionalProperty`))] = [function(formula2, subj, pred, obj, addFn) {
        return formula2.newPropertyAction(subj, handleIFP);
      }];
    }
    if (ArrayIndexOf(features, "FunctionalProperty") >= 0) {
      this.classActions[this.rdfFactory.id(this.rdfFactory.namedNode(`${owlNamespaceURI}FunctionalProperty`))] = [function(formula2, subj, proj, obj, addFn) {
        return formula2.newPropertyAction(subj, handleFP);
      }];
    }
  }
  /** @deprecated Use {add} instead */
  addStatement(st2) {
    this.add(st2.subject, st2.predicate, st2.object, st2.graph);
    return this.statements.length;
  }
  /**
   * Adds a triple (quad) to the store.
   *
   * @param subj - The thing about which the fact a relationship is asserted.
   *        Also accepts a statement or an array of Statements.
   * @param pred - The relationship which is asserted
   * @param obj - The object of the relationship, e.g. another thing or a value. If passed a string, this will become a literal.
   * @param why - The document in which the triple (S,P,O) was or will be stored on the web
   * @returns The statement added to the store, or the store
   */
  add(subj, pred, obj, why) {
    var i;
    if (arguments.length === 1) {
      if (subj instanceof Array) {
        for (i = 0; i < subj.length; i++) {
          this.add(subj[i]);
        }
      } else if (isQuad(subj)) {
        this.add(subj.subject, subj.predicate, subj.object, subj.graph);
      } else if (isStore(subj)) {
        this.add(subj.statements);
      }
      return this;
    }
    var actions;
    var st2;
    if (!why) {
      why = this.fetcher ? this.fetcher.appNode : this.rdfFactory.defaultGraph();
    }
    if (typeof subj == "string") {
      subj = this.rdfFactory.namedNode(subj);
    }
    pred = node_default.fromValue(pred);
    const objNode = node_default.fromValue(obj);
    why = node_default.fromValue(why);
    if (!isRDFlibSubject(subj)) {
      throw new Error("Subject is not a subject type");
    }
    if (!isRDFlibPredicate(pred)) {
      throw new Error(`Predicate ${pred} is not a predicate type`);
    }
    if (!isRDFlibObject(objNode)) {
      throw new Error(`Object ${objNode} is not an object type`);
    }
    if (!isGraph(why)) {
      throw new Error("Why is not a graph type");
    }
    if (this.predicateCallback) {
      this.predicateCallback(this, pred, why);
    }
    var predHash = this.id(this.canon(pred));
    actions = this.propertyActions[predHash];
    var done = false;
    if (actions) {
      for (i = 0; i < actions.length; i++) {
        done = done || actions[i](this, subj, pred, objNode, why);
      }
    }
    if (this.holds(subj, pred, objNode, why)) {
      return null;
    }
    var hash = [this.id(this.canon(subj)), predHash, this.id(this.canon(objNode)), this.id(this.canon(why))];
    st2 = this.rdfFactory.quad(subj, pred, objNode, why);
    for (i = 0; i < 4; i++) {
      var ix = this.index[i];
      var h = hash[i];
      if (!ix[h]) {
        ix[h] = [];
      }
      ix[h].push(st2);
    }
    this.statements.push(st2);
    for (const callback of this.dataCallbacks) {
      callback(st2);
    }
    return st2;
  }
  /**
   * Returns the symbol with canonical URI as smushed
   * @param term - An RDF node
   */
  canon(term2) {
    if (!term2) {
      return term2;
    }
    const y = this.redirections[this.id(term2)];
    if (y) {
      return y;
    }
    switch (term2.termType) {
      case BlankNodeTermType:
        return new BlankNode(term2.value);
      case CollectionTermType:
        return term2;
      // non-RDF/JS type, should just need to cast
      case DefaultGraphTermType:
        return new DefaultGraph();
      case EmptyTermType:
        return term2;
      case GraphTermType:
        return term2;
      case LiteralTermType:
        return new Literal(term2.value, term2.language, term2.datatype);
      case NamedNodeTermType:
        return new NamedNode(term2.value);
      case VariableTermType:
        return new Variable(term2.value);
      default:
        throw new Error(`Term Type not recognized for canonization: ${term2.termType}`);
    }
  }
  /**
   * Checks this formula for consistency
   */
  check() {
    this.checkStatementList(this.statements);
    for (var p = 0; p < 4; p++) {
      var ix = this.index[p];
      for (var key in ix) {
        if (ix.hasOwnProperty(key)) {
          this.checkStatementList(ix[key], p);
        }
      }
    }
  }
  /**
   * Checks a list of statements for consistency
   * @param sts - The list of statements to check
   * @param from - An index with the array ['subject', 'predicate', 'object', 'why']
   */
  checkStatementList(sts, from) {
    if (from === void 0) {
      from = 0;
    }
    var names = ["subject", "predicate", "object", "why"];
    var origin = " found in " + names[from] + " index.";
    var st2;
    for (var j = 0; j < sts.length; j++) {
      st2 = sts[j];
      var term2 = [st2.subject, st2.predicate, st2.object, st2.graph];
      var arrayContains = function(a, x) {
        for (var i = 0; i < a.length; i++) {
          if (a[i].subject.equals(x.subject) && a[i].predicate.equals(x.predicate) && a[i].object.equals(x.object) && a[i].why.equals(x.graph)) {
            return true;
          }
        }
      };
      for (var p = 0; p < 4; p++) {
        var c = this.canon(term2[p]);
        var h = this.id(c);
        if (!this.index[p][h]) {
        } else {
          if (!arrayContains(this.index[p][h], st2)) {
          }
        }
      }
      if (!arrayContains(this.statements, st2)) {
        throw new Error("Statement list does not statement " + st2 + "@" + st2.graph + origin);
      }
    }
  }
  /**
   * Closes this formula (and return it)
   */
  close() {
    return this;
  }
  compareTerms(u1, u2) {
    if (Object.prototype.hasOwnProperty.call(u1, "compareTerm")) {
      return u1.compareTerm(u2);
    }
    if (class_order_default[u1.termType] < class_order_default[u2.termType]) {
      return -1;
    }
    if (class_order_default[u1.termType] > class_order_default[u2.termType]) {
      return 1;
    }
    if (u1.value < u2.value) {
      return -1;
    }
    if (u1.value > u2.value) {
      return 1;
    }
    return 0;
  }
  /**
   * replaces @template with @target and add appropriate triples
   * removes no triples by default and is a one-direction replication
   * @param template node to copy
   * @param target node to copy to
   * @param flags Whether or not to do a two-directional copy and/or delete triples
   */
  copyTo(template, target, flags) {
    if (!flags) flags = [];
    var statList = this.statementsMatching(template);
    if (ArrayIndexOf(flags, "two-direction") !== -1) {
      statList.concat(this.statementsMatching(void 0, void 0, template));
    }
    for (var i = 0; i < statList.length; i++) {
      var st2 = statList[i];
      switch (st2.object.termType) {
        case "NamedNode":
          this.add(target, st2.predicate, st2.object);
          break;
        case "Literal":
        case "BlankNode":
        // @ts-ignore Collections can appear here
        case "Collection":
          this.add(target, st2.predicate, st2.object.copy(this));
      }
      if (ArrayIndexOf(flags, "delete") !== -1) {
        this.remove(st2);
      }
    }
  }
  /**
   * Simplify graph in store when we realize two identifiers are equivalent
   * We replace the bigger with the smaller.
   * @param u1in The first node
   * @param u2in The second node
   */
  equate(u1in, u2in) {
    const u1 = this.canon(u1in);
    const u2 = this.canon(u2in);
    var d = this.compareTerms(u1, u2);
    if (!d) {
      return true;
    }
    if (d < 0) {
      return this.replaceWith(u2, u1);
    } else {
      return this.replaceWith(u1, u2);
    }
  }
  /**
   * Creates a new empty indexed formula
   * Only applicable for IndexedFormula, but TypeScript won't allow a subclass to override a property
   * @param features The list of features
   */
  formula(features) {
    return new _IndexedFormula(features);
  }
  /**
   * Returns the number of statements contained in this IndexedFormula.
   * (Getter proxy to this.statements).
   * Usage:
   *    ```
   *    var kb = rdf.graph()
   *    kb.length  // -> 0
   *    ```
   * @returns {Number}
   */
  get length() {
    return this.statements.length;
  }
  /**
   * Returns any quads matching the given arguments.
   * Standard RDFJS spec method for Source objects, implemented as an
   * alias to `statementsMatching()`
   * @param subject The subject
   * @param predicate The predicate
   * @param object The object
   * @param graph The graph that contains the statement
   */
  match(subject, predicate, object, graph2) {
    return this.statementsMatching(node_default.fromValue(subject), node_default.fromValue(predicate), node_default.fromValue(object), node_default.fromValue(graph2));
  }
  /**
   * Find out whether a given URI is used as symbol in the formula
   * @param uri The URI to look for
   */
  mentionsURI(uri) {
    var hash = "<" + uri + ">";
    return !!this.subjectIndex[hash] || !!this.objectIndex[hash] || !!this.predicateIndex[hash];
  }
  /**
   * Existentials are BNodes - something exists without naming
   * @param uri An URI
   */
  newExistential(uri) {
    if (!uri) return this.bnode();
    var x = this.sym(uri);
    return this.declareExistential(x);
  }
  /**
   * Adds a new property action
   * @param pred the predicate that the function should be triggered on
   * @param action the function that should trigger
   */
  newPropertyAction(pred, action) {
    var hash = this.id(pred);
    if (!this.propertyActions[hash]) {
      this.propertyActions[hash] = [];
    }
    this.propertyActions[hash].push(action);
    var toBeFixed = this.statementsMatching(void 0, pred, void 0);
    var done = false;
    for (var i = 0; i < toBeFixed.length; i++) {
      done = done || action(this, toBeFixed[i].subject, pred, toBeFixed[i].object);
    }
    return done;
  }
  /**
   * Creates a new universal node
   * Universals are Variables
   * @param uri An URI
   */
  newUniversal(uri) {
    var x = this.sym(uri);
    if (!this._universalVariables) this._universalVariables = [];
    this._universalVariables.push(x);
    return x;
  }
  // convenience function used by N3 parser
  variable(name) {
    return new Variable(name);
  }
  /**
   * Find an unused id for a file being edited: return a symbol
   * (Note: Slow iff a lot of them -- could be O(log(k)) )
   * @param doc A document named node
   */
  nextSymbol(doc) {
    for (var i = 0; ; i++) {
      var uri = doc.value + "#n" + i;
      if (!this.mentionsURI(uri)) return this.sym(uri);
    }
  }
  /**
   * Query this store asynchronously, return bindings in callback
   *
   * @param myQuery The query to be run
   * @param callback Function to call when bindings
   * @param Fetcher | null  If you want the query to do link following
   * @param onDone OBSOLETE - do not use this // @@ Why not ?? Called when query complete
   */
  query(myQuery, callback, fetcher2, onDone) {
    return indexedFormulaQuery.call(this, myQuery, callback, fetcher2, onDone);
  }
  /**
   * Query this store synchronously and return bindings
   *
   * @param myQuery The query to be run
   */
  querySync(myQuery) {
    var results = [];
    function saveBinginds(bindings) {
      results.push(bindings);
    }
    function onDone() {
      done = true;
    }
    var done = false;
    myQuery.sync = true;
    indexedFormulaQuery.call(this, myQuery, saveBinginds, null, onDone);
    if (!done) {
      throw new Error("Sync query should have called done function");
    }
    return results;
  }
  /**
   * Removes one or multiple statement(s) from this formula
   * @param st - A Statement or array of Statements to remove
   */
  remove(st2) {
    if (st2 instanceof Array) {
      for (var i = 0; i < st2.length; i++) {
        this.remove(st2[i]);
      }
      return this;
    }
    if (isStore(st2)) {
      return this.remove(st2.statements);
    }
    var sts = this.statementsMatching(st2.subject, st2.predicate, st2.object, st2.graph);
    if (!sts.length) {
      throw new Error("Statement to be removed is not on store: " + st2);
    }
    this.removeStatement(sts[0]);
    return this;
  }
  /**
   * Removes all statements in a doc, along with the related metadata including request/response/status
   * @param doc - The document / graph
   */
  removeDocument(doc) {
    this.removeMetadata(doc);
    var sts = this.statementsMatching(void 0, void 0, void 0, doc).slice();
    for (var i = 0; i < sts.length; i++) {
      this.removeStatement(sts[i]);
    }
    this.removeMatches(doc, null, null);
    return this;
  }
  removeMetadata(doc) {
    const meta = this.sym("chrome://TheCurrentSession");
    const linkNamespaceURI = "http://www.w3.org/2007/ont/link#";
    const requests = this.statementsMatching(void 0, this.sym(`${linkNamespaceURI}requestedURI`), this.rdfFactory.literal(doc.value), meta).map((st2) => st2.subject);
    for (var r = 0; r < requests.length; r++) {
      const request = requests[r];
      if (request != void 0) {
        let sts;
        const status = this.any(request, this.sym(`${linkNamespaceURI}status`), null, meta);
        if (status != void 0) {
          sts = this.statementsMatching(status, this.sym(`${linkNamespaceURI}status`), null, meta).slice();
          for (var i = 0; i < sts.length; i++) {
            this.removeStatement(sts[i]);
          }
        }
        const response = this.any(request, this.sym(`${linkNamespaceURI}response`), null, meta);
        if (response != void 0) {
          sts = this.statementsMatching(response, null, null, meta).slice();
          for (var i = 0; i < sts.length; i++) {
            this.removeStatement(sts[i]);
          }
        }
        sts = this.statementsMatching(request, null, null, meta).slice();
        for (var i = 0; i < sts.length; i++) {
          this.removeStatement(sts[i]);
        }
      }
    }
    this.removeMatches(this.sym(doc.value), null, null, meta);
    return this;
  }
  /**
   * Remove all statements matching args (within limit) *
   * @param subj The subject
   * @param pred The predicate
   * @param obj The object
   * @param why The graph that contains the statement
   * @param limit The number of statements to remove
   */
  removeMany(subj, pred, obj, why, limit) {
    var sts = this.statementsMatching(subj, pred, obj, why, false);
    var statements = [];
    for (var i = 0; i < sts.length; i++) statements.push(sts[i]);
    if (limit) statements = statements.slice(0, limit);
    for (i = 0; i < statements.length; i++) this.remove(statements[i]);
  }
  /**
   * Remove all matching statements
   * @param subject The subject
   * @param predicate The predicate
   * @param object The object
   * @param graph The graph that contains the statement
   */
  removeMatches(subject, predicate, object, graph2) {
    this.removeMany(subject, predicate, object, graph2);
    return this;
  }
  /**
   * Remove a particular statement object from the store
   *
   * @param st - a statement which is already in the store and indexed.
   *        Make sure you only use this for these.
   *        Otherwise, you should use remove() above.
   */
  removeStatement(st2) {
    var term2 = [st2.subject, st2.predicate, st2.object, st2.graph];
    for (var p = 0; p < 4; p++) {
      var c = this.canon(term2[p]);
      var h = this.id(c);
      if (!this.index[p][h]) {
      } else {
        this.rdfArrayRemove(this.index[p][h], st2);
      }
    }
    this.rdfArrayRemove(this.statements, st2);
    for (const callback of this.dataRemovalCallbacks) {
      callback(st2);
    }
    return this;
  }
  /**
   * Removes statements
   * @param sts The statements to remove
   */
  removeStatements(sts) {
    for (var i = 0; i < sts.length; i++) {
      this.remove(sts[i]);
    }
    return this;
  }
  /**
   * Replace big with small, obsoleted with obsoleting.
   */
  replaceWith(big, small) {
    var oldhash = this.id(big);
    var newhash = this.id(small);
    var moveIndex = function(ix) {
      var oldlist = ix[oldhash];
      if (!oldlist) {
        return;
      }
      var newlist = ix[newhash];
      if (!newlist) {
        ix[newhash] = oldlist;
      } else {
        ix[newhash] = oldlist.concat(newlist);
      }
      delete ix[oldhash];
    };
    for (var i = 0; i < 4; i++) {
      moveIndex(this.index[i]);
    }
    this.redirections[oldhash] = small;
    if (big.value) {
      if (!this.aliases[newhash]) {
        this.aliases[newhash] = [];
      }
      this.aliases[newhash].push(big);
      if (this.aliases[oldhash]) {
        for (i = 0; i < this.aliases[oldhash].length; i++) {
          this.redirections[this.id(this.aliases[oldhash][i])] = small;
          this.aliases[newhash].push(this.aliases[oldhash][i]);
        }
      }
      this.add(small, this.sym("http://www.w3.org/2007/ont/link#uri"), big);
      if (this.fetcher) {
        this.fetcher.nowKnownAs(big, small);
      }
    }
    moveIndex(this.classActions);
    moveIndex(this.propertyActions);
    return true;
  }
  /**
   * Return all equivalent URIs by which this is known
   * @param x A named node
   */
  allAliases(x) {
    var a = this.aliases[this.id(this.canon(x))] || [];
    a.push(this.canon(x));
    return a;
  }
  /**
   * Compare by canonical URI as smushed
   * @param x A named node
   * @param y Another named node
   */
  sameThings(x, y) {
    if (x.equals(y)) {
      return true;
    }
    var x1 = this.canon(x);
    if (!x1) return false;
    var y1 = this.canon(y);
    if (!y1) return false;
    return x1.value === y1.value;
  }
  setPrefixForURI(prefix, nsuri) {
    if (prefix === "tab" && this.namespaces["tab"]) {
      return;
    }
    if (prefix.slice(0, 2) === "ns" || prefix.slice(0, 7) === "default") {
      return;
    }
    for (let existingPrefix in this.namespaces) {
      if (this.namespaces[existingPrefix] == nsuri) delete this.namespaces[existingPrefix];
    }
    this.namespaces[prefix] = nsuri;
  }
  /** Search the Store
   *
   * ALL CONVENIENCE LOOKUP FUNCTIONS RELY ON THIS!
   * @param subj - A node to search for as subject, or if null, a wildcard
   * @param pred - A node to search for as predicate, or if null, a wildcard
   * @param obj - A node to search for as object, or if null, a wildcard
   * @param why - A node to search for as graph, or if null, a wildcard
   * @param justOne - flag - stop when found one rather than get all of them?
   * @returns An array of nodes which match the wildcard position
   */
  statementsMatching(subj, pred, obj, why, justOne) {
    var pat = [subj, pred, obj, why];
    var pattern = [];
    var hash = [];
    var wild = [];
    var given = [];
    var p;
    var list;
    for (p = 0; p < 4; p++) {
      pattern[p] = this.canon(node_default.fromValue(pat[p]));
      if (!pattern[p]) {
        wild.push(p);
      } else {
        given.push(p);
        hash[p] = this.id(pattern[p]);
      }
    }
    if (given.length === 0) {
      return this.statements;
    }
    if (given.length === 1) {
      p = given[0];
      list = this.index[p][hash[p]];
      if (list && justOne) {
        if (list.length > 1) {
          list = list.slice(0, 1);
        }
      }
      list = list || [];
      return list;
    }
    var best = 1e10;
    var iBest;
    var i;
    for (i = 0; i < given.length; i++) {
      p = given[i];
      list = this.index[p][hash[p]];
      if (!list) {
        return [];
      }
      if (list.length < best) {
        best = list.length;
        iBest = i;
      }
    }
    var pBest = given[iBest];
    var possibles = this.index[pBest][hash[pBest]];
    var check = given.slice(0, iBest).concat(given.slice(iBest + 1));
    var results = [];
    var parts = ["subject", "predicate", "object", "why"];
    for (var j = 0; j < possibles.length; j++) {
      var st2 = possibles[j];
      for (i = 0; i < check.length; i++) {
        p = check[i];
        if (!this.canon(st2[parts[p]]).equals(pattern[p])) {
          st2 = null;
          break;
        }
      }
      if (st2 != null) {
        results.push(st2);
        if (justOne) break;
      }
    }
    return results;
  }
  /**
   * A list of all the URIs by which this thing is known
   * @param term
   */
  uris(term2) {
    var cterm = this.canon(term2);
    var terms = this.aliases[this.id(cterm)];
    if (!cterm.value) return [];
    var res = [cterm.value];
    if (terms) {
      for (var i = 0; i < terms.length; i++) {
        res.push(terms[i].uri);
      }
    }
    return res;
  }
  serialize(base, contentType, provenance, options) {
    const namespaces = (options == null ? void 0 : options.namespaces) ? {
      ...this.namespaces,
      ...options.namespaces
    } : {
      ...this.namespaces
    };
    options = {
      ...options || {},
      namespaces
    };
    return serialize(provenance, this, base, contentType, void 0, options);
  }
};
_defineProperty(IndexedFormula, "handleRDFType", void 0);
IndexedFormula.handleRDFType = handleRDFType;

// node_modules/rdflib/esm/lists.js
var RDF = Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
function substituteInDoc(store, x, y, doc) {
  for (const quad3 of store.statementsMatching(y, null, null, doc)) {
    const newStatement = new Statement(x, quad3.predicate, quad3.object, doc);
    store.remove(quad3);
    store.add(newStatement);
  }
  for (const quad3 of store.statementsMatching(null, y, null, doc)) {
    store.remove(quad3);
    store.add(new Statement(quad3.subject, x, quad3.object, doc));
  }
  for (const quad3 of store.statementsMatching(null, null, y, doc)) {
    store.remove(quad3);
    store.add(new Statement(quad3.subject, quad3.predicate, x, doc));
  }
}
function substituteNillsInDoc(store, doc) {
  const x = RDF("nil");
  for (const quad3 of store.statementsMatching(x, null, null, doc)) {
    store.remove(quad3);
    const y = new Collection();
    store.add(new Statement(y, quad3.predicate, quad3.object, doc));
  }
  for (const quad3 of store.statementsMatching(null, null, x, doc)) {
    if (!quad3.predicate.sameTerm(RDF("rest"))) {
      store.remove(quad3);
      const y = new Collection();
      store.add(new Statement(quad3.subject, quad3.predicate, y, doc));
    }
  }
}
function convertFirstRestNil(store, doc) {
  function preceding(ele, listSoFar, trash) {
    const rests = store.statementsMatching(ele, RDF("rest"), null, doc);
    if (rests.length !== 1) throw new Error(`Bad list structure: no rest at ${ele}`);
    const firsts = store.statementsMatching(ele, RDF("first"), null, doc);
    if (firsts.length !== 1) throw new Error(`Bad list structure: rest but ${firsts.length} firsts at ${ele}`);
    const value = firsts[0].object;
    const total = [value].concat(listSoFar);
    const totalTrash = trash.concat(rests).concat(firsts);
    const pres = store.statementsMatching(null, RDF("rest"), ele, doc);
    if (pres.length === 0) {
      const newList = new Collection(total);
      store.remove(totalTrash);
      substituteInDoc(store, newList, ele, doc);
      return;
    }
    if (pres.length !== 1) throw new Error(`Bad list structure: ${pres.length} pres at ${ele}`);
    const pre = pres[0].subject;
    if (pre.termType !== "BlankNode") throw new Error(`Bad list element node ${pre} type: ${pre.termType} `);
    preceding(pre, total, totalTrash);
    return;
  }
  substituteNillsInDoc(store, doc);
  const tails = store.statementsMatching(null, RDF("rest"), RDF("nil"), doc);
  tails.forEach((tail) => {
    if (tail.subject.termType !== "BlankNode") throw new Error(`Bad list element node ${tail.subject} type: ${tail.subject.termType} `);
    preceding(tail.subject, [], []);
  });
}

// node_modules/rdflib/esm/n3parser.js
function hexify2(str) {
  return encodeURI(str);
}
var Utf8 = {
  // public method for url encoding
  encode: function(string2) {
    string2 = string2.replace(/\r\n/g, "\n");
    var utftext = "";
    for (var n = 0; n < string2.length; n++) {
      var c = string2.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  },
  // public method for url decoding
  decode: function(utftext) {
    var string2 = "";
    var i = 0;
    while (i < utftext.length) {
      var c = utftext.charCodeAt(i);
      if (c < 128) {
        string2 += String.fromCharCode(c);
        i++;
      } else if (c > 191 && c < 224) {
        string2 += String.fromCharCode((c & 31) << 6 | utftext.charCodeAt(i + 1) & 63);
        i += 2;
      } else {
        string2 += String.fromCharCode((c & 15) << 12 | (utftext.charCodeAt(i + 1) & 63) << 6 | utftext.charCodeAt(i + 2) & 63);
        i += 3;
      }
    }
    return string2;
  }
};
var Logic_NS = "http://www.w3.org/2000/10/swap/log#";
var pyjslib_Tuple = function(theList) {
  return theList;
};
var pyjslib_List = function(theList) {
  return theList;
};
var pyjslib_Dict = function(listOfPairs) {
  if (listOfPairs.length > 0) throw "missing.js: oops nnonempty dict not imp";
  return [];
};
var pyjslib_len = function(s) {
  return s.length;
};
var pyjslib_slice = function(str, i, j) {
  if (typeof str.slice == "undefined") throw "@@ mising.js: No .slice function for " + str + " of type " + typeof str;
  if (typeof j == "undefined" || j == null) return str.slice(i);
  return str.slice(i, j);
};
var StopIteration = Error("dummy error stop iteration");
var pyjslib_Iterator = function(theList) {
  this.last = 0;
  this.li = theList;
  this.next = function() {
    if (this.last == this.li.length) throw StopIteration;
    return this.li[this.last++];
  };
  return this;
};
var string_find = function(str, s) {
  return str.indexOf(s);
};
var assertFudge = function(condition, desc) {
  if (condition) return;
  if (desc) throw "python Assertion failed: " + desc;
  throw "(python) Assertion failed.";
};
var stringFromCharCode = function(uesc) {
  return String.fromCharCode(uesc);
};
String.prototype.encode = function(encoding) {
  if (encoding != "utf-8") throw "UTF8_converter: can only do utf-8";
  return Utf8.encode(this);
};
String.prototype.decode = function(encoding) {
  if (encoding != "utf-8") throw "UTF8_converter: can only do utf-8";
  return this;
};
var uripath_join = function(base, given) {
  return join(given, base);
};
var becauseSubexpression = null;
var diag_tracking = 0;
var diag_chatty_flag = 0;
var diag_progress = function(str) {
};
var RDF_type_URI = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
var RDF_nil_URI = "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil";
var DAML_sameAs_URI = "http://www.w3.org/2002/07/owl#sameAs";
var ADDED_HASH = "#";
var INTEGER_DATATYPE = "http://www.w3.org/2001/XMLSchema#integer";
var FLOAT_DATATYPE = "http://www.w3.org/2001/XMLSchema#double";
var DECIMAL_DATATYPE = "http://www.w3.org/2001/XMLSchema#decimal";
var DATE_DATATYPE = "http://www.w3.org/2001/XMLSchema#date";
var DATETIME_DATATYPE = "http://www.w3.org/2001/XMLSchema#dateTime";
var _notQNameChars = "	\r\n !\"#$%&'()*.,+/;<=>?@[\\]^`{|}~";
var _notNameChars = _notQNameChars + ":";
var eol = new RegExp("^[ \\t]*(#[^\\n]*)?\\r?\\n", "g");
var eof = new RegExp("^[ \\t]*(#[^\\n]*)?$", "g");
var ws = new RegExp("^[ \\t]*", "g");
var signed_integer = new RegExp("^[-+]?[0-9]+", "g");
var number_syntax = new RegExp("^([-+]?[0-9]+)(\\.[0-9]+)?([eE][-+]?[0-9]+)?", "g");
var datetime_syntax = new RegExp("^[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9](T[0-9][0-9]:[0-9][0-9](:[0-9][0-9](\\.[0-9]*)?)?)?Z?");
var wsOrHash = new RegExp("[\\s#]");
var digitstring = new RegExp("^[0-9]+", "g");
var interesting = new RegExp('[\\\\\\r\\n\\"]', "g");
var langcode = new RegExp("^[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*", "g");
function dotTerminatesName(str, i) {
  var next = str.charAt(i + 1);
  return next === "" || wsOrHash.test(next);
}
function createSinkParser(store, openFormula, thisDoc, baseURI, genPrefix, metaURI, flags, why) {
  return new SinkParser(store, openFormula, thisDoc, baseURI, genPrefix, metaURI, flags, why);
}
var n3parser_default = createSinkParser;
var SinkParser = class {
  constructor(store, openFormula, thisDoc, baseURI, genPrefix, metaURI, flags, why) {
    if (typeof openFormula == "undefined") openFormula = null;
    if (typeof thisDoc == "undefined") thisDoc = "";
    if (typeof baseURI == "undefined") baseURI = null;
    if (typeof genPrefix == "undefined") genPrefix = "";
    if (typeof metaURI == "undefined") metaURI = null;
    if (typeof flags == "undefined") flags = "";
    if (typeof why == "undefined") why = null;
    this._bindings = new pyjslib_Dict([]);
    this._flags = flags;
    if (thisDoc != "") {
      assertFudge(thisDoc.indexOf(":") >= 0, "Document URI not absolute: " + thisDoc);
      this._bindings[""] = thisDoc + "#";
    }
    this._store = store;
    if (genPrefix) {
      store.setGenPrefix(genPrefix);
    }
    this._thisDoc = thisDoc;
    this.source = store.sym(thisDoc);
    this.lines = 0;
    this.statementCount = 0;
    this.hasNil = false;
    this.startOfLine = 0;
    this.previousLine = 0;
    this._genPrefix = genPrefix;
    this.keywords = new pyjslib_List(["a", "this", "bind", "has", "is", "of", "true", "false"]);
    this.keywordsSet = 0;
    this._anonymousNodes = new pyjslib_Dict([]);
    this._variables = new pyjslib_Dict([]);
    this._parentVariables = new pyjslib_Dict([]);
    this._reason = why;
    this._reason2 = null;
    if (diag_tracking) {
      this._reason2 = why_BecauseOfData(store.sym(thisDoc), this._reason);
    }
    if (baseURI) {
      this._baseURI = baseURI;
    } else {
      if (thisDoc) {
        this._baseURI = thisDoc;
      } else {
        this._baseURI = null;
      }
    }
    assertFudge(!this._baseURI || this._baseURI.indexOf(":") >= 0);
    if (!this._genPrefix) {
      if (this._thisDoc) {
        this._genPrefix = this._thisDoc + "#_g";
      } else {
        this._genPrefix = RDFSink_uniqueURI();
      }
    }
    if (openFormula == null) {
      if (this._thisDoc) {
        this._formula = store.formula(thisDoc + "#_formula");
      } else {
        this._formula = store.formula();
      }
    } else {
      this._formula = openFormula;
    }
    this._context = this._formula;
    this._parentContext = null;
  }
  here(i) {
    return this._genPrefix + "_L" + this.lines + "C" + (i - this.startOfLine + 1);
  }
  formula() {
    return this._formula;
  }
  loadStream(stream) {
    return this.loadBuf(stream.read());
  }
  loadBuf(buf) {
    this.startDoc();
    this.feed(buf);
    return this.endDoc();
  }
  feed(octets) {
    var str = octets.decode("utf-8");
    var i = 0;
    while (i >= 0) {
      var j = this.skipSpace(str, i);
      if (j < 0) {
        return;
      }
      var i = this.directiveOrStatement(str, j);
      if (i < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "expected directive or statement");
      }
    }
  }
  directiveOrStatement(str, h) {
    var i = this.skipSpace(str, h);
    if (i < 0) {
      return i;
    }
    var j = this.directive(str, i);
    if (j >= 0) {
      return this.checkDot(str, j);
    }
    var j = this.statement(str, i);
    if (j >= 0) {
      return this.checkDot(str, j);
    }
    return j;
  }
  tok(tok, str, i) {
    var whitespace = "	\n\v\f\r ";
    if (str.slice(i, i + 1) == "@") {
      var i = i + 1;
    } else {
      if (ArrayIndexOf(this.keywords, tok) < 0) {
        return -1;
      }
    }
    var k = i + pyjslib_len(tok);
    if (str.slice(i, k) == tok && _notQNameChars.indexOf(str.charAt(k)) >= 0) {
      return k;
    } else {
      return -1;
    }
  }
  directive(str, i) {
    var j = this.skipSpace(str, i);
    if (j < 0) {
      return j;
    }
    var res = new pyjslib_List([]);
    var j = this.tok("bind", str, i);
    if (j > 0) {
      throw BadSyntax(this._thisDoc, this.lines, str, i, "keyword bind is obsolete: use @prefix");
    }
    var j = this.tok("keywords", str, i);
    if (j > 0) {
      var i = this.commaSeparatedList(str, j, res, false);
      if (i < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, i, "'@keywords' needs comma separated list of words");
      }
      this.setKeywords(pyjslib_slice(res, null, null));
      if (diag_chatty_flag > 80) {
        diag_progress("Keywords ", this.keywords);
      }
      return i;
    }
    var j = this.tok("forAll", str, i);
    if (j > 0) {
      var i = this.commaSeparatedList(str, j, res, true);
      if (i < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, i, "Bad variable list after @forAll");
      }
      var __x = new pyjslib_Iterator(res);
      try {
        while (true) {
          var x = __x.next();
          if (ArrayIndexOf(this._variables, x) < 0 || ArrayIndexOf(this._parentVariables, x) >= 0) {
            this._variables[x] = this._context.newUniversal(x);
          }
        }
      } catch (e) {
        if (e != StopIteration) {
          throw e;
        }
      }
      return i;
    }
    var j = this.tok("forSome", str, i);
    if (j > 0) {
      var i = this.commaSeparatedList(str, j, res, this.uri_ref2);
      if (i < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, i, "Bad variable list after @forSome");
      }
      var __x = new pyjslib_Iterator(res);
      try {
        while (true) {
          var x = __x.next();
          this._context.declareExistential(x);
        }
      } catch (e) {
        if (e != StopIteration) {
          throw e;
        }
      }
      return i;
    }
    var j = this.tok("prefix", str, i);
    if (j >= 0) {
      var t = new pyjslib_List([]);
      var i = this.qname(str, j, t);
      if (i < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "expected qname after @prefix");
      }
      var j = this.uri_ref2(str, i, t);
      if (j < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, i, "expected <uriref> after @prefix _qname_");
      }
      var ns3 = t[1].uri;
      if (this._baseURI) {
        var ns3 = uripath_join(this._baseURI, ns3);
      } else {
        assertFudge(ns3.indexOf(":") >= 0, "With no base URI, cannot handle relative URI for NS");
      }
      assertFudge(ns3.indexOf(":") >= 0);
      this._bindings[t[0][0]] = ns3;
      this.bind(t[0][0], hexify2(ns3));
      return j;
    }
    var j = this.tok("base", str, i);
    if (j >= 0) {
      var t = new pyjslib_List([]);
      var i = this.uri_ref2(str, j, t);
      if (i < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "expected <uri> after @base ");
      }
      var ns3 = t[0].uri;
      if (this._baseURI) {
        var ns3 = uripath_join(this._baseURI, ns3);
      } else {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "With no previous base URI, cannot use relative URI in @base  <" + ns3 + ">");
      }
      assertFudge(ns3.indexOf(":") >= 0);
      this._baseURI = ns3;
      return i;
    }
    return -1;
  }
  bind(qn, uri) {
    if (qn == "") {
    } else {
      this._store.setPrefixForURI(qn, uri);
    }
  }
  setKeywords(k) {
    if (k == null) {
      this.keywordsSet = 0;
    } else {
      this.keywords = k;
      this.keywordsSet = 1;
    }
  }
  startDoc() {
  }
  /* Signal end of document and stop parsing. returns formula */
  endDoc() {
    if (this.hasNil && this._store.rdfFactory.supports["COLLECTIONS"]) {
      convertFirstRestNil(this._store, this.source);
    }
    return this._formula;
  }
  makeStatement(quad3) {
    quad3[0].add(quad3[2], quad3[1], quad3[3], this.source);
    if (quad3[2].uri && quad3[2].uri === RDF_nil_URI || quad3[3].uri && quad3[3].uri === RDF_nil_URI) {
      this.hasNil = true;
    }
    this.statementCount += 1;
  }
  statement(str, i) {
    var r = new pyjslib_List([]);
    var i = this.object(str, i, r);
    if (i < 0) {
      return i;
    }
    var j = this.property_list(str, i, r[0]);
    if (j < 0) {
      throw BadSyntax(this._thisDoc, this.lines, str, i, "expected propertylist");
    }
    return j;
  }
  subject(str, i, res) {
    return this.item(str, i, res);
  }
  verb(str, i, res) {
    var j = this.skipSpace(str, i);
    if (j < 0) {
      return j;
    }
    var r = new pyjslib_List([]);
    var j = this.tok("has", str, i);
    if (j >= 0) {
      var i = this.prop(str, j, r);
      if (i < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "expected property after 'has'");
      }
      res.push(new pyjslib_Tuple(["->", r[0]]));
      return i;
    }
    var j = this.tok("is", str, i);
    if (j >= 0) {
      var i = this.prop(str, j, r);
      if (i < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "expected <property> after 'is'");
      }
      var j = this.skipSpace(str, i);
      if (j < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, i, "End of file found, expected property after 'is'");
        return j;
      }
      var i = j;
      var j = this.tok("of", str, i);
      if (j < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, i, "expected 'of' after 'is' <prop>");
      }
      res.push(new pyjslib_Tuple(["<-", r[0]]));
      return j;
    }
    var j = this.tok("a", str, i);
    if (j >= 0) {
      res.push(new pyjslib_Tuple(["->", this._store.sym(RDF_type_URI)]));
      return j;
    }
    if (str.slice(i, i + 2) == "<=") {
      res.push(new pyjslib_Tuple(["<-", this._store.sym(Logic_NS + "implies")]));
      return i + 2;
    }
    if (str.slice(i, i + 1) == "=") {
      if (str.slice(i + 1, i + 2) == ">") {
        res.push(new pyjslib_Tuple(["->", this._store.sym(Logic_NS + "implies")]));
        return i + 2;
      }
      res.push(new pyjslib_Tuple(["->", this._store.sym(DAML_sameAs_URI)]));
      return i + 1;
    }
    if (str.slice(i, i + 2) == ":=") {
      res.push(new pyjslib_Tuple(["->", Logic_NS + "becomes"]));
      return i + 2;
    }
    var j = this.prop(str, i, r);
    if (j >= 0) {
      res.push(new pyjslib_Tuple(["->", r[0]]));
      return j;
    }
    if (str.slice(i, i + 2) == ">-" || str.slice(i, i + 2) == "<-") {
      throw BadSyntax(this._thisDoc, this.lines, str, j, ">- ... -> syntax is obsolete.");
    }
    return -1;
  }
  prop(str, i, res) {
    return this.item(str, i, res);
  }
  item(str, i, res) {
    return this.path(str, i, res);
  }
  blankNode(uri) {
    return this._context.bnode(uri, this._reason2);
  }
  path(str, i, res) {
    var j = this.nodeOrLiteral(str, i, res);
    if (j < 0) {
      return j;
    }
    while ("!^.".indexOf(str.slice(j, j + 1)) >= 0) {
      var ch = str.slice(j, j + 1);
      if (ch == ".") {
        if (dotTerminatesName(str, j)) {
          break;
        }
      }
      var subj = res.pop();
      var obj = this.blankNode(this.here(j));
      var j = this.node(str, j + 1, res);
      if (j < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "EOF found in middle of path syntax");
      }
      var pred = res.pop();
      if (ch == "^") {
        this.makeStatement(new pyjslib_Tuple([this._context, pred, obj, subj]));
      } else {
        this.makeStatement(new pyjslib_Tuple([this._context, pred, subj, obj]));
      }
      res.push(obj);
    }
    return j;
  }
  anonymousNode(ln) {
    var term2 = this._anonymousNodes[ln];
    if (term2) {
      return term2;
    }
    var term2 = this._store.bnode(ln);
    this._anonymousNodes[ln] = term2;
    return term2;
  }
  node(str, i, res, subjectAlready) {
    if (typeof subjectAlready == "undefined") subjectAlready = null;
    var subj = subjectAlready;
    var j = this.skipSpace(str, i);
    if (j < 0) {
      return j;
    }
    var i = j;
    var ch = str.slice(i, i + 1);
    if (ch == "[") {
      var bnodeID = this.here(i);
      var j = this.skipSpace(str, i + 1);
      if (j < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, i, "EOF after '['");
      }
      if (str.slice(j, j + 1) == "=") {
        var i = j + 1;
        var objs = new pyjslib_List([]);
        var j = this.objectList(str, i, objs);
        if (j >= 0) {
          var subj = objs[0];
          if (pyjslib_len(objs) > 1) {
            var __obj = new pyjslib_Iterator(objs);
            try {
              while (true) {
                var obj = __obj.next();
                this.makeStatement(new pyjslib_Tuple([this._context, this._store.sym(DAML_sameAs_URI), subj, obj]));
              }
            } catch (e) {
              if (e != StopIteration) {
                throw e;
              }
            }
          }
          var j = this.skipSpace(str, j);
          if (j < 0) {
            throw BadSyntax(this._thisDoc, this.lines, str, i, "EOF when objectList expected after [ = ");
          }
          if (str.slice(j, j + 1) == ";") {
            var j = j + 1;
          }
        } else {
          throw BadSyntax(this._thisDoc, this.lines, str, i, "objectList expected after [= ");
        }
      }
      if (subj == null) {
        var subj = this.blankNode(bnodeID);
      }
      var i = this.property_list(str, j, subj);
      if (i < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "property_list expected");
      }
      var j = this.skipSpace(str, i);
      if (j < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, i, "EOF when ']' expected after [ <propertyList>");
      }
      if (str.slice(j, j + 1) == ".") {
        res.push(subj);
        return j;
      }
      if (str.slice(j, j + 1) != "]") {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "']' expected");
      }
      res.push(subj);
      return j + 1;
    }
    if (ch == "{") {
      var ch2 = str.slice(i + 1, i + 2);
      if (ch2 == "$") {
        i += 1;
        var j = i + 1;
        var mylist = new pyjslib_List([]);
        var first_run = true;
        while (1) {
          var i = this.skipSpace(str, j);
          if (i < 0) {
            throw BadSyntax(this._thisDoc, this.lines, str, i, "needed '$}', found end.");
          }
          if (str.slice(i, i + 2) == "$}") {
            var j = i + 2;
            break;
          }
          if (!first_run) {
            if (str.slice(i, i + 1) == ",") {
              i += 1;
            } else {
              throw BadSyntax(this._thisDoc, this.lines, str, i, "expected: ','");
            }
          } else {
            var first_run = false;
          }
          var item = new pyjslib_List([]);
          var j = this.item(str, i, item);
          if (j < 0) {
            throw BadSyntax(this._thisDoc, this.lines, str, i, "expected item in set or '$}'");
          }
          mylist.push(item[0]);
        }
        res.push(this._store.newSet(mylist, this._context));
        return j;
      } else {
        var j = i + 1;
        var oldParentContext = this._parentContext;
        this._parentContext = this._context;
        var parentAnonymousNodes = this._anonymousNodes;
        var grandParentVariables = this._parentVariables;
        this._parentVariables = this._variables;
        this._anonymousNodes = new pyjslib_Dict([]);
        this._variables = this._variables.slice();
        var reason2 = this._reason2;
        this._reason2 = becauseSubexpression;
        if (subj == null) {
          var subj = this._store.formula();
        }
        this._context = subj;
        while (1) {
          var i = this.skipSpace(str, j);
          if (i < 0) {
            throw BadSyntax(this._thisDoc, this.lines, str, i, "needed '}', found end.");
          }
          if (str.slice(i, i + 1) == "}") {
            var j = i + 1;
            break;
          }
          var j = this.directiveOrStatement(str, i);
          if (j < 0) {
            throw BadSyntax(this._thisDoc, this.lines, str, i, "expected statement or '}'");
          }
        }
        this._anonymousNodes = parentAnonymousNodes;
        this._variables = this._parentVariables;
        this._parentVariables = grandParentVariables;
        this._context = this._parentContext;
        this._reason2 = reason2;
        this._parentContext = oldParentContext;
        res.push(subj.close());
        return j;
      }
    }
    if (ch == "(") {
      var thing_type = this._store.list;
      var ch2 = str.slice(i + 1, i + 2);
      if (ch2 == "$") {
        var thing_type = this._store.newSet;
        i += 1;
      }
      var j = i + 1;
      var mylist = new pyjslib_List([]);
      while (1) {
        var i = this.skipSpace(str, j);
        if (i < 0) {
          throw BadSyntax(this._thisDoc, this.lines, str, i, "needed ')', found end.");
        }
        if (str.slice(i, i + 1) == ")") {
          var j = i + 1;
          break;
        }
        var item = new pyjslib_List([]);
        var j = this.item(str, i, item);
        if (j < 0) {
          throw BadSyntax(this._thisDoc, this.lines, str, i, "expected item in list or ')'");
        }
        mylist.push(item[0]);
      }
      res.push(thing_type(mylist, this._context));
      return j;
    }
    var j = this.tok("this", str, i);
    if (j >= 0) {
      throw BadSyntax(this._thisDoc, this.lines, str, i, "Keyword 'this' was ancient N3. Now use @forSome and @forAll keywords.");
      res.push(this._context);
      return j;
    }
    var j = this.tok("true", str, i);
    if (j >= 0) {
      res.push(true);
      return j;
    }
    var j = this.tok("false", str, i);
    if (j >= 0) {
      res.push(false);
      return j;
    }
    if (subj == null) {
      var j = this.uri_ref2(str, i, res);
      if (j >= 0) {
        return j;
      }
    }
    return -1;
  }
  property_list(str, i, subj) {
    while (1) {
      var j = this.skipSpace(str, i);
      if (j < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, i, "EOF found when expected verb in property list");
        return j;
      }
      if (str.slice(j, j + 2) == ":-") {
        var i = j + 2;
        var res = new pyjslib_List([]);
        var j = this.node(str, i, res, subj);
        if (j < 0) {
          throw BadSyntax(this._thisDoc, this.lines, str, i, "bad {} or () or [] node after :- ");
        }
        var i = j;
        continue;
      }
      var i = j;
      var v = new pyjslib_List([]);
      var j = this.verb(str, i, v);
      if (j <= 0) {
        return i;
      }
      var objs = new pyjslib_List([]);
      var i = this.objectList(str, j, objs);
      if (i < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "objectList expected");
      }
      var __obj = new pyjslib_Iterator(objs);
      try {
        while (true) {
          var obj = __obj.next();
          var pairFudge = v[0];
          var dir = pairFudge[0];
          var sym = pairFudge[1];
          if (dir == "->") {
            this.makeStatement(new pyjslib_Tuple([this._context, sym, subj, obj]));
          } else {
            this.makeStatement(new pyjslib_Tuple([this._context, sym, obj, subj]));
          }
        }
      } catch (e) {
        if (e != StopIteration) {
          throw e;
        }
      }
      var j = this.skipSpace(str, i);
      if (j < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "EOF found in list of objects");
        return j;
      }
      if (str.slice(i, i + 1) != ";") {
        return i;
      }
      var i = i + 1;
    }
  }
  commaSeparatedList(str, j, res, ofUris) {
    var i = this.skipSpace(str, j);
    if (i < 0) {
      throw BadSyntax(this._thisDoc, this.lines, str, i, "EOF found expecting comma sep list");
      return i;
    }
    if (str.charAt(i) == ".") {
      return j;
    }
    if (ofUris) {
      var i = this.uri_ref2(str, i, res);
    } else {
      var i = this.bareWord(str, i, res);
    }
    if (i < 0) {
      return -1;
    }
    while (1) {
      var j = this.skipSpace(str, i);
      if (j < 0) {
        return j;
      }
      var ch = str.slice(j, j + 1);
      if (ch != ",") {
        if (ch != ".") {
          return -1;
        }
        return j;
      }
      if (ofUris) {
        var i = this.uri_ref2(str, j + 1, res);
      } else {
        var i = this.bareWord(str, j + 1, res);
      }
      if (i < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, i, "bad list content");
        return i;
      }
    }
  }
  objectList(str, i, res) {
    var i = this.object(str, i, res);
    if (i < 0) {
      return -1;
    }
    while (1) {
      var j = this.skipSpace(str, i);
      if (j < 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, j, "EOF found after object");
        return j;
      }
      if (str.slice(j, j + 1) != ",") {
        return j;
      }
      var i = this.object(str, j + 1, res);
      if (i < 0) {
        return i;
      }
    }
  }
  checkDot(str, i) {
    var j = this.skipSpace(str, i);
    if (j < 0) {
      return j;
    }
    if (str.slice(j, j + 1) == ".") {
      return j + 1;
    }
    if (str.slice(j, j + 1) == "}") {
      return j;
    }
    if (str.slice(j, j + 1) == "]") {
      return j;
    }
    throw BadSyntax(this._thisDoc, this.lines, str, j, "expected '.' or '}' or ']' at end of statement");
    return i;
  }
  uri_ref2(str, i, res) {
    var qn = new pyjslib_List([]);
    var j = this.qname(str, i, qn);
    if (j >= 0) {
      var pairFudge = qn[0];
      var pfx = pairFudge[0];
      var ln = pairFudge[1];
      if (pfx == null) {
        assertFudge(0, "not used?");
        var ns3 = this._baseURI + ADDED_HASH;
      } else {
        var ns3 = this._bindings[pfx];
        if (!ns3) {
          if (pfx == "_") {
            res.push(this.anonymousNode(ln));
            return j;
          }
          throw BadSyntax(this._thisDoc, this.lines, str, i, "Prefix " + pfx + " not bound.");
        }
      }
      var symb = this._store.sym(ns3 + ln);
      if (ArrayIndexOf(this._variables, symb) >= 0) {
        res.push(this._variables[symb]);
      } else {
        res.push(symb);
      }
      return j;
    }
    var i = this.skipSpace(str, i);
    if (i < 0) {
      return -1;
    }
    if (str.charAt(i) == "?") {
      var v = new pyjslib_List([]);
      var j = this.variable(str, i, v);
      if (j > 0) {
        res.push(v[0]);
        return j;
      }
      return -1;
    } else if (str.charAt(i) == "<") {
      var i = i + 1;
      var st2 = i;
      while (i < pyjslib_len(str)) {
        if (str.charAt(i) == ">") {
          var uref = str.slice(st2, i);
          if (this._baseURI) {
            var uref = uripath_join(this._baseURI, uref);
          } else {
            assertFudge(uref.indexOf(":") >= 0, "With no base URI, cannot deal with relative URIs");
          }
          if (str.slice(i - 1, i) == "#" && !(pyjslib_slice(uref, -1, null) == "#")) {
            var uref = uref + "#";
          }
          var symb = this._store.sym(uref);
          if (ArrayIndexOf(this._variables, symb) >= 0) {
            res.push(this._variables[symb]);
          } else {
            res.push(symb);
          }
          return i + 1;
        }
        var i = i + 1;
      }
      throw BadSyntax(this._thisDoc, this.lines, str, j, "unterminated URI reference");
    } else if (this.keywordsSet) {
      var v = new pyjslib_List([]);
      var j = this.bareWord(str, i, v);
      if (j < 0) {
        return -1;
      }
      if (ArrayIndexOf(this.keywords, v[0]) >= 0) {
        throw BadSyntax(this._thisDoc, this.lines, str, i, 'Keyword "' + v[0] + '" not allowed here.');
      }
      res.push(this._store.sym(this._bindings[""] + v[0]));
      return j;
    } else {
      return -1;
    }
  }
  skipSpace(str, i) {
    var whitespace = " \n\r	\f\v            ​\u2028\u2029　";
    for (var j = i ? i : 0; j < str.length; j++) {
      var ch = str.charAt(j);
      if (whitespace.indexOf(ch) < 0) {
        if (str.charAt(j) === "#") {
          for (; ; j++) {
            if (j === str.length) {
              return -1;
            }
            if (str.charAt(j) === "\n") {
              this.lines = this.lines + 1;
              break;
            }
          }
          ;
        } else {
          return j;
        }
      } else {
        if (str.charAt(j) === "\n") {
          this.lines = this.lines + 1;
        }
      }
    }
    return -1;
  }
  variable(str, i, res) {
    var j = this.skipSpace(str, i);
    if (j < 0) {
      return -1;
    }
    if (str.slice(j, j + 1) != "?") {
      return -1;
    }
    var j = j + 1;
    var i = j;
    if ("0123456789-".indexOf(str.charAt(j)) >= 0) {
      throw BadSyntax(this._thisDoc, this.lines, str, j, "Varible name can't start with '" + str.charAt(j) + "s'");
      return -1;
    }
    while (i < pyjslib_len(str) && _notNameChars.indexOf(str.charAt(i)) < 0) {
      var i = i + 1;
    }
    if (this._parentContext == null) {
      throw BadSyntax(this._thisDoc, this.lines, str, j, "Can't use ?xxx syntax for variable in outermost level: " + str.slice(j - 1, i));
    }
    res.push(this._store.variable(str.slice(j, i)));
    return i;
  }
  bareWord(str, i, res) {
    var j = this.skipSpace(str, i);
    if (j < 0) {
      return -1;
    }
    var ch = str.charAt(j);
    if ("0123456789-".indexOf(ch) >= 0) {
      return -1;
    }
    if (_notNameChars.indexOf(ch) >= 0) {
      return -1;
    }
    var i = j;
    while (i < pyjslib_len(str)) {
      var c = str.charAt(i);
      if (c === ".") {
        if (dotTerminatesName(str, i)) {
          break;
        }
      } else if (_notNameChars.indexOf(c) >= 0) {
        break;
      }
      var i = i + 1;
    }
    res.push(str.slice(j, i));
    return i;
  }
  qname(str, i, res) {
    var i = this.skipSpace(str, i);
    if (i < 0) {
      return -1;
    }
    var c = str.charAt(i);
    if ("0123456789-+".indexOf(c) >= 0) {
      return -1;
    }
    if (_notNameChars.indexOf(c) < 0) {
      var ln = c;
      var i = i + 1;
      while (i < pyjslib_len(str)) {
        var c = str.charAt(i);
        if (c === ".") {
          if (dotTerminatesName(str, i)) {
            break;
          }
        } else if (_notNameChars.indexOf(c) >= 0) {
          break;
        }
        var ln = ln + c;
        var i = i + 1;
      }
    } else {
      var ln = "";
    }
    if (i < pyjslib_len(str) && str.charAt(i) == ":") {
      var pfx = ln;
      var i = i + 1;
      var ln = "";
      while (i < pyjslib_len(str)) {
        var c = str.charAt(i);
        if (c === ".") {
          if (dotTerminatesName(str, i)) {
            break;
          }
        } else if (_notNameChars.indexOf(c) >= 0) {
          break;
        }
        var ln = ln + c;
        var i = i + 1;
      }
      res.push(new pyjslib_Tuple([pfx, ln]));
      return i;
    } else {
      if (ln && this.keywordsSet && ArrayIndexOf(this.keywords, ln) < 0) {
        res.push(new pyjslib_Tuple(["", ln]));
        return i;
      }
      return -1;
    }
  }
  object(str, i, res) {
    var j = this.subject(str, i, res);
    if (j >= 0) {
      return j;
    } else {
      var j = this.skipSpace(str, i);
      if (j < 0) {
        return -1;
      } else {
        var i = j;
      }
      var delim = null;
      let ch = str.charAt(i);
      if (ch == '"' || ch == "'") {
        if (str.slice(i, i + 3 == ch + ch)) {
          delim = ch + ch + ch;
        } else {
          delim = ch;
        }
        var i = i + pyjslib_len(delim);
        var pairFudge = this.strconst(str, i, delim);
        var j = pairFudge[0];
        var s = pairFudge[1];
        res.push(this._store.literal(s));
        diag_progress("New string const ", s, j);
        return j;
      } else {
        return -1;
      }
    }
  }
  nodeOrLiteral(str, i, res) {
    var j = this.node(str, i, res);
    if (j >= 0) {
      return j;
    } else {
      var j = this.skipSpace(str, i);
      if (j < 0) {
        return -1;
      } else {
        var i = j;
      }
      var ch = str.charAt(i);
      if ("-+0987654321".indexOf(ch) >= 0) {
        datetime_syntax.lastIndex = 0;
        var m = datetime_syntax.exec(str.slice(i));
        if (m != null) {
          var val = m[0];
          j = i + val.length;
          if (val.indexOf("T") >= 0) {
            res.push(this._store.literal(val, this._store.sym(DATETIME_DATATYPE)));
          } else {
            res.push(this._store.literal(val, this._store.sym(DATE_DATATYPE)));
          }
        } else {
          number_syntax.lastIndex = 0;
          var m = number_syntax.exec(str.slice(i));
          if (m == null) {
            throw BadSyntax(this._thisDoc, this.lines, str, i, "Bad number or date syntax");
          }
          j = i + number_syntax.lastIndex;
          var val = str.slice(i, j);
          if (val.indexOf("e") >= 0) {
            res.push(this._store.literal(parseFloat(val), this._store.sym(FLOAT_DATATYPE)));
          } else if (str.slice(i, j).indexOf(".") >= 0) {
            res.push(this._store.literal(parseFloat(val), this._store.sym(DECIMAL_DATATYPE)));
          } else {
            res.push(this._store.literal(parseInt(val), this._store.sym(INTEGER_DATATYPE)));
          }
        }
        ;
        return j;
      }
      if (str.charAt(i) == '"') {
        if (str.slice(i, i + 3) == '"""') {
          var delim = '"""';
        } else {
          var delim = '"';
        }
        var i = i + pyjslib_len(delim);
        var dt = null;
        var pairFudge = this.strconst(str, i, delim);
        var j = pairFudge[0];
        var s = pairFudge[1];
        var lang = null;
        if (str.slice(j, j + 1) == "@") {
          langcode.lastIndex = 0;
          var m = langcode.exec(str.slice(j + 1));
          if (m == null) {
            throw BadSyntax(this._thisDoc, startline, str, i, "Bad language code syntax on string literal, after @");
          }
          var i = langcode.lastIndex + j + 1;
          var lang = str.slice(j + 1, i);
          var j = i;
        }
        if (str.slice(j, j + 2) == "^^") {
          var res2 = new pyjslib_List([]);
          var j = this.uri_ref2(str, j + 2, res2);
          var dt = res2[0];
        }
        res.push(this._store.literal(s, lang || dt));
        return j;
      } else {
        return -1;
      }
    }
  }
  strconst(str, i, delim) {
    var j = i;
    var ustr = "";
    var startline2 = this.lines;
    while (j < pyjslib_len(str)) {
      var i = j + pyjslib_len(delim);
      if (str.slice(j, i) == delim) {
        return new pyjslib_Tuple([i, ustr]);
      }
      if (str.charAt(j) == '"') {
        var ustr = ustr + '"';
        var j = j + 1;
        continue;
      }
      interesting.lastIndex = 0;
      var m = interesting.exec(str.slice(j));
      if (!m) {
        throw BadSyntax(this._thisDoc, startline2, str, j, "Closing quote missing in string at ^ in " + str.slice(j - 20, j) + "^" + str.slice(j, j + 20));
      }
      var i = j + interesting.lastIndex - 1;
      var ustr = ustr + str.slice(j, i);
      var ch = str.charAt(i);
      if (ch == '"') {
        var j = i;
        continue;
      } else if (ch == "\r") {
        var j = i + 1;
        continue;
      } else if (ch == "\n") {
        if (delim == '"') {
          throw BadSyntax(this._thisDoc, startline2, str, i, "newline found in string literal");
        }
        this.lines = this.lines + 1;
        var ustr = ustr + ch;
        var j = i + 1;
        this.previousLine = this.startOfLine;
        this.startOfLine = j;
      } else if (ch == "\\") {
        var j = i + 1;
        var ch = str.slice(j, j + 1);
        if (!ch) {
          throw BadSyntax(this._thisDoc, startline2, str, i, "unterminated string literal (2)");
        }
        var k = string_find('abfrtvn\\"', ch);
        if (k >= 0) {
          var uch = 'a\b\f\r	\v\n\\"'.charAt(k);
          var ustr = ustr + uch;
          var j = j + 1;
        } else if (ch == "u") {
          var pairFudge = this.uEscape(str, j + 1, startline2);
          var j = pairFudge[0];
          var ch = pairFudge[1];
          var ustr = ustr + ch;
        } else if (ch == "U") {
          var pairFudge = this.UEscape(str, j + 1, startline2);
          var j = pairFudge[0];
          var ch = pairFudge[1];
          var ustr = ustr + ch;
        } else {
          throw BadSyntax(this._thisDoc, this.lines, str, i, "bad escape");
        }
      }
    }
    throw BadSyntax(this._thisDoc, this.lines, str, i, "unterminated string literal");
  }
  uEscape(str, i, startline2) {
    var j = i;
    var count = 0;
    var value = 0;
    while (count < 4) {
      var chFudge = str.slice(j, j + 1);
      var ch = chFudge.toLowerCase();
      var j = j + 1;
      if (ch == "") {
        throw BadSyntax(this._thisDoc, startline2, str, i, "unterminated string literal(3)");
      }
      var k = string_find("0123456789abcdef", ch);
      if (k < 0) {
        throw BadSyntax(this._thisDoc, startline2, str, i, "bad string literal hex escape");
      }
      var value = value * 16 + k;
      var count = count + 1;
    }
    var uch = String.fromCharCode(value);
    return new pyjslib_Tuple([j, uch]);
  }
  UEscape(str, i, startline2) {
    var j = i;
    var count = 0;
    var value = "\\U";
    while (count < 8) {
      var chFudge = str.slice(j, j + 1);
      var ch = chFudge.toLowerCase();
      var j = j + 1;
      if (ch == "") {
        throw BadSyntax(this._thisDoc, startline2, str, i, "unterminated string literal(3)");
      }
      var k = string_find("0123456789abcdef", ch);
      if (k < 0) {
        throw BadSyntax(this._thisDoc, startline2, str, i, "bad string literal hex escape");
      }
      var value = value + ch;
      var count = count + 1;
    }
    var uch = stringFromCharCode("0x" + pyjslib_slice(value, 2, 10) - 0);
    return new pyjslib_Tuple([j, uch]);
  }
};
function __OLD_BadSyntax(uri, lines, str, i, why) {
  this._str = str.encode("utf-8");
  this._str = str;
  this._i = i;
  this._why = why;
  this.lines = lines;
  this._uri = uri;
}
__OLD_BadSyntax.prototype.toString = function() {
  var str = this._str;
  var i = this._i;
  var st2 = 0;
  if (i > 60) {
    var pre = "...";
    var st2 = i - 60;
  } else {
    var pre = "";
  }
  if (pyjslib_len(str) - i > 60) {
    var post = "...";
  } else {
    var post = "";
  }
  return 'Line %i of <%s>: Bad syntax (%s) at ^ in:\n"%s%s^%s%s"' % new pyjslib_Tuple([this.lines + 1, this._uri, this._why, pre, str.slice(st2, i), str.slice(i, i + 60), post]);
};
function BadSyntax(uri, lines, str, i, why) {
  let lineNo = lines + 1;
  let msg = "Line " + lineNo + " of <" + uri + ">: Bad syntax: " + why + '\nat: "' + str.slice(i, i + 30) + '"';
  let e = new SyntaxError(msg, uri, lineNo);
  e.lineNo = lineNo;
  e.characterInFile = i;
  e.syntaxProblem = why;
  return e;
}

// node_modules/rdflib/esm/factories/extended-term-factory.js
var ExtendedTermFactory = {
  ...canonical_data_factory_default,
  supports: {
    [Feature.collections]: true,
    [Feature.defaultGraphType]: false,
    [Feature.equalsMethod]: true,
    [Feature.identity]: false,
    [Feature.id]: true,
    [Feature.reversibleId]: false,
    [Feature.variableType]: true
  },
  /**
   * Creates a new collection
   * @param elements - The initial element
   */
  collection(elements) {
    return new Collection(elements);
  },
  id(term2) {
    if (isCollection(term2)) {
      return `( ${term2.elements.map((e) => {
        return this.id(e);
      }).join(", ")} )`;
    }
    if (isVariable(term2)) {
      return Variable.toString(term2);
    }
    return canonical_data_factory_default.id(term2);
  },
  termToNQ(term2) {
    if (term2.termType === CollectionTermType) {
      return Collection.toNT(term2);
    }
    return canonical_data_factory_default.termToNQ(term2);
  }
};
var extended_term_factory_default = ExtendedTermFactory;

// node_modules/rdflib/esm/jsonldparser.js
function jsonldObjectToTerm(kb, obj) {
  if (typeof obj === "string") {
    return kb.rdfFactory.literal(obj);
  }
  if (Object.prototype.hasOwnProperty.call(obj, "@list")) {
    if (kb.rdfFactory.supports["COLLECTIONS"] === true) {
      return listToCollection(kb, obj["@list"]);
    }
    return listToStatements(kb, obj);
  }
  if (Object.prototype.hasOwnProperty.call(obj, "@id")) {
    return nodeType(kb, obj);
  }
  if (Object.prototype.hasOwnProperty.call(obj, "@language")) {
    return kb.rdfFactory.literal(obj["@value"], obj["@language"]);
  }
  if (Object.prototype.hasOwnProperty.call(obj, "@type")) {
    return kb.rdfFactory.literal(obj["@value"], kb.rdfFactory.namedNode(obj["@type"]));
  }
  if (Object.prototype.hasOwnProperty.call(obj, "@value")) {
    return kb.rdfFactory.literal(obj["@value"]);
  }
  return kb.rdfFactory.literal(obj);
}
function listToStatements(kb, obj) {
  const listId = obj["@id"] ? nodeType(kb, obj) : kb.rdfFactory.blankNode();
  const items = obj["@list"].map((listItem) => jsonldObjectToTerm(kb, listItem));
  const statements = arrayToStatements(kb.rdfFactory, listId, items);
  kb.addAll(statements);
  return listId;
}
function listToCollection(kb, obj) {
  if (!Array.isArray(obj)) {
    throw new TypeError("Object must be an array");
  }
  return kb.rdfFactory.collection(obj.map((o) => jsonldObjectToTerm(kb, o)));
}
async function jsonldParser(str, kb, base) {
  const baseString = base && Object.prototype.hasOwnProperty.call(base, "termType") ? base.value : base;
  const jsonld = await import("./jsonld-7PDA6JOM.js");
  const flattened = await jsonld.default.flatten(JSON.parse(str), null, {
    base: baseString
  });
  return flattened.reduce((store, flatResource) => processResource(store, base, flatResource), kb);
}
function nodeType(kb, obj) {
  if (obj["@id"].startsWith("_:")) {
    return kb.rdfFactory.blankNode(obj["@id"].substring(2));
  } else {
    return kb.rdfFactory.namedNode(obj["@id"]);
  }
}
function processResource(kb, base, flatResource) {
  const id = flatResource["@id"] ? nodeType(kb, flatResource) : kb.rdfFactory.blankNode();
  for (const property of Object.keys(flatResource)) {
    if (property === "@id") {
      continue;
    } else if (property == "@graph") {
      const graphId = id;
      const nestedFlatResources = flatResource[property];
      for (let i = 0; i < nestedFlatResources.length; i++) {
        kb = processResource(kb, graphId, nestedFlatResources[i]);
      }
    }
    const value = flatResource[property];
    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        kb.addStatement(createStatement(kb, id, property, value[i], base));
      }
    } else {
      kb.addStatement(createStatement(kb, id, property, value, base));
    }
  }
  return kb;
}
function createStatement(kb, id, property, value, base) {
  let predicate, object;
  if (property === "@type") {
    predicate = kb.rdfFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
    object = kb.rdfFactory.namedNode(value);
  } else {
    predicate = kb.rdfFactory.namedNode(property);
    object = jsonldObjectToTerm(kb, value);
  }
  return kb.rdfFactory.quad(id, predicate, object, kb.rdfFactory.namedNode(base));
}

// node_modules/n3/src/N3Lexer.js
var import_buffer = __toESM(require_buffer());

// node_modules/n3/src/IRIs.js
var RDF2 = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
var XSD = "http://www.w3.org/2001/XMLSchema#";
var SWAP = "http://www.w3.org/2000/10/swap/";
var IRIs_default = {
  xsd: {
    decimal: `${XSD}decimal`,
    boolean: `${XSD}boolean`,
    double: `${XSD}double`,
    integer: `${XSD}integer`,
    string: `${XSD}string`
  },
  rdf: {
    type: `${RDF2}type`,
    nil: `${RDF2}nil`,
    first: `${RDF2}first`,
    rest: `${RDF2}rest`,
    langString: `${RDF2}langString`
  },
  owl: {
    sameAs: "http://www.w3.org/2002/07/owl#sameAs"
  },
  r: {
    forSome: `${SWAP}reify#forSome`,
    forAll: `${SWAP}reify#forAll`
  },
  log: {
    implies: `${SWAP}log#implies`,
    isImpliedBy: `${SWAP}log#isImpliedBy`
  }
};

// node_modules/n3/src/N3Lexer.js
var { xsd } = IRIs_default;
var escapeSequence = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g;
var escapeReplacements = {
  "\\": "\\",
  "'": "'",
  '"': '"',
  "n": "\n",
  "r": "\r",
  "t": "	",
  "f": "\f",
  "b": "\b",
  "_": "_",
  "~": "~",
  ".": ".",
  "-": "-",
  "!": "!",
  "$": "$",
  "&": "&",
  "(": "(",
  ")": ")",
  "*": "*",
  "+": "+",
  ",": ",",
  ";": ";",
  "=": "=",
  "/": "/",
  "?": "?",
  "#": "#",
  "@": "@",
  "%": "%"
};
var illegalIriChars = /[\x00-\x20<>\\"\{\}\|\^\`]/;
var lineModeRegExps = {
  _iri: true,
  _unescapedIri: true,
  _simpleQuotedString: true,
  _langcode: true,
  _blank: true,
  _newline: true,
  _comment: true,
  _whitespace: true,
  _endOfFile: true
};
var invalidRegExp = /$0^/;
var N3Lexer = class {
  constructor(options) {
    this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/;
    this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/;
    this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/;
    this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/;
    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i;
    this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/;
    this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/;
    this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/;
    this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/;
    this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/;
    this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/;
    this._keyword = /^@[a-z]+(?=[\s#<:])/i;
    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i;
    this._shortPredicates = /^a(?=[\s#()\[\]\{\}"'<>])/;
    this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/;
    this._comment = /#([^\n\r]*)/;
    this._whitespace = /^[ \t]+/;
    this._endOfFile = /^(?:#[^\n\r]*)?$/;
    options = options || {};
    this._isImpliedBy = options.isImpliedBy;
    if (this._lineMode = !!options.lineMode) {
      this._n3Mode = false;
      for (const key in this) {
        if (!(key in lineModeRegExps) && this[key] instanceof RegExp)
          this[key] = invalidRegExp;
      }
    } else {
      this._n3Mode = options.n3 !== false;
    }
    this.comments = !!options.comments;
    this._literalClosingPos = 0;
  }
  // ## Private methods
  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback
  _tokenizeToEnd(callback, inputFinished) {
    let input = this._input;
    let currentLineLength = input.length;
    while (true) {
      let whiteSpaceMatch, comment;
      while (whiteSpaceMatch = this._newline.exec(input)) {
        if (this.comments && (comment = this._comment.exec(whiteSpaceMatch[0])))
          emitToken("comment", comment[1], "", this._line, whiteSpaceMatch[0].length);
        input = input.substr(whiteSpaceMatch[0].length, input.length);
        currentLineLength = input.length;
        this._line++;
      }
      if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input)))
        input = input.substr(whiteSpaceMatch[0].length, input.length);
      if (this._endOfFile.test(input)) {
        if (inputFinished) {
          if (this.comments && (comment = this._comment.exec(input)))
            emitToken("comment", comment[1], "", this._line, input.length);
          input = null;
          emitToken("eof", "", "", this._line, 0);
        }
        return this._input = input;
      }
      const line = this._line, firstChar = input[0];
      let type = "", value = "", prefix = "", match = null, matchLength = 0, inconclusive = false;
      switch (firstChar) {
        case "^":
          if (input.length < 3)
            break;
          else if (input[1] === "^") {
            this._previousMarker = "^^";
            input = input.substr(2);
            if (input[0] !== "<") {
              inconclusive = true;
              break;
            }
          } else {
            if (this._n3Mode) {
              matchLength = 1;
              type = "^";
            }
            break;
          }
        // Fall through in case the type is an IRI
        case "<":
          if (match = this._unescapedIri.exec(input))
            type = "IRI", value = match[1];
          else if (match = this._iri.exec(input)) {
            value = this._unescape(match[1]);
            if (value === null || illegalIriChars.test(value))
              return reportSyntaxError(this);
            type = "IRI";
          } else if (input.length > 1 && input[1] === "<")
            type = "<<", matchLength = 2;
          else if (this._n3Mode && input.length > 1 && input[1] === "=") {
            matchLength = 2;
            if (this._isImpliedBy) type = "abbreviation", value = "<";
            else type = "inverse", value = ">";
          }
          break;
        case ">":
          if (input.length > 1 && input[1] === ">")
            type = ">>", matchLength = 2;
          break;
        case "_":
          if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(`${input} `)))
            type = "blank", prefix = "_", value = match[1];
          break;
        case '"':
          if (match = this._simpleQuotedString.exec(input))
            value = match[1];
          else {
            ({ value, matchLength } = this._parseLiteral(input));
            if (value === null)
              return reportSyntaxError(this);
          }
          if (match !== null || matchLength !== 0) {
            type = "literal";
            this._literalClosingPos = 0;
          }
          break;
        case "'":
          if (!this._lineMode) {
            if (match = this._simpleApostropheString.exec(input))
              value = match[1];
            else {
              ({ value, matchLength } = this._parseLiteral(input));
              if (value === null)
                return reportSyntaxError(this);
            }
            if (match !== null || matchLength !== 0) {
              type = "literal";
              this._literalClosingPos = 0;
            }
          }
          break;
        case "?":
          if (this._n3Mode && (match = this._variable.exec(input)))
            type = "var", value = match[0];
          break;
        case "@":
          if (this._previousMarker === "literal" && (match = this._langcode.exec(input)))
            type = "langcode", value = match[1];
          else if (match = this._keyword.exec(input))
            type = match[0];
          break;
        case ".":
          if (input.length === 1 ? inputFinished : input[1] < "0" || input[1] > "9") {
            type = ".";
            matchLength = 1;
            break;
          }
        // Fall through to numerical case (could be a decimal dot)
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        case "+":
        case "-":
          if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(`${input} `))) {
            type = "literal", value = match[0];
            prefix = typeof match[1] === "string" ? xsd.double : typeof match[2] === "string" ? xsd.decimal : xsd.integer;
          }
          break;
        case "B":
        case "b":
        case "p":
        case "P":
        case "G":
        case "g":
          if (match = this._sparqlKeyword.exec(input))
            type = match[0].toUpperCase();
          else
            inconclusive = true;
          break;
        case "f":
        case "t":
          if (match = this._boolean.exec(input))
            type = "literal", value = match[0], prefix = xsd.boolean;
          else
            inconclusive = true;
          break;
        case "a":
          if (match = this._shortPredicates.exec(input))
            type = "abbreviation", value = "a";
          else
            inconclusive = true;
          break;
        case "=":
          if (this._n3Mode && input.length > 1) {
            type = "abbreviation";
            if (input[1] !== ">")
              matchLength = 1, value = "=";
            else
              matchLength = 2, value = ">";
          }
          break;
        case "!":
          if (!this._n3Mode)
            break;
        case ",":
        case ";":
        case "[":
        case "]":
        case "(":
        case ")":
        case "}":
          if (!this._lineMode) {
            matchLength = 1;
            type = firstChar;
          }
          break;
        case "{":
          if (!this._lineMode && input.length >= 2) {
            if (input[1] === "|")
              type = "{|", matchLength = 2;
            else
              type = firstChar, matchLength = 1;
          }
          break;
        case "|":
          if (input.length >= 2 && input[1] === "}")
            type = "|}", matchLength = 2;
          break;
        default:
          inconclusive = true;
      }
      if (inconclusive) {
        if ((this._previousMarker === "@prefix" || this._previousMarker === "PREFIX") && (match = this._prefix.exec(input)))
          type = "prefix", value = match[1] || "";
        else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(`${input} `)))
          type = "prefixed", prefix = match[1] || "", value = this._unescape(match[2]);
      }
      if (this._previousMarker === "^^") {
        switch (type) {
          case "prefixed":
            type = "type";
            break;
          case "IRI":
            type = "typeIRI";
            break;
          default:
            type = "";
        }
      }
      if (!type) {
        if (inputFinished || !/^'''|^"""/.test(input) && /\n|\r/.test(input))
          return reportSyntaxError(this);
        else
          return this._input = input;
      }
      const length = matchLength || match[0].length;
      const token = emitToken(type, value, prefix, line, length);
      this.previousToken = token;
      this._previousMarker = type;
      input = input.substr(length, input.length);
    }
    function emitToken(type, value, prefix, line, length) {
      const start = input ? currentLineLength - input.length : currentLineLength;
      const end = start + length;
      const token = { type, value, prefix, line, start, end };
      callback(null, token);
      return token;
    }
    function reportSyntaxError(self2) {
      callback(self2._syntaxError(/^\S*/.exec(input)[0]));
    }
  }
  // ### `_unescape` replaces N3 escape codes by their corresponding characters
  _unescape(item) {
    let invalid = false;
    const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {
      if (typeof unicode4 === "string")
        return String.fromCharCode(Number.parseInt(unicode4, 16));
      if (typeof unicode8 === "string") {
        let charCode = Number.parseInt(unicode8, 16);
        return charCode <= 65535 ? String.fromCharCode(Number.parseInt(unicode8, 16)) : String.fromCharCode(55296 + ((charCode -= 65536) >> 10), 56320 + (charCode & 1023));
      }
      if (escapedChar in escapeReplacements)
        return escapeReplacements[escapedChar];
      invalid = true;
      return "";
    });
    return invalid ? null : replaced;
  }
  // ### `_parseLiteral` parses a literal into an unescaped value
  _parseLiteral(input) {
    if (input.length >= 3) {
      const opening = input.match(/^(?:"""|"|'''|'|)/)[0];
      const openingLength = opening.length;
      let closingPos = Math.max(this._literalClosingPos, openingLength);
      while ((closingPos = input.indexOf(opening, closingPos)) > 0) {
        let backslashCount = 0;
        while (input[closingPos - backslashCount - 1] === "\\")
          backslashCount++;
        if (backslashCount % 2 === 0) {
          const raw = input.substring(openingLength, closingPos);
          const lines = raw.split(/\r\n|\r|\n/).length - 1;
          const matchLength = closingPos + openingLength;
          if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode)
            break;
          this._line += lines;
          return { value: this._unescape(raw), matchLength };
        }
        closingPos++;
      }
      this._literalClosingPos = input.length - openingLength + 1;
    }
    return { value: "", matchLength: 0 };
  }
  // ### `_syntaxError` creates a syntax error for the given issue
  _syntaxError(issue) {
    this._input = null;
    const err = new Error(`Unexpected "${issue}" on line ${this._line}.`);
    err.context = {
      token: void 0,
      line: this._line,
      previousToken: this.previousToken
    };
    return err;
  }
  // ### Strips off any starting UTF BOM mark.
  _readStartingBom(input) {
    return input.startsWith("\uFEFF") ? input.substr(1) : input;
  }
  // ## Public methods
  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.
  // The input can be a string or a stream.
  tokenize(input, callback) {
    this._line = 1;
    if (typeof input === "string") {
      this._input = this._readStartingBom(input);
      if (typeof callback === "function")
        queueMicrotask(() => this._tokenizeToEnd(callback, true));
      else {
        const tokens = [];
        let error;
        this._tokenizeToEnd((e, t) => e ? error = e : tokens.push(t), true);
        if (error) throw error;
        return tokens;
      }
    } else {
      this._pendingBuffer = null;
      if (typeof input.setEncoding === "function")
        input.setEncoding("utf8");
      input.on("data", (data) => {
        if (this._input !== null && data.length !== 0) {
          if (this._pendingBuffer) {
            data = import_buffer.Buffer.concat([this._pendingBuffer, data]);
            this._pendingBuffer = null;
          }
          if (data[data.length - 1] & 128) {
            this._pendingBuffer = data;
          } else {
            if (typeof this._input === "undefined")
              this._input = this._readStartingBom(typeof data === "string" ? data : data.toString());
            else
              this._input += data;
            this._tokenizeToEnd(callback, false);
          }
        }
      });
      input.on("end", () => {
        if (typeof this._input === "string")
          this._tokenizeToEnd(callback, true);
      });
      input.on("error", callback);
    }
  }
};

// node_modules/n3/src/N3DataFactory.js
var { rdf: rdf2, xsd: xsd2 } = IRIs_default;
var DEFAULTGRAPH;
var _blankNodeCounter = 0;
var DataFactory = {
  namedNode: namedNode2,
  blankNode,
  variable,
  literal,
  defaultGraph: defaultGraph3,
  quad,
  triple: quad,
  fromTerm,
  fromQuad
};
var N3DataFactory_default = DataFactory;
var Term = class _Term {
  constructor(id) {
    this.id = id;
  }
  // ### The value of this term
  get value() {
    return this.id;
  }
  // ### Returns whether this object represents the same term as the other
  equals(other) {
    if (other instanceof _Term)
      return this.id === other.id;
    return !!other && this.termType === other.termType && this.value === other.value;
  }
  // ### Implement hashCode for Immutable.js, since we implement `equals`
  // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()
  hashCode() {
    return 0;
  }
  // ### Returns a plain object representation of this term
  toJSON() {
    return {
      termType: this.termType,
      value: this.value
    };
  }
};
var NamedNode2 = class extends Term {
  // ### The term type of this term
  get termType() {
    return "NamedNode";
  }
};
var Literal2 = class _Literal extends Term {
  // ### The term type of this term
  get termType() {
    return "Literal";
  }
  // ### The text value of this literal
  get value() {
    return this.id.substring(1, this.id.lastIndexOf('"'));
  }
  // ### The language of this literal
  get language() {
    const id = this.id;
    let atPos = id.lastIndexOf('"') + 1;
    return atPos < id.length && id[atPos++] === "@" ? id.substr(atPos).toLowerCase() : "";
  }
  // ### The datatype IRI of this literal
  get datatype() {
    return new NamedNode2(this.datatypeString);
  }
  // ### The datatype string of this literal
  get datatypeString() {
    const id = this.id, dtPos = id.lastIndexOf('"') + 1;
    const char = dtPos < id.length ? id[dtPos] : "";
    return char === "^" ? id.substr(dtPos + 2) : (
      // If "@" follows, return rdf:langString; xsd:string otherwise
      char !== "@" ? xsd2.string : rdf2.langString
    );
  }
  // ### Returns whether this object represents the same term as the other
  equals(other) {
    if (other instanceof _Literal)
      return this.id === other.id;
    return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;
  }
  toJSON() {
    return {
      termType: this.termType,
      value: this.value,
      language: this.language,
      datatype: { termType: "NamedNode", value: this.datatypeString }
    };
  }
};
var BlankNode2 = class extends Term {
  constructor(name) {
    super(`_:${name}`);
  }
  // ### The term type of this term
  get termType() {
    return "BlankNode";
  }
  // ### The name of this blank node
  get value() {
    return this.id.substr(2);
  }
};
var Variable2 = class extends Term {
  constructor(name) {
    super(`?${name}`);
  }
  // ### The term type of this term
  get termType() {
    return "Variable";
  }
  // ### The name of this variable
  get value() {
    return this.id.substr(1);
  }
};
var DefaultGraph2 = class extends Term {
  constructor() {
    super("");
    return DEFAULTGRAPH || this;
  }
  // ### The term type of this term
  get termType() {
    return "DefaultGraph";
  }
  // ### Returns whether this object represents the same term as the other
  equals(other) {
    return this === other || !!other && this.termType === other.termType;
  }
};
DEFAULTGRAPH = new DefaultGraph2();
var Quad = class extends Term {
  constructor(subject, predicate, object, graph2) {
    super("");
    this._subject = subject;
    this._predicate = predicate;
    this._object = object;
    this._graph = graph2 || DEFAULTGRAPH;
  }
  // ### The term type of this term
  get termType() {
    return "Quad";
  }
  get subject() {
    return this._subject;
  }
  get predicate() {
    return this._predicate;
  }
  get object() {
    return this._object;
  }
  get graph() {
    return this._graph;
  }
  // ### Returns a plain object representation of this quad
  toJSON() {
    return {
      termType: this.termType,
      subject: this._subject.toJSON(),
      predicate: this._predicate.toJSON(),
      object: this._object.toJSON(),
      graph: this._graph.toJSON()
    };
  }
  // ### Returns whether this object represents the same quad as the other
  equals(other) {
    return !!other && this._subject.equals(other.subject) && this._predicate.equals(other.predicate) && this._object.equals(other.object) && this._graph.equals(other.graph);
  }
};
function namedNode2(iri) {
  return new NamedNode2(iri);
}
function blankNode(name) {
  return new BlankNode2(name || `n3-${_blankNodeCounter++}`);
}
function literal(value, languageOrDataType) {
  if (typeof languageOrDataType === "string")
    return new Literal2(`"${value}"@${languageOrDataType.toLowerCase()}`);
  let datatype = languageOrDataType ? languageOrDataType.value : "";
  if (datatype === "") {
    if (typeof value === "boolean")
      datatype = xsd2.boolean;
    else if (typeof value === "number") {
      if (Number.isFinite(value))
        datatype = Number.isInteger(value) ? xsd2.integer : xsd2.double;
      else {
        datatype = xsd2.double;
        if (!Number.isNaN(value))
          value = value > 0 ? "INF" : "-INF";
      }
    }
  }
  return datatype === "" || datatype === xsd2.string ? new Literal2(`"${value}"`) : new Literal2(`"${value}"^^${datatype}`);
}
function variable(name) {
  return new Variable2(name);
}
function defaultGraph3() {
  return DEFAULTGRAPH;
}
function quad(subject, predicate, object, graph2) {
  return new Quad(subject, predicate, object, graph2);
}
function fromTerm(term2) {
  if (term2 instanceof Term)
    return term2;
  switch (term2.termType) {
    case "NamedNode":
      return namedNode2(term2.value);
    case "BlankNode":
      return blankNode(term2.value);
    case "Variable":
      return variable(term2.value);
    case "DefaultGraph":
      return DEFAULTGRAPH;
    case "Literal":
      return literal(term2.value, term2.language || term2.datatype);
    case "Quad":
      return fromQuad(term2);
    default:
      throw new Error(`Unexpected termType: ${term2.termType}`);
  }
}
function fromQuad(inQuad) {
  if (inQuad instanceof Quad)
    return inQuad;
  if (inQuad.termType !== "Quad")
    throw new Error(`Unexpected termType: ${inQuad.termType}`);
  return quad(fromTerm(inQuad.subject), fromTerm(inQuad.predicate), fromTerm(inQuad.object), fromTerm(inQuad.graph));
}

// node_modules/n3/src/N3Parser.js
var blankNodePrefix = 0;
var N3Parser = class {
  constructor(options) {
    this._contextStack = [];
    this._graph = null;
    options = options || {};
    this._setBase(options.baseIRI);
    options.factory && initDataFactory(this, options.factory);
    const format = typeof options.format === "string" ? options.format.match(/\w*$/)[0].toLowerCase() : "", isTurtle = /turtle/.test(format), isTriG = /trig/.test(format), isNTriples = /triple/.test(format), isNQuads = /quad/.test(format), isN3 = this._n3Mode = /n3/.test(format), isLineMode = isNTriples || isNQuads;
    if (!(this._supportsNamedGraphs = !(isTurtle || isN3)))
      this._readPredicateOrNamedGraph = this._readPredicate;
    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);
    this._isImpliedBy = options.isImpliedBy;
    this._supportsRDFStar = format === "" || /star|\*$/.test(format);
    if (isLineMode)
      this._resolveRelativeIRI = (iri) => {
        return null;
      };
    this._blankNodePrefix = typeof options.blankNodePrefix !== "string" ? "" : options.blankNodePrefix.replace(/^(?!_:)/, "_:");
    this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode, n3: isN3, isImpliedBy: this._isImpliedBy });
    this._explicitQuantifiers = !!options.explicitQuantifiers;
  }
  // ## Static class methods
  // ### `_resetBlankNodePrefix` restarts blank node prefix identification
  static _resetBlankNodePrefix() {
    blankNodePrefix = 0;
  }
  // ## Private methods
  // ### `_setBase` sets the base IRI to resolve relative IRIs
  _setBase(baseIRI) {
    if (!baseIRI) {
      this._base = "";
      this._basePath = "";
    } else {
      const fragmentPos = baseIRI.indexOf("#");
      if (fragmentPos >= 0)
        baseIRI = baseIRI.substr(0, fragmentPos);
      this._base = baseIRI;
      this._basePath = baseIRI.indexOf("/") < 0 ? baseIRI : baseIRI.replace(/[^\/?]*(?:\?.*)?$/, "");
      baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i);
      this._baseRoot = baseIRI[0];
      this._baseScheme = baseIRI[1];
    }
  }
  // ### `_saveContext` stores the current parsing context
  // when entering a new scope (list, blank node, formula)
  _saveContext(type, graph2, subject, predicate, object) {
    const n3Mode = this._n3Mode;
    this._contextStack.push({
      type,
      subject,
      predicate,
      object,
      graph: graph2,
      inverse: n3Mode ? this._inversePredicate : false,
      blankPrefix: n3Mode ? this._prefixes._ : "",
      quantified: n3Mode ? this._quantified : null
    });
    if (n3Mode) {
      this._inversePredicate = false;
      this._prefixes._ = this._graph ? `${this._graph.value}.` : ".";
      this._quantified = Object.create(this._quantified);
    }
  }
  // ### `_restoreContext` restores the parent context
  // when leaving a scope (list, blank node, formula)
  _restoreContext(type, token) {
    const context = this._contextStack.pop();
    if (!context || context.type !== type)
      return this._error(`Unexpected ${token.type}`, token);
    this._subject = context.subject;
    this._predicate = context.predicate;
    this._object = context.object;
    this._graph = context.graph;
    if (this._n3Mode) {
      this._inversePredicate = context.inverse;
      this._prefixes._ = context.blankPrefix;
      this._quantified = context.quantified;
    }
  }
  // ### `_readInTopContext` reads a token when in the top context
  _readInTopContext(token) {
    switch (token.type) {
      // If an EOF token arrives in the top context, signal that we're done
      case "eof":
        if (this._graph !== null)
          return this._error("Unclosed graph", token);
        delete this._prefixes._;
        return this._callback(null, null, this._prefixes);
      // It could be a prefix declaration
      case "PREFIX":
        this._sparqlStyle = true;
      case "@prefix":
        return this._readPrefix;
      // It could be a base declaration
      case "BASE":
        this._sparqlStyle = true;
      case "@base":
        return this._readBaseIRI;
      // It could be a graph
      case "{":
        if (this._supportsNamedGraphs) {
          this._graph = "";
          this._subject = null;
          return this._readSubject;
        }
      case "GRAPH":
        if (this._supportsNamedGraphs)
          return this._readNamedGraphLabel;
      // Otherwise, the next token must be a subject
      default:
        return this._readSubject(token);
    }
  }
  // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable
  _readEntity(token, quantifier) {
    let value;
    switch (token.type) {
      // Read a relative or absolute IRI
      case "IRI":
      case "typeIRI":
        const iri = this._resolveIRI(token.value);
        if (iri === null)
          return this._error("Invalid IRI", token);
        value = this._factory.namedNode(iri);
        break;
      // Read a prefixed name
      case "type":
      case "prefixed":
        const prefix = this._prefixes[token.prefix];
        if (prefix === void 0)
          return this._error(`Undefined prefix "${token.prefix}:"`, token);
        value = this._factory.namedNode(prefix + token.value);
        break;
      // Read a blank node
      case "blank":
        value = this._factory.blankNode(this._prefixes[token.prefix] + token.value);
        break;
      // Read a variable
      case "var":
        value = this._factory.variable(token.value.substr(1));
        break;
      // Everything else is not an entity
      default:
        return this._error(`Expected entity but got ${token.type}`, token);
    }
    if (!quantifier && this._n3Mode && value.id in this._quantified)
      value = this._quantified[value.id];
    return value;
  }
  // ### `_readSubject` reads a quad's subject
  _readSubject(token) {
    this._predicate = null;
    switch (token.type) {
      case "[":
        this._saveContext(
          "blank",
          this._graph,
          this._subject = this._factory.blankNode(),
          null,
          null
        );
        return this._readBlankNodeHead;
      case "(":
        this._saveContext("list", this._graph, this.RDF_NIL, null, null);
        this._subject = null;
        return this._readListItem;
      case "{":
        if (!this._n3Mode)
          return this._error("Unexpected graph", token);
        this._saveContext(
          "formula",
          this._graph,
          this._graph = this._factory.blankNode(),
          null,
          null
        );
        return this._readSubject;
      case "}":
        return this._readPunctuation(token);
      case "@forSome":
        if (!this._n3Mode)
          return this._error('Unexpected "@forSome"', token);
        this._subject = null;
        this._predicate = this.N3_FORSOME;
        this._quantifier = "blankNode";
        return this._readQuantifierList;
      case "@forAll":
        if (!this._n3Mode)
          return this._error('Unexpected "@forAll"', token);
        this._subject = null;
        this._predicate = this.N3_FORALL;
        this._quantifier = "variable";
        return this._readQuantifierList;
      case "literal":
        if (!this._n3Mode)
          return this._error("Unexpected literal", token);
        if (token.prefix.length === 0) {
          this._literalValue = token.value;
          return this._completeSubjectLiteral;
        } else
          this._subject = this._factory.literal(token.value, this._factory.namedNode(token.prefix));
        break;
      case "<<":
        if (!this._supportsRDFStar)
          return this._error("Unexpected RDF-star syntax", token);
        this._saveContext("<<", this._graph, null, null, null);
        this._graph = null;
        return this._readSubject;
      default:
        if ((this._subject = this._readEntity(token)) === void 0)
          return;
        if (this._n3Mode)
          return this._getPathReader(this._readPredicateOrNamedGraph);
    }
    return this._readPredicateOrNamedGraph;
  }
  // ### `_readPredicate` reads a quad's predicate
  _readPredicate(token) {
    const type = token.type;
    switch (type) {
      case "inverse":
        this._inversePredicate = true;
      case "abbreviation":
        this._predicate = this.ABBREVIATIONS[token.value];
        break;
      case ".":
      case "]":
      case "}":
        if (this._predicate === null)
          return this._error(`Unexpected ${type}`, token);
        this._subject = null;
        return type === "]" ? this._readBlankNodeTail(token) : this._readPunctuation(token);
      case ";":
        return this._predicate !== null ? this._readPredicate : this._error("Expected predicate but got ;", token);
      case "[":
        if (this._n3Mode) {
          this._saveContext(
            "blank",
            this._graph,
            this._subject,
            this._subject = this._factory.blankNode(),
            null
          );
          return this._readBlankNodeHead;
        }
      case "blank":
        if (!this._n3Mode)
          return this._error("Disallowed blank node as predicate", token);
      default:
        if ((this._predicate = this._readEntity(token)) === void 0)
          return;
    }
    return this._readObject;
  }
  // ### `_readObject` reads a quad's object
  _readObject(token) {
    switch (token.type) {
      case "literal":
        if (token.prefix.length === 0) {
          this._literalValue = token.value;
          return this._readDataTypeOrLang;
        } else
          this._object = this._factory.literal(token.value, this._factory.namedNode(token.prefix));
        break;
      case "[":
        this._saveContext(
          "blank",
          this._graph,
          this._subject,
          this._predicate,
          this._subject = this._factory.blankNode()
        );
        return this._readBlankNodeHead;
      case "(":
        this._saveContext("list", this._graph, this._subject, this._predicate, this.RDF_NIL);
        this._subject = null;
        return this._readListItem;
      case "{":
        if (!this._n3Mode)
          return this._error("Unexpected graph", token);
        this._saveContext(
          "formula",
          this._graph,
          this._subject,
          this._predicate,
          this._graph = this._factory.blankNode()
        );
        return this._readSubject;
      case "<<":
        if (!this._supportsRDFStar)
          return this._error("Unexpected RDF-star syntax", token);
        this._saveContext("<<", this._graph, this._subject, this._predicate, null);
        this._graph = null;
        return this._readSubject;
      default:
        if ((this._object = this._readEntity(token)) === void 0)
          return;
        if (this._n3Mode)
          return this._getPathReader(this._getContextEndReader());
    }
    return this._getContextEndReader();
  }
  // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph
  _readPredicateOrNamedGraph(token) {
    return token.type === "{" ? this._readGraph(token) : this._readPredicate(token);
  }
  // ### `_readGraph` reads a graph
  _readGraph(token) {
    if (token.type !== "{")
      return this._error(`Expected graph but got ${token.type}`, token);
    this._graph = this._subject, this._subject = null;
    return this._readSubject;
  }
  // ### `_readBlankNodeHead` reads the head of a blank node
  _readBlankNodeHead(token) {
    if (token.type === "]") {
      this._subject = null;
      return this._readBlankNodeTail(token);
    } else {
      this._predicate = null;
      return this._readPredicate(token);
    }
  }
  // ### `_readBlankNodeTail` reads the end of a blank node
  _readBlankNodeTail(token) {
    if (token.type !== "]")
      return this._readBlankNodePunctuation(token);
    if (this._subject !== null)
      this._emit(this._subject, this._predicate, this._object, this._graph);
    const empty = this._predicate === null;
    this._restoreContext("blank", token);
    if (this._object !== null)
      return this._getContextEndReader();
    else if (this._predicate !== null)
      return this._readObject;
    else
      return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;
  }
  // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node
  _readPredicateAfterBlank(token) {
    switch (token.type) {
      case ".":
      case "}":
        this._subject = null;
        return this._readPunctuation(token);
      default:
        return this._readPredicate(token);
    }
  }
  // ### `_readListItem` reads items from a list
  _readListItem(token) {
    let item = null, list = null, next = this._readListItem;
    const previousList = this._subject, stack = this._contextStack, parent = stack[stack.length - 1];
    switch (token.type) {
      case "[":
        this._saveContext(
          "blank",
          this._graph,
          list = this._factory.blankNode(),
          this.RDF_FIRST,
          this._subject = item = this._factory.blankNode()
        );
        next = this._readBlankNodeHead;
        break;
      case "(":
        this._saveContext(
          "list",
          this._graph,
          list = this._factory.blankNode(),
          this.RDF_FIRST,
          this.RDF_NIL
        );
        this._subject = null;
        break;
      case ")":
        this._restoreContext("list", token);
        if (stack.length !== 0 && stack[stack.length - 1].type === "list")
          this._emit(this._subject, this._predicate, this._object, this._graph);
        if (this._predicate === null) {
          next = this._readPredicate;
          if (this._subject === this.RDF_NIL)
            return next;
        } else {
          next = this._getContextEndReader();
          if (this._object === this.RDF_NIL)
            return next;
        }
        list = this.RDF_NIL;
        break;
      case "literal":
        if (token.prefix.length === 0) {
          this._literalValue = token.value;
          next = this._readListItemDataTypeOrLang;
        } else {
          item = this._factory.literal(token.value, this._factory.namedNode(token.prefix));
          next = this._getContextEndReader();
        }
        break;
      case "{":
        if (!this._n3Mode)
          return this._error("Unexpected graph", token);
        this._saveContext(
          "formula",
          this._graph,
          this._subject,
          this._predicate,
          this._graph = this._factory.blankNode()
        );
        return this._readSubject;
      default:
        if ((item = this._readEntity(token)) === void 0)
          return;
    }
    if (list === null)
      this._subject = list = this._factory.blankNode();
    if (previousList === null) {
      if (parent.predicate === null)
        parent.subject = list;
      else
        parent.object = list;
    } else {
      this._emit(previousList, this.RDF_REST, list, this._graph);
    }
    if (item !== null) {
      if (this._n3Mode && (token.type === "IRI" || token.type === "prefixed")) {
        this._saveContext("item", this._graph, list, this.RDF_FIRST, item);
        this._subject = item, this._predicate = null;
        return this._getPathReader(this._readListItem);
      }
      this._emit(list, this.RDF_FIRST, item, this._graph);
    }
    return next;
  }
  // ### `_readDataTypeOrLang` reads an _optional_ datatype or language
  _readDataTypeOrLang(token) {
    return this._completeObjectLiteral(token, false);
  }
  // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list
  _readListItemDataTypeOrLang(token) {
    return this._completeObjectLiteral(token, true);
  }
  // ### `_completeLiteral` completes a literal with an optional datatype or language
  _completeLiteral(token) {
    let literal3 = this._factory.literal(this._literalValue);
    switch (token.type) {
      // Create a datatyped literal
      case "type":
      case "typeIRI":
        const datatype = this._readEntity(token);
        if (datatype === void 0) return;
        literal3 = this._factory.literal(this._literalValue, datatype);
        token = null;
        break;
      // Create a language-tagged string
      case "langcode":
        literal3 = this._factory.literal(this._literalValue, token.value);
        token = null;
        break;
    }
    return { token, literal: literal3 };
  }
  // Completes a literal in subject position
  _completeSubjectLiteral(token) {
    this._subject = this._completeLiteral(token).literal;
    return this._readPredicateOrNamedGraph;
  }
  // Completes a literal in object position
  _completeObjectLiteral(token, listItem) {
    const completed = this._completeLiteral(token);
    if (!completed)
      return;
    this._object = completed.literal;
    if (listItem)
      this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);
    if (completed.token === null)
      return this._getContextEndReader();
    else {
      this._readCallback = this._getContextEndReader();
      return this._readCallback(completed.token);
    }
  }
  // ### `_readFormulaTail` reads the end of a formula
  _readFormulaTail(token) {
    if (token.type !== "}")
      return this._readPunctuation(token);
    if (this._subject !== null)
      this._emit(this._subject, this._predicate, this._object, this._graph);
    this._restoreContext("formula", token);
    return this._object === null ? this._readPredicate : this._getContextEndReader();
  }
  // ### `_readPunctuation` reads punctuation between quads or quad parts
  _readPunctuation(token) {
    let next, graph2 = this._graph;
    const subject = this._subject, inversePredicate = this._inversePredicate;
    switch (token.type) {
      // A closing brace ends a graph
      case "}":
        if (this._graph === null)
          return this._error("Unexpected graph closing", token);
        if (this._n3Mode)
          return this._readFormulaTail(token);
        this._graph = null;
      // A dot just ends the statement, without sharing anything with the next
      case ".":
        this._subject = null;
        next = this._contextStack.length ? this._readSubject : this._readInTopContext;
        if (inversePredicate) this._inversePredicate = false;
        break;
      // Semicolon means the subject is shared; predicate and object are different
      case ";":
        next = this._readPredicate;
        break;
      // Comma means both the subject and predicate are shared; the object is different
      case ",":
        next = this._readObject;
        break;
      // {| means that the current triple is annotated with predicate-object pairs.
      case "{|":
        if (!this._supportsRDFStar)
          return this._error("Unexpected RDF-star syntax", token);
        const predicate = this._predicate, object = this._object;
        this._subject = this._factory.quad(subject, predicate, object, this.DEFAULTGRAPH);
        next = this._readPredicate;
        break;
      // |} means that the current quoted triple in annotation syntax is finalized.
      case "|}":
        if (this._subject.termType !== "Quad")
          return this._error("Unexpected asserted triple closing", token);
        this._subject = null;
        next = this._readPunctuation;
        break;
      default:
        if (this._supportsQuads && this._graph === null && (graph2 = this._readEntity(token)) !== void 0) {
          next = this._readQuadPunctuation;
          break;
        }
        return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
    }
    if (subject !== null) {
      const predicate = this._predicate, object = this._object;
      if (!inversePredicate)
        this._emit(subject, predicate, object, graph2);
      else
        this._emit(object, predicate, subject, graph2);
    }
    return next;
  }
  // ### `_readBlankNodePunctuation` reads punctuation in a blank node
  _readBlankNodePunctuation(token) {
    let next;
    switch (token.type) {
      // Semicolon means the subject is shared; predicate and object are different
      case ";":
        next = this._readPredicate;
        break;
      // Comma means both the subject and predicate are shared; the object is different
      case ",":
        next = this._readObject;
        break;
      default:
        return this._error(`Expected punctuation to follow "${this._object.id}"`, token);
    }
    this._emit(this._subject, this._predicate, this._object, this._graph);
    return next;
  }
  // ### `_readQuadPunctuation` reads punctuation after a quad
  _readQuadPunctuation(token) {
    if (token.type !== ".")
      return this._error("Expected dot to follow quad", token);
    return this._readInTopContext;
  }
  // ### `_readPrefix` reads the prefix of a prefix declaration
  _readPrefix(token) {
    if (token.type !== "prefix")
      return this._error("Expected prefix to follow @prefix", token);
    this._prefix = token.value;
    return this._readPrefixIRI;
  }
  // ### `_readPrefixIRI` reads the IRI of a prefix declaration
  _readPrefixIRI(token) {
    if (token.type !== "IRI")
      return this._error(`Expected IRI to follow prefix "${this._prefix}:"`, token);
    const prefixNode = this._readEntity(token);
    this._prefixes[this._prefix] = prefixNode.value;
    this._prefixCallback(this._prefix, prefixNode);
    return this._readDeclarationPunctuation;
  }
  // ### `_readBaseIRI` reads the IRI of a base declaration
  _readBaseIRI(token) {
    const iri = token.type === "IRI" && this._resolveIRI(token.value);
    if (!iri)
      return this._error("Expected valid IRI to follow base declaration", token);
    this._setBase(iri);
    return this._readDeclarationPunctuation;
  }
  // ### `_readNamedGraphLabel` reads the label of a named graph
  _readNamedGraphLabel(token) {
    switch (token.type) {
      case "IRI":
      case "blank":
      case "prefixed":
        return this._readSubject(token), this._readGraph;
      case "[":
        return this._readNamedGraphBlankLabel;
      default:
        return this._error("Invalid graph label", token);
    }
  }
  // ### `_readNamedGraphLabel` reads a blank node label of a named graph
  _readNamedGraphBlankLabel(token) {
    if (token.type !== "]")
      return this._error("Invalid graph label", token);
    this._subject = this._factory.blankNode();
    return this._readGraph;
  }
  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration
  _readDeclarationPunctuation(token) {
    if (this._sparqlStyle) {
      this._sparqlStyle = false;
      return this._readInTopContext(token);
    }
    if (token.type !== ".")
      return this._error("Expected declaration to end with a dot", token);
    return this._readInTopContext;
  }
  // Reads a list of quantified symbols from a @forSome or @forAll statement
  _readQuantifierList(token) {
    let entity;
    switch (token.type) {
      case "IRI":
      case "prefixed":
        if ((entity = this._readEntity(token, true)) !== void 0)
          break;
      default:
        return this._error(`Unexpected ${token.type}`, token);
    }
    if (!this._explicitQuantifiers)
      this._quantified[entity.id] = this._factory[this._quantifier](this._factory.blankNode().value);
    else {
      if (this._subject === null)
        this._emit(
          this._graph || this.DEFAULTGRAPH,
          this._predicate,
          this._subject = this._factory.blankNode(),
          this.QUANTIFIERS_GRAPH
        );
      else
        this._emit(
          this._subject,
          this.RDF_REST,
          this._subject = this._factory.blankNode(),
          this.QUANTIFIERS_GRAPH
        );
      this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);
    }
    return this._readQuantifierPunctuation;
  }
  // Reads punctuation from a @forSome or @forAll statement
  _readQuantifierPunctuation(token) {
    if (token.type === ",")
      return this._readQuantifierList;
    else {
      if (this._explicitQuantifiers) {
        this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);
        this._subject = null;
      }
      this._readCallback = this._getContextEndReader();
      return this._readCallback(token);
    }
  }
  // ### `_getPathReader` reads a potential path and then resumes with the given function
  _getPathReader(afterPath) {
    this._afterPath = afterPath;
    return this._readPath;
  }
  // ### `_readPath` reads a potential path
  _readPath(token) {
    switch (token.type) {
      // Forward path
      case "!":
        return this._readForwardPath;
      // Backward path
      case "^":
        return this._readBackwardPath;
      // Not a path; resume reading where we left off
      default:
        const stack = this._contextStack, parent = stack.length && stack[stack.length - 1];
        if (parent && parent.type === "item") {
          const item = this._subject;
          this._restoreContext("item", token);
          this._emit(this._subject, this.RDF_FIRST, item, this._graph);
        }
        return this._afterPath(token);
    }
  }
  // ### `_readForwardPath` reads a '!' path
  _readForwardPath(token) {
    let subject, predicate;
    const object = this._factory.blankNode();
    if ((predicate = this._readEntity(token)) === void 0)
      return;
    if (this._predicate === null)
      subject = this._subject, this._subject = object;
    else
      subject = this._object, this._object = object;
    this._emit(subject, predicate, object, this._graph);
    return this._readPath;
  }
  // ### `_readBackwardPath` reads a '^' path
  _readBackwardPath(token) {
    const subject = this._factory.blankNode();
    let predicate, object;
    if ((predicate = this._readEntity(token)) === void 0)
      return;
    if (this._predicate === null)
      object = this._subject, this._subject = subject;
    else
      object = this._object, this._object = subject;
    this._emit(subject, predicate, object, this._graph);
    return this._readPath;
  }
  // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF-star quad or the end of a nested RDF-star triple
  _readRDFStarTailOrGraph(token) {
    if (token.type !== ">>") {
      if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== void 0)
        return this._readRDFStarTail;
      return this._error(`Expected >> to follow "${this._object.id}"`, token);
    }
    return this._readRDFStarTail(token);
  }
  // ### `_readRDFStarTail` reads the end of a nested RDF-star triple
  _readRDFStarTail(token) {
    if (token.type !== ">>")
      return this._error(`Expected >> but got ${token.type}`, token);
    const quad3 = this._factory.quad(
      this._subject,
      this._predicate,
      this._object,
      this._graph || this.DEFAULTGRAPH
    );
    this._restoreContext("<<", token);
    if (this._subject === null) {
      this._subject = quad3;
      return this._readPredicate;
    } else {
      this._object = quad3;
      return this._getContextEndReader();
    }
  }
  // ### `_getContextEndReader` gets the next reader function at the end of a context
  _getContextEndReader() {
    const contextStack = this._contextStack;
    if (!contextStack.length)
      return this._readPunctuation;
    switch (contextStack[contextStack.length - 1].type) {
      case "blank":
        return this._readBlankNodeTail;
      case "list":
        return this._readListItem;
      case "formula":
        return this._readFormulaTail;
      case "<<":
        return this._readRDFStarTailOrGraph;
    }
  }
  // ### `_emit` sends a quad through the callback
  _emit(subject, predicate, object, graph2) {
    this._callback(null, this._factory.quad(subject, predicate, object, graph2 || this.DEFAULTGRAPH));
  }
  // ### `_error` emits an error message through the callback
  _error(message, token) {
    const err = new Error(`${message} on line ${token.line}.`);
    err.context = {
      token,
      line: token.line,
      previousToken: this._lexer.previousToken
    };
    this._callback(err);
    this._callback = noop;
  }
  // ### `_resolveIRI` resolves an IRI against the base path
  _resolveIRI(iri) {
    return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);
  }
  // ### `_resolveRelativeIRI` resolves an IRI against the base path,
  // assuming that a base path has been set and that the IRI is indeed relative
  _resolveRelativeIRI(iri) {
    if (!iri.length)
      return this._base;
    switch (iri[0]) {
      // Resolve relative fragment IRIs against the base IRI
      case "#":
        return this._base + iri;
      // Resolve relative query string IRIs by replacing the query string
      case "?":
        return this._base.replace(/(?:\?.*)?$/, iri);
      // Resolve root-relative IRIs at the root of the base IRI
      case "/":
        return (iri[1] === "/" ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);
      // Resolve all other IRIs at the base IRI's path
      default:
        return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);
    }
  }
  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986
  _removeDotSegments(iri) {
    if (!/(^|\/)\.\.?($|[/#?])/.test(iri))
      return iri;
    const length = iri.length;
    let result = "", i = -1, pathStart = -1, segmentStart = 0, next = "/";
    while (i < length) {
      switch (next) {
        // The path starts with the first slash after the authority
        case ":":
          if (pathStart < 0) {
            if (iri[++i] === "/" && iri[++i] === "/")
              while ((pathStart = i + 1) < length && iri[pathStart] !== "/")
                i = pathStart;
          }
          break;
        // Don't modify a query string or fragment
        case "?":
        case "#":
          i = length;
          break;
        // Handle '/.' or '/..' path segments
        case "/":
          if (iri[i + 1] === ".") {
            next = iri[++i + 1];
            switch (next) {
              // Remove a '/.' segment
              case "/":
                result += iri.substring(segmentStart, i - 1);
                segmentStart = i + 1;
                break;
              // Remove a trailing '/.' segment
              case void 0:
              case "?":
              case "#":
                return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
              // Remove a '/..' segment
              case ".":
                next = iri[++i + 1];
                if (next === void 0 || next === "/" || next === "?" || next === "#") {
                  result += iri.substring(segmentStart, i - 2);
                  if ((segmentStart = result.lastIndexOf("/")) >= pathStart)
                    result = result.substr(0, segmentStart);
                  if (next !== "/")
                    return `${result}/${iri.substr(i + 1)}`;
                  segmentStart = i + 1;
                }
            }
          }
      }
      next = iri[++i];
    }
    return result + iri.substring(segmentStart);
  }
  // ## Public methods
  // ### `parse` parses the N3 input and emits each parsed quad through the onQuad callback.
  parse(input, quadCallback, prefixCallback) {
    let onQuad, onPrefix, onComment;
    if (quadCallback && (quadCallback.onQuad || quadCallback.onPrefix || quadCallback.onComment)) {
      onQuad = quadCallback.onQuad;
      onPrefix = quadCallback.onPrefix;
      onComment = quadCallback.onComment;
    } else {
      onQuad = quadCallback;
      onPrefix = prefixCallback;
    }
    this._readCallback = this._readInTopContext;
    this._sparqlStyle = false;
    this._prefixes = /* @__PURE__ */ Object.create(null);
    this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${blankNodePrefix++}_`;
    this._prefixCallback = onPrefix || noop;
    this._inversePredicate = false;
    this._quantified = /* @__PURE__ */ Object.create(null);
    if (!onQuad) {
      const quads = [];
      let error;
      this._callback = (e, t) => {
        e ? error = e : t && quads.push(t);
      };
      this._lexer.tokenize(input).every((token) => {
        return this._readCallback = this._readCallback(token);
      });
      if (error) throw error;
      return quads;
    }
    let processNextToken = (error, token) => {
      if (error !== null)
        this._callback(error), this._callback = noop;
      else if (this._readCallback)
        this._readCallback = this._readCallback(token);
    };
    if (onComment) {
      this._lexer.comments = true;
      processNextToken = (error, token) => {
        if (error !== null)
          this._callback(error), this._callback = noop;
        else if (this._readCallback) {
          if (token.type === "comment")
            onComment(token.value);
          else
            this._readCallback = this._readCallback(token);
        }
      };
    }
    this._callback = onQuad;
    this._lexer.tokenize(input, processNextToken);
  }
};
function noop() {
}
function initDataFactory(parser, factory) {
  parser._factory = factory;
  parser.DEFAULTGRAPH = factory.defaultGraph();
  parser.RDF_FIRST = factory.namedNode(IRIs_default.rdf.first);
  parser.RDF_REST = factory.namedNode(IRIs_default.rdf.rest);
  parser.RDF_NIL = factory.namedNode(IRIs_default.rdf.nil);
  parser.N3_FORALL = factory.namedNode(IRIs_default.r.forAll);
  parser.N3_FORSOME = factory.namedNode(IRIs_default.r.forSome);
  parser.ABBREVIATIONS = {
    "a": factory.namedNode(IRIs_default.rdf.type),
    "=": factory.namedNode(IRIs_default.owl.sameAs),
    ">": factory.namedNode(IRIs_default.log.implies),
    "<": factory.namedNode(IRIs_default.log.isImpliedBy)
  };
  parser.QUANTIFIERS_GRAPH = factory.namedNode("urn:n3:quantifiers");
}
initDataFactory(N3Parser.prototype, N3DataFactory_default);

// node_modules/n3/src/N3Writer.js
var DEFAULTGRAPH2 = N3DataFactory_default.defaultGraph();
var { rdf: rdf3, xsd: xsd3 } = IRIs_default;

// node_modules/n3/src/N3Store.js
var import_readable_stream = __toESM(require_browser3());
var ITERATOR = Symbol("iter");

// node_modules/n3/src/N3StreamParser.js
var import_readable_stream2 = __toESM(require_browser3());

// node_modules/n3/src/N3StreamWriter.js
var import_readable_stream3 = __toESM(require_browser3());

// node_modules/rdflib/esm/rdfaparser.js
if (typeof Node3 === "undefined") {
  Node3 = {
    ELEMENT_NODE: 1,
    ATTRIBUTE_NODE: 2,
    TEXT_NODE: 3,
    CDATA_SECTION_NODE: 4,
    ENTITY_REFERENCE_NODE: 5,
    ENTITY_NODE: 6,
    PROCESSING_INSTRUCTION_NODE: 7,
    COMMENT_NODE: 8,
    DOCUMENT_NODE: 9,
    DOCUMENT_TYPE_NODE: 10,
    DOCUMENT_FRAGMENT_NODE: 11,
    NOTATION_NODE: 12
  };
}
var Node3;
var RDFaProcessor = class _RDFaProcessor {
  constructor(kb, options) {
    this.options = options || {};
    this.kb = kb;
    this.target = options.target || {
      graph: {
        subjects: {},
        prefixes: {},
        terms: {}
      }
    };
    this.blankNodes = [];
    this.htmlOptions = {
      "selfClosing": "br img input area base basefont col colgroup source wbr isindex link meta param hr"
    };
    this.theOne = "_:" + (/* @__PURE__ */ new Date()).getTime();
    this.language = null;
    this.vocabulary = null;
    this.blankCounter = 0;
    this.langAttributes = [{
      namespaceURI: "http://www.w3.org/XML/1998/namespace",
      localName: "lang"
    }];
    this.inXHTMLMode = false;
    this.absURIRE = /[\w\_\-]+:\S+/;
    this.finishedHandlers = [];
    this.init();
  }
  addTriple(origin, subject, predicate, object) {
    var su, ob, pr, or;
    if (typeof subject === "undefined") {
      su = canonical_data_factory_default.namedNode(this.options.base);
    } else {
      su = this.toRDFNodeObject(subject);
    }
    pr = this.toRDFNodeObject(predicate);
    ob = this.toRDFNodeObject(object);
    or = canonical_data_factory_default.namedNode(this.options.base);
    this.kb.add(su, pr, ob, or);
  }
  ancestorPath(node) {
    var path = "";
    while (node && node.nodeType !== Node3.DOCUMENT_NODE) {
      path = "/" + node.localName + path;
      node = node.parentNode;
    }
    return path;
  }
  copyMappings(mappings) {
    var newMappings = {};
    for (var k in mappings) {
      newMappings[k] = mappings[k];
    }
    return newMappings;
  }
  copyProperties() {
  }
  deriveDateTimeType(value) {
    for (var i = 0; i < _RDFaProcessor.dateTimeTypes.length; i++) {
      var matched = _RDFaProcessor.dateTimeTypes[i].pattern.exec(value);
      if (matched && matched[0].length === value.length) {
        return _RDFaProcessor.dateTimeTypes[i].type;
      }
    }
    return null;
  }
  init() {
  }
  newBlankNode() {
    this.blankCounter++;
    return "_:" + this.blankCounter;
  }
  newSubjectOrigin(origin, subject) {
  }
  parseCURIE(value, prefixes, base) {
    var colon = value.indexOf(":");
    var uri;
    if (colon >= 0) {
      var prefix = value.substring(0, colon);
      if (prefix === "") {
        uri = prefixes[""];
        return uri ? uri + value.substring(colon + 1) : null;
      } else if (prefix === "_") {
        return "_:" + value.substring(colon + 1);
      } else if (_RDFaProcessor.NCNAME.test(prefix)) {
        uri = prefixes[prefix];
        if (uri) {
          return uri + value.substring(colon + 1);
        }
      }
    }
    return null;
  }
  parseCURIEOrURI(value, prefixes, base) {
    var curie = this.parseCURIE(value, prefixes, base);
    if (curie) {
      return curie;
    }
    return this.resolveAndNormalize(base, value);
  }
  parsePredicate(value, defaultVocabulary, terms, prefixes, base, ignoreTerms) {
    if (value === "") {
      return null;
    }
    var predicate = this.parseTermOrCURIEOrAbsURI(value, defaultVocabulary, ignoreTerms ? null : terms, prefixes, base);
    if (predicate && predicate.indexOf("_:") === 0) {
      return null;
    }
    return predicate;
  }
  parsePrefixMappings(str, target) {
    var values = this.tokenize(str);
    var prefix = null;
    for (var i = 0; i < values.length; i++) {
      if (values[i][values[i].length - 1] === ":") {
        prefix = values[i].substring(0, values[i].length - 1);
      } else if (prefix) {
        target[prefix] = this.options.base ? join(values[i], this.options.base) : values[i];
        prefix = null;
      }
    }
  }
  static parseRDFaDOM(dom, kb, base) {
    var p = new _RDFaProcessor(kb, {
      "base": base
    });
    if (!dom.baseURI) {
      dom.baseURI = base;
    }
    p.process(dom, {
      baseURI: base
    });
  }
  parseSafeCURIEOrCURIEOrURI(value, prefixes, base) {
    value = this.trim(value);
    if (value.charAt(0) === "[" && value.charAt(value.length - 1) === "]") {
      value = value.substring(1, value.length - 1);
      value = value.trim(value);
      if (value.length === 0) {
        return null;
      }
      if (value === "_:") {
        return this.theOne;
      }
      return this.parseCURIE(value, prefixes, base);
    } else {
      return this.parseCURIEOrURI(value, prefixes, base);
    }
  }
  parseTermOrCURIEOrAbsURI(value, defaultVocabulary, terms, prefixes, base) {
    value = this.trim(value);
    var curie = this.parseCURIE(value, prefixes, base);
    if (curie) {
      return curie;
    } else if (terms) {
      if (defaultVocabulary && !this.absURIRE.exec(value)) {
        return defaultVocabulary + value;
      }
      var term2 = terms[value];
      if (term2) {
        return term2;
      }
      var lcvalue = value.toLowerCase();
      term2 = terms[lcvalue];
      if (term2) {
        return term2;
      }
    }
    if (this.absURIRE.exec(value)) {
      return this.resolveAndNormalize(base, value);
    }
    return null;
  }
  parseTermOrCURIEOrURI(value, defaultVocabulary, terms, prefixes, base) {
    value = this.trim(value);
    var curie = this.parseCURIE(value, prefixes, base);
    if (curie) {
      return curie;
    } else {
      var term2 = terms[value];
      if (term2) {
        return term2;
      }
      var lcvalue = value.toLowerCase();
      term2 = terms[lcvalue];
      if (term2) {
        return term2;
      }
      if (defaultVocabulary && !this.absURIRE.exec(value)) {
        return defaultVocabulary + value;
      }
    }
    return this.resolveAndNormalize(base, value);
  }
  parseURI(uri) {
    return uri;
  }
  process(node, options) {
    options = options || {};
    var base;
    if (node.nodeType === Node3.DOCUMENT_NODE) {
      if (node.baseURI && !options.baseURI) {
        options.baseURI = node.baseURI;
      }
      base = node.baseURI;
      node = node.documentElement;
      if (!node.baseURI) {
        node.baseURI = base;
      }
      this.setContext(node);
    } else if (node.parentNode.nodeType === Node3.DOCUMENT_NODE) {
      this.setContext(node);
    }
    var queue = [];
    var removeHash = function(baseURI) {
      if (!baseURI && options && options.baseURI) {
        return options.baseURI;
      }
      var hash = baseURI.indexOf("#");
      if (hash >= 0) {
        baseURI = baseURI.substring(0, hash);
      }
      if (options && options.baseURIMap) {
        baseURI = options.baseURIMap(baseURI);
      }
      return baseURI;
    };
    queue.push({
      current: node,
      context: this.push(null, removeHash(node.baseURI))
    });
    while (queue.length > 0) {
      var item = queue.shift();
      if (item.parent) {
        if (item.context.parent && item.context.parent.listMapping === item.listMapping) {
          continue;
        }
        for (let predicate2 in item.listMapping) {
          var list = item.listMapping[predicate2];
          if (list.length === 0) {
            this.addTriple(item.parent, item.subject, predicate2, {
              type: _RDFaProcessor.objectURI,
              value: "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"
            });
            continue;
          }
          var bnodes = [];
          for (let i2 = 0; i2 < list.length; i2++) {
            bnodes.push(this.newBlankNode());
          }
          for (let i2 = 0; i2 < bnodes.length; i2++) {
            this.addTriple(item.parent, bnodes[i2], "http://www.w3.org/1999/02/22-rdf-syntax-ns#first", list[i2]);
            this.addTriple(item.parent, bnodes[i2], "http://www.w3.org/1999/02/22-rdf-syntax-ns#rest", {
              type: _RDFaProcessor.objectURI,
              value: i2 + 1 < bnodes.length ? bnodes[i2 + 1] : "http://www.w3.org/1999/02/22-rdf-syntax-ns#nil"
            });
          }
          this.addTriple(item.parent, item.subject, predicate2, {
            type: _RDFaProcessor.objectURI,
            value: bnodes[0]
          });
        }
        continue;
      }
      var current = item.current;
      var context = item.context;
      var skip = false;
      var newSubject = null;
      var currentObjectResource = null;
      var typedResource = null;
      var prefixes = context.prefixes;
      var prefixesCopied = false;
      var incomplete = [];
      var listMapping = context.listMapping;
      var listMappingDifferent = !context.parent;
      var language = context.language;
      var vocabulary = context.vocabulary;
      base = this.parseURI(removeHash(current.baseURI));
      current.item = null;
      var vocabAtt = current.getAttributeNode("vocab");
      if (vocabAtt) {
        let value = this.trim(vocabAtt.value);
        if (value.length > 0) {
          vocabulary = value;
          var baseSubject = base.spec;
          this.addTriple(current, baseSubject, "http://www.w3.org/ns/rdfa#usesVocabulary", {
            type: _RDFaProcessor.objectURI,
            value: vocabulary
          });
        } else {
          vocabulary = this.vocabulary;
        }
      }
      for (var i = 0; i < current.attributes.length; i++) {
        var att = current.attributes[i];
        if (att.nodeName.charAt(0) === "x" && att.nodeName.indexOf("xmlns:") === 0) {
          if (!prefixesCopied) {
            prefixes = this.copyMappings(prefixes);
            prefixesCopied = true;
          }
          var prefix = att.nodeName.substring(6);
          var ref = _RDFaProcessor.trim(att.value);
          prefixes[prefix] = this.options.base ? join(ref, this.options.base) : ref;
        }
      }
      var prefixAtt = current.getAttributeNode("prefix");
      if (prefixAtt) {
        if (!prefixesCopied) {
          prefixes = this.copyMappings(prefixes);
          prefixesCopied = true;
        }
        this.parsePrefixMappings(prefixAtt.value, prefixes);
      }
      var xmlLangAtt = null;
      for (let i2 = 0; !xmlLangAtt && i2 < this.langAttributes.length; i2++) {
        xmlLangAtt = current.getAttributeNodeNS(this.langAttributes[i2].namespaceURI, this.langAttributes[i2].localName);
      }
      if (xmlLangAtt) {
        let value = _RDFaProcessor.trim(xmlLangAtt.value);
        if (value.length > 0) {
          language = value;
        } else {
          language = null;
        }
      }
      var relAtt = current.getAttributeNode("rel");
      var revAtt = current.getAttributeNode("rev");
      var typeofAtt = current.getAttributeNode("typeof");
      var propertyAtt = current.getAttributeNode("property");
      var datatypeAtt = current.getAttributeNode("datatype");
      var datetimeAtt = this.inHTMLMode ? current.getAttributeNode("datetime") : null;
      var contentAtt = current.getAttributeNode("content");
      var aboutAtt = current.getAttributeNode("about");
      var srcAtt = current.getAttributeNode("src");
      var resourceAtt = current.getAttributeNode("resource");
      var hrefAtt = current.getAttributeNode("href");
      var inlistAtt = current.getAttributeNode("inlist");
      var relAttPredicates = [];
      var predicate, values;
      if (relAtt) {
        values = this.tokenize(relAtt.value);
        for (let i2 = 0; i2 < values.length; i2++) {
          predicate = this.parsePredicate(values[i2], vocabulary, context.terms, prefixes, base, this.inHTMLMode && propertyAtt !== null);
          if (predicate) {
            relAttPredicates.push(predicate);
          }
        }
      }
      var revAttPredicates = [];
      if (revAtt) {
        values = this.tokenize(revAtt.value);
        for (let i2 = 0; i2 < values.length; i2++) {
          predicate = this.parsePredicate(values[i2], vocabulary, context.terms, prefixes, base, this.inHTMLMode && propertyAtt);
          if (predicate) {
            revAttPredicates.push(predicate);
          }
        }
      }
      if (this.inHTMLMode && (relAtt || revAtt) && propertyAtt) {
        if (relAttPredicates.length === 0) {
          relAtt = null;
        }
        if (revAttPredicates.length === 0) {
          revAtt = null;
        }
      }
      if (relAtt || revAtt) {
        if (aboutAtt) {
          newSubject = this.parseSafeCURIEOrCURIEOrURI(aboutAtt.value, prefixes, base);
        }
        if (typeofAtt) {
          typedResource = newSubject;
        }
        if (!newSubject) {
          if (current.parentNode.nodeType === Node3.DOCUMENT_NODE) {
            newSubject = removeHash(current.baseURI);
          } else if (context.parentObject) {
            newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;
          }
        }
        if (resourceAtt) {
          currentObjectResource = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);
        }
        if (!currentObjectResource) {
          if (hrefAtt) {
            currentObjectResource = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));
          } else if (srcAtt) {
            currentObjectResource = this.resolveAndNormalize(base, encodeURI(srcAtt.value));
          } else if (typeofAtt && !aboutAtt && !(this.inXHTMLMode && (current.localName === "head" || current.localName === "body"))) {
            currentObjectResource = this.newBlankNode();
          }
        }
        if (typeofAtt && !aboutAtt && this.inXHTMLMode && (current.localName === "head" || current.localName === "body")) {
          typedResource = newSubject;
        } else if (typeofAtt && !aboutAtt) {
          typedResource = currentObjectResource;
        }
      } else if (propertyAtt && !contentAtt && !datatypeAtt) {
        if (aboutAtt) {
          newSubject = this.parseSafeCURIEOrCURIEOrURI(aboutAtt.value, prefixes, base);
          if (typeofAtt) {
            typedResource = newSubject;
          }
        }
        if (!newSubject && current.parentNode.nodeType === Node3.DOCUMENT_NODE) {
          newSubject = removeHash(current.baseURI);
          if (typeofAtt) {
            typedResource = newSubject;
          }
        } else if (!newSubject && context.parentObject) {
          newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;
        }
        if (typeofAtt && !typedResource) {
          if (resourceAtt) {
            typedResource = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);
          }
          if (!typedResource && hrefAtt) {
            typedResource = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));
          }
          if (!typedResource && srcAtt) {
            typedResource = this.resolveAndNormalize(base, encodeURI(srcAtt.value));
          }
          if (!typedResource && (this.inXHTMLMode || this.inHTMLMode) && (current.localName === "head" || current.localName === "body")) {
            typedResource = newSubject;
          }
          if (!typedResource) {
            typedResource = this.newBlankNode();
          }
          currentObjectResource = typedResource;
        }
      } else {
        if (aboutAtt) {
          newSubject = this.parseSafeCURIEOrCURIEOrURI(aboutAtt.value, prefixes, base);
        }
        if (!newSubject && resourceAtt) {
          newSubject = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);
        }
        if (!newSubject && hrefAtt) {
          newSubject = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));
        }
        if (!newSubject && srcAtt) {
          newSubject = this.resolveAndNormalize(base, encodeURI(srcAtt.value));
        }
        if (!newSubject) {
          if (current.parentNode.nodeType === Node3.DOCUMENT_NODE) {
            newSubject = removeHash(current.baseURI);
          } else if ((this.inXHTMLMode || this.inHTMLMode) && (current.localName === "head" || current.localName === "body")) {
            newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;
          } else if (typeofAtt) {
            newSubject = this.newBlankNode();
          } else if (context.parentObject) {
            newSubject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;
            if (!propertyAtt) {
              skip = true;
            }
          }
        }
        if (typeofAtt) {
          typedResource = newSubject;
        }
      }
      if (newSubject) {
        if (aboutAtt || resourceAtt || typedResource) {
          var id = newSubject;
          if (typeofAtt && !aboutAtt && !resourceAtt && currentObjectResource) {
            id = currentObjectResource;
          }
          this.newSubjectOrigin(current, id);
        }
      }
      if (typedResource) {
        values = this.tokenize(typeofAtt.value);
        for (let i2 = 0; i2 < values.length; i2++) {
          var object = this.parseTermOrCURIEOrAbsURI(values[i2], vocabulary, context.terms, prefixes, base);
          if (object) {
            this.addTriple(current, typedResource, _RDFaProcessor.typeURI, {
              type: _RDFaProcessor.objectURI,
              value: object
            });
          }
        }
      }
      if (newSubject && newSubject !== context.parentObject) {
        listMapping = {};
        listMappingDifferent = true;
      }
      if (currentObjectResource) {
        if (relAtt && inlistAtt) {
          for (let i2 = 0; i2 < relAttPredicates.length; i2++) {
            let list2 = listMapping[relAttPredicates[i2]];
            if (!list2) {
              list2 = [];
              listMapping[relAttPredicates[i2]] = list2;
            }
            list2.push({
              type: _RDFaProcessor.objectURI,
              value: currentObjectResource
            });
          }
        } else if (relAtt) {
          for (let i2 = 0; i2 < relAttPredicates.length; i2++) {
            this.addTriple(current, newSubject, relAttPredicates[i2], {
              type: _RDFaProcessor.objectURI,
              value: currentObjectResource
            });
          }
        }
        if (revAtt) {
          for (let i2 = 0; i2 < revAttPredicates.length; i2++) {
            this.addTriple(current, currentObjectResource, revAttPredicates[i2], {
              type: _RDFaProcessor.objectURI,
              value: newSubject
            });
          }
        }
      } else {
        if (newSubject && !currentObjectResource && (relAtt || revAtt)) {
          currentObjectResource = this.newBlankNode();
        }
        if (relAtt && inlistAtt) {
          for (let i2 = 0; i2 < relAttPredicates.length; i2++) {
            let list2 = listMapping[relAttPredicates[i2]];
            if (!list2) {
              list2 = [];
              listMapping[predicate] = list2;
            }
            incomplete.push({
              predicate: relAttPredicates[i2],
              list: list2
            });
          }
        } else if (relAtt) {
          for (let i2 = 0; i2 < relAttPredicates.length; i2++) {
            incomplete.push({
              predicate: relAttPredicates[i2],
              forward: true
            });
          }
        }
        if (revAtt) {
          for (let i2 = 0; i2 < revAttPredicates.length; i2++) {
            incomplete.push({
              predicate: revAttPredicates[i2],
              forward: false
            });
          }
        }
      }
      if (propertyAtt) {
        var datatype = null;
        var content = null;
        if (datatypeAtt) {
          datatype = datatypeAtt.value === "" ? _RDFaProcessor.PlainLiteralURI : this.parseTermOrCURIEOrAbsURI(datatypeAtt.value, vocabulary, context.terms, prefixes, base);
          if (datetimeAtt && !contentAtt) {
            content = datetimeAtt.value;
          } else {
            content = datatype === _RDFaProcessor.XMLLiteralURI || datatype === _RDFaProcessor.HTMLLiteralURI ? null : contentAtt ? contentAtt.value : current.textContent;
          }
        } else if (contentAtt) {
          datatype = _RDFaProcessor.PlainLiteralURI;
          content = contentAtt.value;
        } else if (datetimeAtt) {
          content = datetimeAtt.value;
          datatype = _RDFaProcessor.deriveDateTimeType(content);
          if (!datatype) {
            datatype = _RDFaProcessor.PlainLiteralURI;
          }
        } else if (!relAtt && !revAtt) {
          if (resourceAtt) {
            content = this.parseSafeCURIEOrCURIEOrURI(resourceAtt.value, prefixes, base);
          }
          if (!content && hrefAtt) {
            content = this.resolveAndNormalize(base, encodeURI(hrefAtt.value));
          } else if (!content && srcAtt) {
            content = this.resolveAndNormalize(base, encodeURI(srcAtt.value));
          }
          if (content) {
            datatype = _RDFaProcessor.objectURI;
          }
        }
        if (!datatype) {
          if (typeofAtt && !aboutAtt) {
            datatype = _RDFaProcessor.objectURI;
            content = typedResource;
          } else {
            content = current.textContent;
            if (this.inHTMLMode && current.localName === "time") {
              datatype = _RDFaProcessor.deriveDateTimeType(content);
            }
            if (!datatype) {
              datatype = _RDFaProcessor.PlainLiteralURI;
            }
          }
        }
        values = this.tokenize(propertyAtt.value);
        for (let i2 = 0; i2 < values.length; i2++) {
          let predicate2 = this.parsePredicate(values[i2], vocabulary, context.terms, prefixes, base);
          if (predicate2) {
            if (inlistAtt) {
              let list2 = listMapping[predicate2];
              if (!list2) {
                list2 = [];
                listMapping[predicate2] = list2;
              }
              list2.push(datatype === _RDFaProcessor.XMLLiteralURI || datatype === _RDFaProcessor.HTMLLiteralURI ? {
                type: datatype,
                value: current.childNodes
              } : {
                type: datatype || _RDFaProcessor.PlainLiteralURI,
                value: content,
                language
              });
            } else {
              if (datatype === _RDFaProcessor.XMLLiteralURI || datatype === _RDFaProcessor.HTMLLiteralURI) {
                this.addTriple(current, newSubject, predicate2, {
                  type: datatype,
                  value: current.childNodes
                });
              } else {
                this.addTriple(current, newSubject, predicate2, {
                  type: datatype || _RDFaProcessor.PlainLiteralURI,
                  value: content,
                  language
                });
              }
            }
          }
        }
      }
      if (newSubject && !skip) {
        for (let i2 = 0; i2 < context.incomplete.length; i2++) {
          if (context.incomplete[i2].list) {
            context.incomplete[i2].list.push({
              type: _RDFaProcessor.objectURI,
              value: newSubject
            });
          } else if (context.incomplete[i2].forward) {
            this.addTriple(current, context.subject, context.incomplete[i2].predicate, {
              type: _RDFaProcessor.objectURI,
              value: newSubject
            });
          } else {
            this.addTriple(current, newSubject, context.incomplete[i2].predicate, {
              type: _RDFaProcessor.objectURI,
              value: context.subject
            });
          }
        }
      }
      var childContext = null;
      var listSubject = newSubject;
      if (skip) {
        childContext = this.push(context, context.subject);
        childContext.parentObject = removeHash(current.parentNode.baseURI) === context.parentObject ? removeHash(current.baseURI) : context.parentObject;
        childContext.incomplete = context.incomplete;
        childContext.language = language;
        childContext.prefixes = prefixes;
        childContext.vocabulary = vocabulary;
      } else {
        childContext = this.push(context, newSubject);
        childContext.parentObject = currentObjectResource || newSubject || context.subject;
        childContext.prefixes = prefixes;
        childContext.incomplete = incomplete;
        if (currentObjectResource) {
          listSubject = currentObjectResource;
          listMapping = {};
          listMappingDifferent = true;
        }
        childContext.listMapping = listMapping;
        childContext.language = language;
        childContext.vocabulary = vocabulary;
      }
      if (listMappingDifferent) {
        queue.unshift({
          parent: current,
          context,
          subject: listSubject,
          listMapping
        });
      }
      for (var child = current.lastChild; child; child = child.previousSibling) {
        if (child.nodeType === Node3.ELEMENT_NODE) {
          queue.unshift({
            current: child,
            context: childContext
          });
        }
      }
    }
    if (this.inHTMLMode) {
      this.copyProperties();
    }
    for (let i2 = 0; i2 < this.finishedHandlers.length; i2++) {
      this.finishedHandlers[i2](node);
    }
  }
  push(parent, subject) {
    return {
      parent,
      subject: subject || (parent ? parent.subject : null),
      parentObject: null,
      incomplete: [],
      listMapping: parent ? parent.listMapping : {},
      language: parent ? parent.language : this.language,
      prefixes: parent ? parent.prefixes : this.target.graph.prefixes,
      terms: parent ? parent.terms : this.target.graph.terms,
      vocabulary: parent ? parent.vocabulary : this.vocabulary
    };
  }
  resolveAndNormalize(base, uri) {
    return join(uri, base);
  }
  setContext(node) {
    if (node.localName === "html" && node.getAttribute("version") === "XHTML+RDFa 1.1") {
      this.setXHTMLContext();
    } else if (node.localName === "html" || node.namespaceURI === "http://www.w3.org/1999/xhtml") {
      if (typeof document !== "undefined" && document.doctype) {
        if (document.doctype.publicId === "-//W3C//DTD XHTML+RDFa 1.0//EN" && document.doctype.systemId === "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-1.dtd") {
          console.log("WARNING: RDF 1.0 is not supported.  Defaulting to HTML5 mode.");
          this.setHTMLContext();
        } else if (document.doctype.publicId === "-//W3C//DTD XHTML+RDFa 1.1//EN" && document.doctype.systemId === "http://www.w3.org/MarkUp/DTD/xhtml-rdfa-2.dtd") {
          this.setXHTMLContext();
        } else {
          this.setHTMLContext();
        }
      } else {
        this.setHTMLContext();
      }
    } else {
      this.setXMLContext();
    }
  }
  setHTMLContext() {
    this.setInitialContext();
    this.langAttributes = [{
      namespaceURI: "http://www.w3.org/XML/1998/namespace",
      localName: "lang"
    }, {
      namespaceURI: null,
      localName: "lang"
    }];
    this.inXHTMLMode = false;
    this.inHTMLMode = true;
  }
  setInitialContext() {
    this.vocabulary = null;
    this.langAttributes = [{
      namespaceURI: "http://www.w3.org/XML/1998/namespace",
      localName: "lang"
    }];
  }
  setXHTMLContext() {
    this.setInitialContext();
    this.inXHTMLMode = true;
    this.inHTMLMode = false;
    this.langAttributes = [{
      namespaceURI: "http://www.w3.org/XML/1998/namespace",
      localName: "lang"
    }, {
      namespaceURI: null,
      localName: "lang"
    }];
    this.target.graph.terms["alternate"] = "http://www.w3.org/1999/xhtml/vocab#alternate";
    this.target.graph.terms["appendix"] = "http://www.w3.org/1999/xhtml/vocab#appendix";
    this.target.graph.terms["bookmark"] = "http://www.w3.org/1999/xhtml/vocab#bookmark";
    this.target.graph.terms["cite"] = "http://www.w3.org/1999/xhtml/vocab#cite";
    this.target.graph.terms["chapter"] = "http://www.w3.org/1999/xhtml/vocab#chapter";
    this.target.graph.terms["contents"] = "http://www.w3.org/1999/xhtml/vocab#contents";
    this.target.graph.terms["copyright"] = "http://www.w3.org/1999/xhtml/vocab#copyright";
    this.target.graph.terms["first"] = "http://www.w3.org/1999/xhtml/vocab#first";
    this.target.graph.terms["glossary"] = "http://www.w3.org/1999/xhtml/vocab#glossary";
    this.target.graph.terms["help"] = "http://www.w3.org/1999/xhtml/vocab#help";
    this.target.graph.terms["icon"] = "http://www.w3.org/1999/xhtml/vocab#icon";
    this.target.graph.terms["index"] = "http://www.w3.org/1999/xhtml/vocab#index";
    this.target.graph.terms["last"] = "http://www.w3.org/1999/xhtml/vocab#last";
    this.target.graph.terms["license"] = "http://www.w3.org/1999/xhtml/vocab#license";
    this.target.graph.terms["meta"] = "http://www.w3.org/1999/xhtml/vocab#meta";
    this.target.graph.terms["next"] = "http://www.w3.org/1999/xhtml/vocab#next";
    this.target.graph.terms["prev"] = "http://www.w3.org/1999/xhtml/vocab#prev";
    this.target.graph.terms["previous"] = "http://www.w3.org/1999/xhtml/vocab#previous";
    this.target.graph.terms["section"] = "http://www.w3.org/1999/xhtml/vocab#section";
    this.target.graph.terms["stylesheet"] = "http://www.w3.org/1999/xhtml/vocab#stylesheet";
    this.target.graph.terms["subsection"] = "http://www.w3.org/1999/xhtml/vocab#subsection";
    this.target.graph.terms["start"] = "http://www.w3.org/1999/xhtml/vocab#start";
    this.target.graph.terms["top"] = "http://www.w3.org/1999/xhtml/vocab#top";
    this.target.graph.terms["up"] = "http://www.w3.org/1999/xhtml/vocab#up";
    this.target.graph.terms["p3pv1"] = "http://www.w3.org/1999/xhtml/vocab#p3pv1";
    this.target.graph.terms["related"] = "http://www.w3.org/1999/xhtml/vocab#related";
    this.target.graph.terms["role"] = "http://www.w3.org/1999/xhtml/vocab#role";
    this.target.graph.terms["transformation"] = "http://www.w3.org/1999/xhtml/vocab#transformation";
  }
  setXMLContext() {
    this.setInitialContext();
    this.inXHTMLMode = false;
    this.inHTMLMode = false;
  }
  tokenize(str) {
    return this.trim(str).split(/\s+/);
  }
  static tokenize(str) {
    return this.trim(str).split(/\s+/);
  }
  toRDFNodeObject(x) {
    if (typeof x === "undefined") return void 0;
    if (typeof x === "string") {
      if (x.substring(0, 2) === "_:") {
        if (typeof this.blankNodes[x.substring(2)] === "undefined") {
          this.blankNodes[x.substring(2)] = new BlankNode(x.substring(2));
        }
        return this.blankNodes[x.substring(2)];
      }
      return canonical_data_factory_default.namedNode(x);
    }
    switch (x.type) {
      case _RDFaProcessor.objectURI:
        if (x.value.substring(0, 2) === "_:") {
          if (typeof this.blankNodes[x.value.substring(2)] === "undefined") {
            this.blankNodes[x.value.substring(2)] = new BlankNode(x.value.substring(2));
          }
          return this.blankNodes[x.value.substring(2)];
        }
        return canonical_data_factory_default.namedNode(x.value);
      case _RDFaProcessor.PlainLiteralURI:
        return new Literal(x.value, x.language || "");
      case _RDFaProcessor.XMLLiteralURI:
      case _RDFaProcessor.HTMLLiteralURI:
        var string2 = "";
        Object.keys(x.value).forEach((i) => {
          string2 += domToString(x.value[i], this.htmlOptions);
        });
        return new Literal(string2, "", new NamedNode(x.type));
      default:
        return new Literal(x.value, "", new NamedNode(x.type));
    }
  }
  trim(str) {
    return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
  static trim(str) {
    return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
  }
};
RDFaProcessor.XMLLiteralURI = "http://www.w3.org/1999/02/22-rdf-syntax-ns#XMLLiteral";
RDFaProcessor.HTMLLiteralURI = "http://www.w3.org/1999/02/22-rdf-syntax-ns#HTML";
RDFaProcessor.PlainLiteralURI = "http://www.w3.org/1999/02/22-rdf-syntax-ns#PlainLiteral";
RDFaProcessor.objectURI = "http://www.w3.org/1999/02/22-rdf-syntax-ns#object";
RDFaProcessor.typeURI = "http://www.w3.org/1999/02/22-rdf-syntax-ns#type";
RDFaProcessor.nameChar = "[-A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌-‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�က0-F.0-9·̀-ͯ‿-⁀]";
RDFaProcessor.nameStartChar = "[A-Za-zÀ-ÖØ-öø-ÿĀ-ıĴ-ľŁ-ňŊ-žƀ-ǃǍ-ǰǴ-ǵǺ-ȗɐ-ʨʻ-ˁΆΈ-ΊΌΎ-ΡΣ-ώϐ-ϖϚϜϞϠϢ-ϳЁ-ЌЎ-яё-ќў-ҁҐ-ӄӇ-ӈӋ-ӌӐ-ӫӮ-ӵӸ-ӹԱ-Ֆՙա-ֆא-תװ-ײء-غف-يٱ-ڷں-ھۀ-ێې-ۓەۥ-ۦअ-हऽक़-ॡঅ-ঌএ-ঐও-নপ-রলশ-হড়-ঢ়য়-ৡৰ-ৱਅ-ਊਏ-ਐਓ-ਨਪ-ਰਲ-ਲ਼ਵ-ਸ਼ਸ-ਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઋઍએ-ઑઓ-નપ-રલ-ળવ-હઽૠଅ-ଌଏ-ଐଓ-ନପ-ରଲ-ଳଶ-ହଽଡ଼-ଢ଼ୟ-ୡஅ-ஊஎ-ஐஒ-கங-சஜஞ-டண-தந-பம-வஷ-ஹఅ-ఌఎ-ఐఒ-నప-ళవ-హౠ-ౡಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹೞೠ-ೡഅ-ഌഎ-ഐഒ-നപ-ഹൠ-ൡก-ฮะา-ำเ-ๅກ-ຂຄງ-ຈຊຍດ-ທນ-ຟມ-ຣລວສ-ຫອ-ຮະາ-ຳຽເ-ໄཀ-ཇཉ-ཀྵႠ-Ⴥა-ჶᄀᄂ-ᄃᄅ-ᄇᄉᄋ-ᄌᄎ-ᄒᄼᄾᅀᅌᅎᅐᅔ-ᅕᅙᅟ-ᅡᅣᅥᅧᅩᅭ-ᅮᅲ-ᅳᅵᆞᆨᆫᆮ-ᆯᆷ-ᆸᆺᆼ-ᇂᇫᇰᇹḀ-ẛẠ-ỹἀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼΩK-Å℮ↀ-ↂぁ-ゔァ-ヺㄅ-ㄬ가-힣一-龥〇〡-〩_]";
RDFaProcessor.NCNAME = new RegExp("^" + RDFaProcessor.nameStartChar + RDFaProcessor.nameChar + "*$");
RDFaProcessor.dateTimeTypes = [{
  pattern: /-?P(?:[0-9]+Y)?(?:[0-9]+M)?(?:[0-9]+D)?(?:T(?:[0-9]+H)?(?:[0-9]+M)?(?:[0-9]+(?:\.[0-9]+)?S)?)?/,
  type: "http://www.w3.org/2001/XMLSchema#duration"
}, {
  pattern: /-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]-[0-9][0-9]T(?:[0-1][0-9]|2[0-4]):[0-5][0-9]:[0-5][0-9](?:\.[0-9]+)?(?:Z|[+\-][0-9][0-9]:[0-9][0-9])?/,
  type: "http://www.w3.org/2001/XMLSchema#dateTime"
}, {
  pattern: /-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]-[0-9][0-9](?:Z|[+\-][0-9][0-9]:[0-9][0-9])?/,
  type: "http://www.w3.org/2001/XMLSchema#date"
}, {
  pattern: /(?:[0-1][0-9]|2[0-4]):[0-5][0-9]:[0-5][0-9](?:\.[0-9]+)?(?:Z|[+\-][0-9][0-9]:[0-9][0-9])?/,
  type: "http://www.w3.org/2001/XMLSchema#time"
}, {
  pattern: /-?(?:[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9])-[0-9][0-9]/,
  type: "http://www.w3.org/2001/XMLSchema#gYearMonth"
}, {
  pattern: /-?[1-9][0-9][0-9][0-9]|0[1-9][0-9][0-9]|00[1-9][0-9]|000[1-9]/,
  type: "http://www.w3.org/2001/XMLSchema#gYear"
}];
var parseRDFaDOM = RDFaProcessor.parseRDFaDOM;

// node_modules/rdflib/esm/rdfxmlparser.js
var RDFParser = class _RDFParser {
  /*
   * @constructor
   * @param {RDFStore} store An RDFStore object
   */
  constructor(store) {
    this.store = store;
    this.bnodes = {};
    this.why = null;
    this.reify = false;
  }
  /** Standard namespaces that we know how to handle @final
   *  @member RDFParser
   */
  /**
   * Frame class for namespace and base URI lookups
   * Base lookups will always resolve because the parser knows
   * the default base.
   *
   * @private
   */
  frameFactory(parser, parent, element) {
    return {
      "NODE": 1,
      "ARC": 2,
      "parent": parent,
      "parser": parser,
      "store": parser.store,
      "element": element,
      "lastChild": 0,
      "base": null,
      "lang": null,
      "node": null,
      "nodeType": null,
      "listIndex": 1,
      "rdfid": null,
      "datatype": null,
      "collection": false,
      /** Terminate the frame and notify the store that we're done */
      "terminateFrame": function() {
        if (this.collection) {
          this.node.close();
        }
      },
      /** Add a symbol of a certain type to the this frame */
      "addSymbol": function(type, uri) {
        uri = join(uri, this.base);
        this.node = this.store.sym(uri);
        this.nodeType = type;
      },
      /** Load any constructed triples into the store */
      "loadTriple": function() {
        if (this.parent.parent.collection) {
          this.parent.parent.node.append(this.node);
        } else {
          this.store.add(this.parent.parent.node, this.parent.node, this.node, this.parser.why);
        }
        if (this.parent.rdfid != null) {
          var triple2 = this.store.sym(join("#" + this.parent.rdfid, this.base));
          this.store.add(triple2, this.store.sym(_RDFParser.ns.RDF + "type"), this.store.sym(_RDFParser.ns.RDF + "Statement"), this.parser.why);
          this.store.add(triple2, this.store.sym(_RDFParser.ns.RDF + "subject"), this.parent.parent.node, this.parser.why);
          this.store.add(triple2, this.store.sym(_RDFParser.ns.RDF + "predicate"), this.parent.node, this.parser.why);
          this.store.add(triple2, this.store.sym(_RDFParser.ns.RDF + "object"), this.node, this.parser.why);
        }
      },
      /** Check if it's OK to load a triple */
      "isTripleToLoad": function() {
        return this.parent != null && this.parent.parent != null && this.nodeType === this.NODE && this.parent.nodeType === this.ARC && this.parent.parent.nodeType === this.NODE;
      },
      /** Add a symbolic node to this frame */
      "addNode": function(uri) {
        this.addSymbol(this.NODE, uri);
        if (this.isTripleToLoad()) {
          this.loadTriple();
        }
      },
      /** Add a collection node to this frame */
      "addCollection": function() {
        this.nodeType = this.NODE;
        this.node = this.store.collection();
        this.collection = true;
        if (this.isTripleToLoad()) {
          this.loadTriple();
        }
      },
      /** Add a collection arc to this frame */
      "addCollectionArc": function() {
        this.nodeType = this.ARC;
      },
      /** Add a bnode to this frame */
      "addBNode": function(id) {
        if (id != null) {
          if (this.parser.bnodes[id] != null) {
            this.node = this.parser.bnodes[id];
          } else {
            this.node = this.parser.bnodes[id] = this.store.bnode();
          }
        } else {
          this.node = this.store.bnode();
        }
        this.nodeType = this.NODE;
        if (this.isTripleToLoad()) {
          this.loadTriple();
        }
      },
      /** Add an arc or property to this frame */
      "addArc": function(uri) {
        if (uri === _RDFParser.ns.RDF + "li") {
          uri = _RDFParser.ns.RDF + "_" + this.parent.listIndex;
          this.parent.listIndex++;
        }
        this.addSymbol(this.ARC, uri);
      },
      /** Add a literal to this frame */
      "addLiteral": function(value) {
        if (this.parent.datatype && this.parent.datatype !== _RDFParser.ns.RDF + "langString") {
          this.node = this.store.literal(value, this.store.sym(this.parent.datatype));
        } else {
          this.node = this.store.literal(value, this.lang);
        }
        this.nodeType = this.NODE;
        if (this.isTripleToLoad()) {
          this.loadTriple();
        }
      }
    };
  }
  // from the OpenLayers source .. needed to get around IE problems.
  getAttributeNodeNS(node, uri, name) {
    var attributeNode = null;
    if (node.getAttributeNodeNS) {
      attributeNode = node.getAttributeNodeNS(uri, name);
    } else {
      var attributes = node.attributes;
      var potentialNode, fullName;
      for (var i = 0; i < attributes.length; ++i) {
        potentialNode = attributes[i];
        if (potentialNode.namespaceURI === uri) {
          fullName = potentialNode.prefix ? potentialNode.prefix + ":" + name : name;
          if (fullName === potentialNode.nodeName) {
            attributeNode = potentialNode;
            break;
          }
        }
      }
    }
    return attributeNode;
  }
  /**
   * Build our initial scope frame and parse the DOM into triples
   * @param {HTMLDocument} document The DOM to parse
   * @param {String} base The base URL to use
   * @param {Object} why The context to which this resource belongs
   */
  parse(document3, base, why) {
    var children = document3.childNodes;
    this.cleanParser();
    var root;
    if (document3.nodeType === _RDFParser.nodeType.DOCUMENT) {
      for (var c = 0; c < children.length; c++) {
        if (children[c].nodeType === _RDFParser.nodeType.ELEMENT) {
          root = children[c];
          break;
        }
      }
    } else if (document3.nodeType === _RDFParser.nodeType.ELEMENT) {
      root = document3;
    } else {
      throw new Error("RDFParser: can't find root in " + base + ". Halting. ");
    }
    this.why = why;
    var f = this.frameFactory(this);
    this.base = base;
    f.base = base;
    f.lang = null;
    this.parseDOM(this.buildFrame(f, root));
    return true;
  }
  parseDOM(frame) {
    var rdfid;
    var elementURI = (function(el) {
      var result = "";
      if (el.namespaceURI == null) {
        throw new Error("RDF/XML syntax error: No namespace for " + el.localName + " in " + this.base);
      }
      if (el.namespaceURI) {
        result = result + el.namespaceURI;
      }
      if (el.localName) {
        result = result + el.localName;
      } else if (el.nodeName) {
        if (el.nodeName.indexOf(":") >= 0) result = result + el.nodeName.split(":")[1];
        else result = result + el.nodeName;
      }
      return result;
    }).bind(this);
    var dig = true;
    while (frame.parent) {
      var dom = frame.element;
      var attrs = dom.attributes;
      if (dom.nodeType === _RDFParser.nodeType.TEXT || dom.nodeType === _RDFParser.nodeType.CDATA_SECTION) {
        if (frame.parent.nodeType === frame.NODE) {
          frame.addArc(_RDFParser.ns.RDF + "value");
          frame = this.buildFrame(frame);
        }
        frame.addLiteral(dom.nodeValue);
      } else if (elementURI(dom) !== _RDFParser.ns.RDF + "RDF") {
        if (frame.parent && frame.parent.collection) {
          frame.addCollectionArc();
          frame = this.buildFrame(frame, frame.element);
          frame.parent.element = null;
        }
        if (!frame.parent || !frame.parent.nodeType || frame.parent.nodeType === frame.ARC) {
          var about = this.getAttributeNodeNS(dom, _RDFParser.ns.RDF, "about");
          rdfid = this.getAttributeNodeNS(dom, _RDFParser.ns.RDF, "ID");
          if (about && rdfid) {
            throw new Error("RDFParser: " + dom.nodeName + " has both rdf:id and rdf:about. Halting. Only one of these properties may be specified on a node.");
          }
          if (!about && rdfid) {
            frame.addNode("#" + rdfid.nodeValue);
            dom.removeAttributeNode(rdfid);
          } else if (about == null && rdfid == null) {
            var bnid = this.getAttributeNodeNS(dom, _RDFParser.ns.RDF, "nodeID");
            if (bnid) {
              frame.addBNode(bnid.nodeValue);
              dom.removeAttributeNode(bnid);
            } else {
              frame.addBNode();
            }
          } else {
            frame.addNode(about.nodeValue);
            dom.removeAttributeNode(about);
          }
          var rdftype = this.getAttributeNodeNS(dom, _RDFParser.ns.RDF, "type");
          if (_RDFParser.ns.RDF + "Description" !== elementURI(dom)) {
            rdftype = {
              "nodeValue": elementURI(dom)
            };
          }
          if (rdftype != null) {
            this.store.add(frame.node, this.store.sym(_RDFParser.ns.RDF + "type"), this.store.sym(join(rdftype.nodeValue, frame.base)), this.why);
            if (rdftype.nodeName) {
              dom.removeAttributeNode(rdftype);
            }
          }
          for (var x = attrs.length - 1; x >= 0; x--) {
            this.store.add(frame.node, this.store.sym(elementURI(attrs[x])), this.store.literal(attrs[x].nodeValue, frame.lang), this.why);
          }
        } else {
          frame.addArc(elementURI(dom));
          if (this.reify) {
            rdfid = this.getAttributeNodeNS(dom, _RDFParser.ns.RDF, "ID");
            if (rdfid) {
              frame.rdfid = rdfid.nodeValue;
              dom.removeAttributeNode(rdfid);
            }
          }
          var parsetype = this.getAttributeNodeNS(dom, _RDFParser.ns.RDF, "parseType");
          var datatype = this.getAttributeNodeNS(dom, _RDFParser.ns.RDF, "datatype");
          if (datatype) {
            frame.datatype = datatype.nodeValue;
            dom.removeAttributeNode(datatype);
          }
          if (parsetype) {
            var nv = parsetype.nodeValue;
            if (nv === "Literal") {
              frame.datatype = _RDFParser.ns.RDF + "XMLLiteral";
              frame = this.buildFrame(frame);
              frame.addLiteral(dom.innerHTML || dom.childNodes);
              dig = false;
            } else if (nv === "Resource") {
              frame = this.buildFrame(frame, frame.element);
              frame.parent.element = null;
              frame.addBNode();
            } else if (nv === "Collection") {
              frame = this.buildFrame(frame, frame.element);
              frame.parent.element = null;
              frame.addCollection();
            }
            dom.removeAttributeNode(parsetype);
          }
          if (attrs.length !== 0) {
            var resource = this.getAttributeNodeNS(dom, _RDFParser.ns.RDF, "resource");
            var bnid2 = this.getAttributeNodeNS(dom, _RDFParser.ns.RDF, "nodeID");
            frame = this.buildFrame(frame);
            if (resource) {
              frame.addNode(resource.nodeValue);
              dom.removeAttributeNode(resource);
            } else {
              if (bnid2) {
                frame.addBNode(bnid2.nodeValue);
                dom.removeAttributeNode(bnid2);
              } else {
                frame.addBNode();
              }
            }
            for (var x1 = attrs.length - 1; x1 >= 0; x1--) {
              var f = this.buildFrame(frame);
              f.addArc(elementURI(attrs[x1]));
              if (elementURI(attrs[x1]) === _RDFParser.ns.RDF + "type") {
                this.buildFrame(f).addNode(attrs[x1].nodeValue);
              } else {
                this.buildFrame(f).addLiteral(attrs[x1].nodeValue);
              }
            }
          } else if (dom.childNodes.length === 0) {
            this.buildFrame(frame).addLiteral("");
          }
        }
      }
      dom = frame.element;
      while (frame.parent) {
        var pframe = frame;
        while (dom == null) {
          frame = frame.parent;
          dom = frame.element;
        }
        var candidate = dom.childNodes && dom.childNodes[frame.lastChild];
        if (!candidate || !dig) {
          frame.terminateFrame();
          if (!(frame = frame.parent)) {
            break;
          }
          dom = frame.element;
          dig = true;
        } else if (candidate.nodeType !== _RDFParser.nodeType.ELEMENT && candidate.nodeType !== _RDFParser.nodeType.TEXT && candidate.nodeType !== _RDFParser.nodeType.CDATA_SECTION || (candidate.nodeType === _RDFParser.nodeType.TEXT || candidate.nodeType === _RDFParser.nodeType.CDATA_SECTION) && dom.childNodes.length !== 1) {
          frame.lastChild++;
        } else {
          frame.lastChild++;
          frame = this.buildFrame(pframe, dom.childNodes[frame.lastChild - 1]);
          break;
        }
      }
    }
  }
  /**
   * Cleans out state from a previous parse run
   * @private
   */
  cleanParser() {
    this.bnodes = {};
    this.why = null;
  }
  /**
   * Builds scope frame
   * @private
   */
  buildFrame(parent, element) {
    var frame = this.frameFactory(this, parent, element);
    if (parent) {
      frame.base = parent.base;
      frame.lang = parent.lang;
    }
    if (!element || element.nodeType === _RDFParser.nodeType.TEXT || element.nodeType === _RDFParser.nodeType.CDATA_SECTION) {
      return frame;
    }
    var attrs = element.attributes;
    var base = element.getAttributeNode("xml:base");
    if (base != null) {
      frame.base = base.nodeValue;
      element.removeAttribute("xml:base");
    }
    var lang = element.getAttributeNode("xml:lang");
    if (lang != null) {
      frame.lang = lang.nodeValue;
      element.removeAttribute("xml:lang");
    }
    for (var x = attrs.length - 1; x >= 0; x--) {
      if (attrs[x].nodeName.substr(0, 3) === "xml") {
        if (attrs[x].name.slice(0, 6) === "xmlns:") {
          var uri = attrs[x].nodeValue;
          if (this.base) uri = join(uri, this.base);
          this.store.setPrefixForURI(attrs[x].name.slice(6), uri);
        }
        element.removeAttributeNode(attrs[x]);
      }
    }
    return frame;
  }
};
_defineProperty(RDFParser, "ns", {
  "RDF": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
  "RDFS": "http://www.w3.org/2000/01/rdf-schema#"
});
_defineProperty(RDFParser, "nodeType", {
  "ELEMENT": 1,
  "ATTRIBUTE": 2,
  "TEXT": 3,
  "CDATA_SECTION": 4,
  "ENTITY_REFERENCE": 5,
  "ENTITY": 6,
  "PROCESSING_INSTRUCTION": 7,
  "COMMENT": 8,
  "DOCUMENT": 9,
  "DOCUMENT_TYPE": 10,
  "DOCUMENT_FRAGMENT": 11,
  "NOTATION": 12
});

// node_modules/rdflib/esm/patch-parser.js
function sparqlUpdateParser(str, kb, base) {
  var i, j, k;
  var keywords = ["INSERT", "DELETE", "WHERE"];
  var SQNS = Namespace("http://www.w3.org/ns/pim/patch#");
  var p = n3parser_default(kb, kb, base, base, null, null, "", null);
  var clauses = {};
  var badSyntax = function(uri, lines, str2, i2, why) {
    return "Line " + (lines + 1) + " of <" + uri + ">: Bad syntax:\n   " + why + '\n   at: "' + str2.slice(i2, i2 + 30) + '"';
  };
  i = 0;
  var query = kb.sym(base + "#query");
  clauses["query"] = query;
  while (true) {
    j = p.skipSpace(str, i);
    if (j < 0) {
      return clauses;
    }
    if (str[j] === ";") {
      i = p.skipSpace(str, j + 1);
      if (i < 0) {
        return clauses;
      }
      j = i;
    }
    var found = false;
    for (k = 0; k < keywords.length; k++) {
      var key = keywords[k];
      if (str.slice(j, j + key.length) === key) {
        i = p.skipSpace(str, j + key.length);
        if (i < 0) {
          throw badSyntax(p._thisDoc, p.lines, str, j + key.length, "found EOF, needed {...} after " + key);
        }
        if ((key === "INSERT" || key === "DELETE") && str.slice(i, i + 4) === "DATA") {
          j = p.skipSpace(str, i + 4);
          if (j < 0) {
            throw badSyntax(p._thisDoc, p.lines, str, i + 4, "needed {...} after INSERT DATA " + key);
          }
          i = j;
        }
        var res2 = [];
        j = p.node(str, i, res2);
        if (j < 0) {
          throw badSyntax(p._thisDoc, p.lines, str, i, "bad syntax or EOF in {...} after " + key);
        }
        clauses[key.toLowerCase()] = res2[0];
        kb.add(query, SQNS(key.toLowerCase()), res2[0]);
        found = true;
        i = j;
      }
    }
    if (!found && str.slice(j, j + 7) === "@prefix") {
      i = p.directive(str, j);
      if (i < 0) {
        throw badSyntax(p._thisDoc, p.lines, str, i, "bad syntax or EOF after @prefix ");
      }
      i = p.checkDot(str, i);
      found = true;
    }
    if (!found) {
      throw badSyntax(p._thisDoc, p.lines, str, j, "Unknown syntax at start of statememt: '" + str.slice(j).slice(0, 20) + "'");
    }
  }
}

// node_modules/rdflib/esm/parse.js
function parse2(str, kb, base, contentType = "text/turtle", callback) {
  contentType = contentType || TurtleContentType;
  contentType = contentType.split(";")[0];
  try {
    if (contentType === N3ContentType || contentType === TurtleContentType) {
      var p = n3parser_default(kb, kb, base, base, null, null, "", null);
      p.loadBuf(str);
      executeCallback();
    } else if (contentType === RDFXMLContentType) {
      var parser = new RDFParser(kb);
      parser.parse(parseXML(str), base, kb.sym(base));
      executeCallback();
    } else if (contentType === XHTMLContentType) {
      parseRDFaDOM(parseXML(str, {
        contentType: XHTMLContentType
      }), kb, base);
      executeCallback();
    } else if (contentType === HTMLContentType) {
      parseRDFaDOM(parseXML(str, {
        contentType: HTMLContentType
      }), kb, base);
      executeCallback();
    } else if (contentType === SPARQLUpdateContentType || contentType === SPARQLUpdateSingleMatchContentType) {
      sparqlUpdateParser(str, kb, base);
      executeCallback();
    } else if (contentType === JSONLDContentType) {
      jsonldParser(str, kb, base).then(executeCallback).catch(executeErrorCallback);
    } else if (contentType === NQuadsContentType || contentType === NQuadsAltContentType) {
      var n3Parser = new N3Parser({
        factory: extended_term_factory_default
      });
      nquadCallback(null, str);
    } else if (contentType === void 0) {
      throw new Error("contentType is undefined");
    } else {
      throw new Error("Don't know how to parse " + contentType + " yet");
    }
  } catch (e) {
    executeErrorCallback(e);
  }
  parse2.handled = {
    "text/n3": true,
    "text/turtle": true,
    "application/rdf+xml": true,
    "application/xhtml+xml": true,
    "text/html": true,
    "application/sparql-update": true,
    "application/sparql-update-single-match": true,
    "application/ld+json": true,
    "application/nquads": true,
    "application/n-quads": true
  };
  function executeCallback() {
    if (callback) {
      callback(null, kb);
    } else {
      return;
    }
  }
  function executeErrorCallback(e) {
    if (
      // TODO: Always true, what is the right behavior
      contentType !== JSONLDContentType || // @ts-ignore always true?
      contentType !== NQuadsContentType || // @ts-ignore always true?
      contentType !== NQuadsAltContentType
    ) {
      if (callback) {
        callback(e, kb);
      } else {
        let e2 = new Error("" + e + " while trying to parse <" + base + "> as " + contentType);
        e2.cause = e;
        throw e2;
      }
    }
  }
  function nquadCallback(err, nquads) {
    if (err) {
      callback(err, kb);
    }
    try {
      n3Parser.parse(nquads, tripleCallback);
    } catch (err2) {
      callback(err2, kb);
    }
  }
  function tripleCallback(err, triple2) {
    if (triple2) {
      kb.add(triple2.subject, triple2.predicate, triple2.object, triple2.graph);
    } else {
      callback(err, kb);
    }
  }
}

// node_modules/rdflib/esm/fetcher.js
var import_cross_fetch = __toESM(require_browser_ponyfill());
var Parsable = {
  "text/n3": true,
  "text/turtle": true,
  "application/rdf+xml": true,
  "application/xhtml+xml": true,
  "text/html": true,
  "application/ld+json": true
};
var CONTENT_TYPE_BY_EXT = {
  "rdf": RDFXMLContentType,
  "owl": RDFXMLContentType,
  "n3": "text/n3",
  "ttl": "text/turtle",
  "nt": "text/n3",
  "acl": "text/n3",
  "html": "text/html",
  "xml": "text/xml"
};
var getNS = (factory) => {
  return {
    link: Namespace("http://www.w3.org/2007/ont/link#", factory),
    http: Namespace("http://www.w3.org/2007/ont/http#", factory),
    httph: Namespace("http://www.w3.org/2007/ont/httph#", factory),
    // headers
    rdf: Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#", factory),
    rdfs: Namespace("http://www.w3.org/2000/01/rdf-schema#", factory),
    dc: Namespace("http://purl.org/dc/elements/1.1/", factory),
    ldp: Namespace("http://www.w3.org/ns/ldp#", factory)
  };
};
var ns2 = getNS();
var Handler = class {
  constructor(response, dom) {
    _defineProperty(this, "response", void 0);
    _defineProperty(this, "dom", void 0);
    this.response = response;
    this.dom = dom;
  }
};
_defineProperty(Handler, "pattern", void 0);
var RDFXMLHandler = class extends Handler {
  static toString() {
    return "RDFXMLHandler";
  }
  static register(fetcher2) {
    fetcher2.mediatypes[RDFXMLContentType] = {
      "q": 0.9
    };
  }
  parse(fetcher2, responseText, options) {
    let kb = fetcher2.store;
    if (!this.dom) {
      this.dom = parseXML(responseText);
    }
    let root = this.dom.documentElement;
    if (root && root.nodeName === "parsererror") {
      return fetcher2.failFetch(options, "Badly formed XML in " + options.resource.value, "parse_error");
    }
    let parser = new RDFParser(kb);
    try {
      parser.parse(this.dom, options.original.value, options.original);
    } catch (err) {
      return fetcher2.failFetch(options, "Syntax error parsing RDF/XML! " + err, "parse_error");
    }
    if (!options.noMeta) {
      kb.add(options.original, ns2.rdf("type"), ns2.link("RDFDocument"), fetcher2.appNode);
    }
    return fetcher2.doneFetch(options, this.response);
  }
};
RDFXMLHandler.pattern = new RegExp("application/rdf\\+xml");
var XHTMLHandler = class extends Handler {
  static toString() {
    return "XHTMLHandler";
  }
  static register(fetcher2) {
    fetcher2.mediatypes[XHTMLContentType] = {
      "q": 0.8
    };
  }
  parse(fetcher2, responseText, options) {
    let relation, reverse;
    if (!this.dom) {
      this.dom = parseXML(responseText);
    }
    let kb = fetcher2.store;
    let title = this.dom.getElementsByTagName("title");
    if (title.length > 0) {
      kb.add(options.resource, ns2.dc("title"), kb.rdfFactory.literal(title[0].textContent), options.resource);
    }
    let links = this.dom.getElementsByTagName("link");
    for (let x = links.length - 1; x >= 0; x--) {
      relation = links[x].getAttribute("rel");
      reverse = false;
      if (!relation) {
        relation = links[x].getAttribute("rev");
        reverse = true;
      }
      if (relation) {
        fetcher2.linkData(options.original, relation, links[x].getAttribute("href"), options.resource, reverse);
      }
    }
    let scripts = this.dom.getElementsByTagName("script");
    for (let i = 0; i < scripts.length; i++) {
      let contentType = scripts[i].getAttribute("type");
      if (Parsable[contentType]) {
        parse2(scripts[i].textContent, kb, options.original.value, contentType);
        parse2(scripts[i].textContent, kb, options.original.value, contentType);
      }
    }
    if (!options.noMeta) {
      kb.add(options.resource, ns2.rdf("type"), ns2.link("WebPage"), fetcher2.appNode);
    }
    if (!options.noRDFa && parseRDFaDOM) {
      try {
        parseRDFaDOM(this.dom, kb, options.original.value);
      } catch (err) {
        let msg = "Error trying to parse " + options.resource + " as RDFa:\n" + err + ":\n" + err.stack;
        return fetcher2.failFetch(options, msg, "parse_error");
      }
    }
    return fetcher2.doneFetch(options, this.response);
  }
};
XHTMLHandler.pattern = new RegExp("application/xhtml");
var XMLHandler = class _XMLHandler extends Handler {
  static toString() {
    return "XMLHandler";
  }
  static register(fetcher2) {
    fetcher2.mediatypes["text/xml"] = {
      "q": 0.5
    };
    fetcher2.mediatypes["application/xml"] = {
      "q": 0.5
    };
  }
  static isElement(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  parse(fetcher2, responseText, options) {
    let dom = parseXML(responseText);
    for (let c = 0; c < dom.childNodes.length; c++) {
      const node = dom.childNodes[c];
      if (_XMLHandler.isElement(node)) {
        let ns3 = node.namespaceURI;
        if (ns3 && ns3 === ns3["rdf"]) {
          fetcher2.addStatus(options.req, "Has XML root element in the RDF namespace, so assume RDF/XML.");
          let rdfHandler = new RDFXMLHandler(this.response, dom);
          return rdfHandler.parse(fetcher2, responseText, options);
        }
        break;
      }
    }
    if (dom.doctype) {
      if (dom.doctype.name === "html" && dom.doctype.publicId.match(/^-\/\/W3C\/\/DTD XHTML/) && dom.doctype.systemId.match(/http:\/\/www.w3.org\/TR\/xhtml/)) {
        fetcher2.addStatus(options.req, "Has XHTML DOCTYPE. Switching to XHTML Handler.\n");
        let xhtmlHandler = new XHTMLHandler(this.response, dom);
        return xhtmlHandler.parse(fetcher2, responseText, options);
      }
    }
    let html = dom.getElementsByTagName("html")[0];
    if (html) {
      let xmlns = html.getAttribute("xmlns");
      if (xmlns && xmlns.match(/^http:\/\/www.w3.org\/1999\/xhtml/)) {
        fetcher2.addStatus(options.req, "Has a default namespace for XHTML. Switching to XHTMLHandler.\n");
        let xhtmlHandler = new XHTMLHandler(this.response, dom);
        return xhtmlHandler.parse(fetcher2, responseText, options);
      }
    }
    return fetcher2.failFetch(options, "Unsupported dialect of XML: not RDF or XHTML namespace, etc.\n" + responseText.slice(0, 80), 901);
  }
};
XMLHandler.pattern = new RegExp("(text|application)/(.*)xml");
var HTMLHandler = class extends Handler {
  static toString() {
    return "HTMLHandler";
  }
  static register(fetcher2) {
    fetcher2.mediatypes["text/html"] = {
      "q": 0.8
    };
  }
  parse(fetcher2, responseText, options) {
    let kb = fetcher2.store;
    if (isXML(responseText)) {
      fetcher2.addStatus(options.req, "Has an XML declaration. We'll assume it's XHTML as the content-type was text/html.\n");
      let xhtmlHandler = new XHTMLHandler(this.response);
      return xhtmlHandler.parse(fetcher2, responseText, options);
    }
    if (isXHTML(responseText)) {
      fetcher2.addStatus(options.req, "Has XHTML DOCTYPE. Switching to XHTMLHandler.\n");
      let xhtmlHandler = new XHTMLHandler(this.response);
      return xhtmlHandler.parse(fetcher2, responseText, options);
    }
    if (isXMLNS(responseText)) {
      fetcher2.addStatus(options.req, "Has default namespace for XHTML, so switching to XHTMLHandler.\n");
      let xhtmlHandler = new XHTMLHandler(this.response);
      return xhtmlHandler.parse(fetcher2, responseText, options);
    }
    let titleMatch = new RegExp("<title>([\\s\\S]+?)</title>", "im").exec(responseText);
    if (titleMatch) {
      kb.add(options.resource, ns2.dc("title"), kb.rdfFactory.literal(titleMatch[1]), options.resource);
    }
    kb.add(options.resource, ns2.rdf("type"), ns2.link("WebPage"), fetcher2.appNode);
    fetcher2.addStatus(options.req, "non-XML HTML document, not parsed for data.");
    return fetcher2.doneFetch(options, this.response);
  }
};
HTMLHandler.pattern = new RegExp("text/html");
var JsonLdHandler = class extends Handler {
  static toString() {
    return "JsonLdHandler";
  }
  static register(fetcher2) {
    fetcher2.mediatypes["application/ld+json"] = {
      "q": 0.9
    };
  }
  async parse(fetcher2, responseText, options, response) {
    const kb = fetcher2.store;
    try {
      await jsonldParser(responseText, kb, options.original.value);
      fetcher2.store.add(options.original, ns2.rdf("type"), ns2.link("RDFDocument"), fetcher2.appNode);
      return fetcher2.doneFetch(options, response);
    } catch (err) {
      const msg = "Error trying to parse " + options.resource + " as JSON-LD:\n" + err;
      return fetcher2.failFetch(options, msg, "parse_error", response);
    }
  }
};
JsonLdHandler.pattern = /application\/(ld\+json|activity\+json)/;
var TextHandler = class extends Handler {
  static toString() {
    return "TextHandler";
  }
  static register(fetcher2) {
    fetcher2.mediatypes["text/plain"] = {
      "q": 0.5
    };
  }
  parse(fetcher2, responseText, options) {
    if (isXML(responseText)) {
      fetcher2.addStatus(options.req, "Warning: " + options.resource + " has an XML declaration. We'll assume it's XML but its content-type wasn't XML.\n");
      let xmlHandler = new XMLHandler(this.response);
      return xmlHandler.parse(fetcher2, responseText, options);
    }
    if (responseText.slice(0, 500).match(/xmlns:/)) {
      fetcher2.addStatus(options.req, "May have an XML namespace. We'll assume it's XML but its content-type wasn't XML.\n");
      let xmlHandler = new XMLHandler(this.response);
      return xmlHandler.parse(fetcher2, responseText, options);
    }
    fetcher2.addStatus(options.req, "Plain text document, no known RDF semantics.");
    return fetcher2.doneFetch(options, this.response);
  }
};
TextHandler.pattern = new RegExp("text/plain");
var N3Handler = class extends Handler {
  static toString() {
    return "N3Handler";
  }
  static register(fetcher2) {
    fetcher2.mediatypes["text/n3"] = {};
    fetcher2.mediatypes["text/turtle"] = {};
  }
  parse(fetcher2, responseText, options, response) {
    let kb = fetcher2.store;
    let p = n3parser_default(kb, kb, options.original.value, options.original.value, null, null, "", null);
    try {
      p.loadBuf(responseText);
    } catch (err) {
      let msg = "Error trying to parse " + options.resource + " as Notation3:\n" + err;
      return fetcher2.failFetch(options, msg, "parse_error", response);
    }
    fetcher2.addStatus(options.req, "N3 parsed: " + p.statementCount + " triples in " + p.lines + " lines.");
    fetcher2.store.add(options.original, ns2.rdf("type"), ns2.link("RDFDocument"), fetcher2.appNode);
    return fetcher2.doneFetch(options, this.response);
  }
};
N3Handler.pattern = new RegExp("(application|text)/(x-)?(rdf\\+)?(n3|turtle)");
var defaultHandlers = {
  RDFXMLHandler,
  XHTMLHandler,
  XMLHandler,
  HTMLHandler,
  TextHandler,
  N3Handler,
  JsonLdHandler
};
function isXHTML(responseText) {
  const docTypeStart = responseText.indexOf("<!DOCTYPE html");
  const docTypeEnd = responseText.indexOf(">");
  if (docTypeStart === -1 || docTypeEnd === -1 || docTypeStart > docTypeEnd) {
    return false;
  }
  return responseText.substr(docTypeStart, docTypeEnd - docTypeStart).indexOf("XHTML") !== -1;
}
function isXML(responseText) {
  const match = responseText.match(/\s*<\?xml\s+version\s*=[^<>]+\?>/);
  return !!match;
}
function isXMLNS(responseText) {
  const match = responseText.match(/[^(<html)]*<html\s+[^<]*xmlns=['"]http:\/\/www.w3.org\/1999\/xhtml["'][^<]*>/);
  return !!match;
}
var Fetcher = class _Fetcher {
  constructor(store, options = {}) {
    _defineProperty(this, "store", void 0);
    _defineProperty(this, "timeout", void 0);
    _defineProperty(this, "_fetch", void 0);
    _defineProperty(this, "mediatypes", void 0);
    _defineProperty(this, "appNode", void 0);
    _defineProperty(this, "requested", void 0);
    _defineProperty(this, "timeouts", void 0);
    _defineProperty(this, "redirectedTo", void 0);
    _defineProperty(this, "fetchQueue", void 0);
    _defineProperty(this, "fetchCallbacks", void 0);
    _defineProperty(this, "nonexistent", void 0);
    _defineProperty(this, "lookedUp", void 0);
    _defineProperty(this, "handlers", void 0);
    _defineProperty(this, "ns", void 0);
    _defineProperty(this, "fireCallbacks", void 0);
    this.store = store || new IndexedFormula();
    this.ns = getNS(this.store.rdfFactory);
    this.timeout = options.timeout || 3e4;
    let fetchFunc = options.fetch || typeof global !== "undefined" && (global.solidFetcher || global.solidFetch) || typeof window !== "undefined" && (window.solidFetcher || window.solidFetch) || import_cross_fetch.default;
    if (!fetchFunc) {
      throw new Error("No _fetch function available for Fetcher");
    }
    if (typeof window !== "undefined" && fetchFunc === window.fetch) {
      this._fetch = fetchFunc.bind(window);
    } else if (typeof global !== "undefined" && fetchFunc === global.fetch) {
      this._fetch = fetchFunc.bind(global);
    } else {
      this._fetch = fetchFunc;
    }
    this.appNode = this.store.sym("chrome://TheCurrentSession");
    this.store.fetcher = this;
    this.requested = {};
    this.timeouts = {};
    this.redirectedTo = {};
    this.fetchQueue = {};
    this.fetchCallbacks = {};
    this.nonexistent = {};
    this.lookedUp = {};
    this.handlers = [];
    this.mediatypes = {
      "image/*": {
        "q": 0.9
      },
      "*/*": {
        "q": 0.1
      }
      // Must allow access to random content
    };
    callbackify(this, ["request", "fail", "refresh", "retract", "done"]);
    Object.keys(options.handlers || defaultHandlers).map((key) => this.addHandler(defaultHandlers[key]));
  }
  static crossSiteProxy(uri) {
    if (_Fetcher.crossSiteProxyTemplate) {
      return _Fetcher.crossSiteProxyTemplate.replace("{uri}", encodeURIComponent(uri));
    } else {
      return void 0;
    }
  }
  static offlineOverride(uri) {
    let requestedURI = uri;
    var UI;
    if (typeof window !== "undefined" && window.panes && (UI = window.panes.UI) && UI.preferences && UI.preferences.get("offlineModeUsingLocalhost")) {
      if (requestedURI.slice(0, 7) === "http://" && requestedURI.slice(7, 17) !== "localhost/") {
        requestedURI = "http://localhost/" + requestedURI.slice(7);
        log_default.warn("Localhost kludge for offline use: actually getting <" + requestedURI + ">");
      } else {
      }
    } else {
    }
    return requestedURI;
  }
  static proxyIfNecessary(uri) {
    var UI;
    if (typeof window !== "undefined" && window.panes && (UI = window.panes.UI) && UI.isExtension) {
      return uri;
    }
    if (typeof $SolidTestEnvironment !== "undefined" && $SolidTestEnvironment.localSiteMap) {
      let hostpath = uri.split("/").slice(2);
      const lookup = (parts, index) => {
        let z = index[parts.shift()];
        if (!z) {
          return null;
        }
        if (typeof z === "string") {
          return z + parts.join("/");
        }
        if (!parts) {
          return null;
        }
        return lookup(parts, z);
      };
      const y = lookup(hostpath, $SolidTestEnvironment.localSiteMap);
      if (y) {
        return y;
      }
    }
    if (_Fetcher.crossSiteProxyTemplate && typeof document !== "undefined" && document.location && ("" + document.location).slice(0, 6) === "https:" && // origin is secure
    uri.slice(0, 5) === "http:") {
      return _Fetcher.crossSiteProxyTemplate.replace("{uri}", encodeURIComponent(uri));
    }
    return uri;
  }
  /**
   * Tests whether the uri's protocol is supported by the Fetcher.
   * @param uri
   */
  static unsupportedProtocol(uri) {
    let pcol = protocol(uri);
    return pcol === "tel" || pcol === "mailto" || pcol === "urn";
  }
  /** Decide on credentials using old XXHR api or new fetch()  one
   * @param requestedURI
   * @param options
   */
  static setCredentials(requestedURI, options = {}) {
    if (options.credentials === void 0) {
      if (options.withCredentials !== void 0) {
        options.credentials = options.withCredentials ? "include" : "omit";
      } else {
        options.credentials = "include";
      }
    }
  }
  /**
   * Promise-based load function
   *
   * Loads a web resource or resources into the store.
   *
   * A resource may be given as NamedNode object, or as a plain URI.
   * an array of resources will be given, in which they will be fetched in parallel.
   * By default, the HTTP headers are recorded also, in the same store, in a separate graph.
   * This allows code like editable() for example to test things about the resource.
   *
   * @param uri {Array<RDFlibNamedNode>|Array<string>|RDFlibNamedNode|string}
   *
   * @param [options={}] {Object}
   *
   * @param [options.fetch] {Function}
   *
   * @param [options.referringTerm] {RDFlibNamedNode} Referring term, the resource which
   *   referred to this (for tracking bad links)
   *
   * @param [options.contentType] {string} Provided content type (for writes)
   *
   * @param [options.forceContentType] {string} Override the incoming header to
   *   force the data to be treated as this content-type (for reads)
   *
   * @param [options.force] {boolean} Load the data even if loaded before.
   *   Also sets the `Cache-Control:` header to `no-cache`
   *
   * @param [options.baseURI=docuri] {Node|string} Original uri to preserve
   *   through proxying etc (`xhr.original`).
   *
   * @param [options.proxyUsed] {boolean} Whether this request is a retry via
   *   a proxy (generally done from an error handler)
   *
   * @param [options.withCredentials] {boolean} flag for XHR/CORS etc
   *
   * @param [options.clearPreviousData] {boolean} Before we parse new data,
   *   clear old, but only on status 200 responses
   *
   * @param [options.noMeta] {boolean} Prevents the addition of various metadata
   *   triples (about the fetch request) to the store
   *
   * @param [options.noRDFa] {boolean}
   *
   * @returns {Promise<Result>}
   */
  load(uri, options = {}) {
    options = Object.assign({}, options);
    if (uri instanceof Array) {
      return Promise.all(uri.map((x) => {
        return this.load(x, Object.assign({}, options));
      }));
    }
    const uriIn = uri;
    let docuri = termValue(uriIn);
    docuri = docuri.split("#")[0];
    options = this.initFetchOptions(docuri, options);
    const meta = this.appNode;
    const kb = this.store;
    const requests = kb.statementsMatching(void 0, this.ns.link("requestedURI"), kb.sym(docuri), meta).map((st2) => st2.subject);
    for (const request of requests) {
      const response = kb.any(request, this.ns.link("response"), null, meta);
      if (response != void 0) {
        const quad3 = kb.statementsMatching(response, this.ns.link("outOfDate"), true, meta);
        kb.remove(quad3);
        options.force = true;
        options.clearPreviousData = true;
      }
    }
    const initialisedOptions = this.initFetchOptions(docuri, options);
    return this.pendingFetchPromise(docuri, initialisedOptions.baseURI, initialisedOptions);
  }
  async pendingFetchPromise(uri, originalUri, options) {
    let pendingPromise;
    if (!options.force && await this.fetchQueue[originalUri]) {
      pendingPromise = this.fetchQueue[originalUri];
    } else {
      pendingPromise = Promise.race([this.setRequestTimeout(uri, options), this.fetchUri(uri, options)]);
      this.fetchQueue[originalUri] = pendingPromise;
      this.cleanupFetchRequest(originalUri, void 0, this.timeout);
    }
    return pendingPromise.then((x) => {
      if (uri in this.timeouts) {
        this.timeouts[uri].forEach(clearTimeout);
        delete this.timeouts[uri];
      }
      return x;
    });
  }
  /**
   * @param _options - DEPRECATED
   */
  cleanupFetchRequest(originalUri, _options, timeout) {
    if (_options !== void 0) {
      console.warn("_options is deprecated");
    }
    this.timeouts[originalUri] = (this.timeouts[originalUri] || []).concat(setTimeout(() => {
      if (!this.isPending(originalUri)) {
        delete this.fetchQueue[originalUri];
      }
    }, timeout));
  }
  initFetchOptions(uri, options) {
    let kb = this.store;
    let isGet = !options.method || options.method.toUpperCase() === "GET";
    if (!isGet) {
      options.force = true;
    }
    options.resource = kb.rdfFactory.namedNode(uri);
    options.baseURI = options.baseURI || uri;
    options.original = kb.rdfFactory.namedNode(options.baseURI);
    options.req = kb.bnode();
    options.headers = options.headers || {};
    if (options.contentType) {
      options.headers["content-type"] = options.contentType;
    }
    if (options.force) {
      options.cache = "no-cache";
    }
    let acceptString = this.acceptString();
    options.headers["accept"] = acceptString;
    let requestedURI = _Fetcher.offlineOverride(uri);
    options.requestedURI = requestedURI;
    _Fetcher.setCredentials(requestedURI, options);
    let actualProxyURI = _Fetcher.proxyIfNecessary(requestedURI);
    if (requestedURI !== actualProxyURI) {
      options.proxyUsed = true;
    }
    options.actualProxyURI = actualProxyURI;
    return options;
  }
  /**
   * (The promise chain ends in either a `failFetch()` or a `doneFetch()`)
   *
   * @param docuri {string}
   * @param options {Object}
   *
   * @returns {Promise<Object>} fetch() result or an { error, status } object
   */
  fetchUri(docuri, options) {
    if (!docuri) {
      return Promise.reject(new Error("Cannot fetch an empty uri"));
    }
    if (_Fetcher.unsupportedProtocol(docuri)) {
      return this.failFetch(options, "fetcher: Unsupported protocol", "unsupported_protocol");
    }
    let state = this.getState(docuri);
    if (!options.force) {
      if (state === "fetched") {
        return Promise.resolve(
          // @ts-ignore This is not a valid response object
          this.doneFetch(options, {
            status: 200,
            ok: true,
            statusText: "Already loaded into quadstore."
          })
        );
      }
      if (state === "failed" && this.requested[docuri] === 404) {
        let message = "Previously failed: " + this.requested[docuri];
        let dummyResponse = {
          url: docuri,
          // This does not comply to Fetch spec, it can be a string value in rdflib
          status: this.requested[docuri],
          statusText: message,
          responseText: message,
          headers: new import_cross_fetch.Headers(),
          // Headers() ???
          ok: false,
          body: null,
          bodyUsed: false,
          size: 0,
          timeout: 0
        };
        return this.failFetch(options, message, this.requested[docuri], dummyResponse);
      }
    } else {
      delete this.nonexistent[docuri];
    }
    this.fireCallbacks("request", [docuri]);
    this.requested[docuri] = true;
    if (!options.noMeta) {
      this.saveRequestMetadata(docuri, options);
    }
    let {
      actualProxyURI
    } = options;
    return this._fetch(actualProxyURI, options).then((response) => this.handleResponse(response, docuri, options), (error) => {
      let dummyResponse = {
        url: actualProxyURI,
        status: 999,
        // @@ what number/string should fetch failures report?
        statusText: (error.name || "network failure") + ": " + (error.errno || error.code || error.type),
        responseText: error.message,
        headers: new import_cross_fetch.Headers(),
        // Headers() ???
        ok: false,
        body: null,
        bodyUsed: false,
        size: 0,
        timeout: 0
      };
      return this.handleError(dummyResponse, docuri, options);
    });
  }
  /**
   * Asks for a doc to be loaded if necessary then calls back
   *
   * Calling methods:
   *   nowOrWhenFetched (uri, userCallback)
   *   nowOrWhenFetched (uri, options, userCallback)
   *   nowOrWhenFetched (uri, referringTerm, userCallback, options)  <-- old
   *   nowOrWhenFetched (uri, referringTerm, userCallback) <-- old
   *
   *  Options include:
   *   referringTerm    The document in which this link was found.
   *                    this is valuable when finding the source of bad URIs
   *   force            boolean.  Never mind whether you have tried before,
   *                    load this from scratch.
   *   forceContentType Override the incoming header to force the data to be
   *                    treated as this content-type.
   *
   *  Callback function takes:
   *
   *    ok               True if the fetch worked, and got a 200 response.
   *                     False if any error happened
   *
   *    errmessage       Text error message if not OK.
   *
   *    response         The fetch Response object (was: XHR) if there was was one
   *                     includes response.status as the HTTP status if any.
   */
  nowOrWhenFetched(uriIn, p2, userCallback, options = {}) {
    const uri = termValue(uriIn);
    if (typeof p2 === "function") {
      userCallback = p2;
    } else if (typeof p2 === "undefined") {
    } else if (isNamedNode(p2)) {
      options.referringTerm = p2;
    } else {
      options = p2;
    }
    this.load(uri, options).then((fetchResponse) => {
      if (userCallback) {
        if (fetchResponse) {
          if (fetchResponse.ok) {
            userCallback(true, "OK", fetchResponse);
          } else {
            let oops = "HTTP error: Status " + fetchResponse.status + " (" + fetchResponse.statusText + ")";
            if (fetchResponse.responseText) {
              oops += " " + fetchResponse.responseText;
            }
            userCallback(false, oops, fetchResponse);
          }
        } else {
          let oops = "@@ nowOrWhenFetched:  no response object!";
          userCallback(false, oops);
        }
      }
    }, function(err) {
      var message = err.message || err.statusText;
      message = "Failed to load  <" + uri + "> " + message;
      if (err.response && err.response.status) {
        message += " status: " + err.response.status;
      }
      userCallback(false, message, err.response);
    });
  }
  /**
   * Records a status message (as a literal node) by appending it to the
   * request's metadata status collection.
   *
   */
  addStatus(req, statusMessage) {
    let now = /* @__PURE__ */ new Date();
    statusMessage = "[" + now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds() + "." + now.getMilliseconds() + "] " + statusMessage;
    let kb = this.store;
    const statusNode = kb.the(req, this.ns.link("status"));
    if (isCollection(statusNode)) {
      statusNode.append(kb.rdfFactory.literal(statusMessage));
    } else {
      log_default.warn("web.js: No list to add to: " + statusNode + "," + statusMessage);
    }
  }
  /**
   * Records errors in the system on failure:
   *
   *  - Adds an entry to the request status collection
   *  - Adds an error triple with the fail message to the metadata
   *  - Fires the 'fail' callback
   *  - Rejects with an error result object, which has a response object if any
   */
  failFetch(options, errorMessage, statusCode, response) {
    this.addStatus(options.req, errorMessage);
    if (!options.noMeta) {
      this.store.add(options.original, this.ns.link("error"), this.store.rdfFactory.literal(errorMessage));
    }
    let meth = (options.method || "GET").toUpperCase();
    let isGet = meth === "GET" || meth === "HEAD";
    if (isGet) {
      if (!options.resource.equals(options.original)) {
      } else {
      }
      this.requested[docpart(options.original.value)] = statusCode;
      this.fireCallbacks("fail", [options.original.value, errorMessage]);
    }
    var err = new Error("Fetcher: " + errorMessage);
    err.status = statusCode;
    err.statusText = errorMessage;
    err.response = response;
    return Promise.reject(err);
  }
  // in the why part of the quad distinguish between HTML and HTTP header
  // Reverse is set iif the link was rev= as opposed to rel=
  linkData(originalUri, rel, uri, why, reverse) {
    if (!uri) return;
    let kb = this.store;
    let predicate;
    let obj = kb.rdfFactory.namedNode(join(uri, originalUri.value));
    if (rel === "alternate" || rel === "seeAlso" || rel === "meta" || rel === "describedby") {
      if (obj.value === originalUri.value) {
        return;
      }
      predicate = this.ns.rdfs("seeAlso");
    } else if (rel === "type") {
      predicate = kb.rdfFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
    } else {
      predicate = kb.rdfFactory.namedNode(join(encodeURIComponent(rel), "http://www.iana.org/assignments/link-relations/"));
    }
    if (reverse) {
      kb.add(obj, predicate, originalUri, why);
    } else {
      kb.add(originalUri, predicate, obj, why);
    }
  }
  parseLinkHeader(linkHeader, originalUri, reqNode) {
    if (!linkHeader) {
      return;
    }
    const linkexp = /<[^>]*>\s*(\s*;\s*[^()<>@,;:"/[\]?={} \t]+=(([^\(\)<>@,;:"\/\[\]\?={} \t]+)|("[^"]*")))*(,|$)/g;
    const paramexp = /[^\(\)<>@,;:"\/\[\]\?={} \t]+=(([^\(\)<>@,;:"\/\[\]\?={} \t]+)|("[^"]*"))/g;
    const matches = linkHeader.match(linkexp);
    if (matches == null) return;
    for (let i = 0; i < matches.length; i++) {
      let split = matches[i].split(">");
      let href = split[0].substring(1);
      let ps = split[1];
      let s = ps.match(paramexp);
      if (s == null) return;
      for (let j = 0; j < s.length; j++) {
        let p = s[j];
        let paramsplit = p.split("=");
        let rel = paramsplit[1].replace(/["']/g, "");
        this.linkData(originalUri, rel, href, reqNode);
      }
    }
  }
  doneFetch(options, response) {
    this.addStatus(options.req, "Done.");
    this.requested[options.original.value] = "done";
    this.fireCallbacks("done", [options.original.value]);
    response.req = options.req;
    return response;
  }
  /**
   * Note two nodes are now smushed
   * If only one was flagged as looked up, then the new node is looked up again,
   * which will make sure all the URIs are dereferenced
   */
  nowKnownAs(was, now) {
    if (this.lookedUp[was.value]) {
      if (!this.lookedUp[now.value]) {
        this.lookUpThing(now, was);
      }
    } else if (this.lookedUp[now.value]) {
      if (!this.lookedUp[was.value]) {
        this.lookUpThing(was, now);
      }
    }
  }
  /**
   * Writes back to the web what we have in the store for this uri
   */
  putBack(uri, options = {}) {
    const uriSting = termValue(uri);
    let doc = new NamedNode(uriSting).doc();
    options.contentType = options["content-type"] || options["Content-Type"] || options.contentType || TurtleContentType;
    if (options.contentType === "application/ld+json") {
      return new Promise((resolve, reject) => {
        serialize(doc, this.store, doc.uri, options.contentType, (err, jsonString) => {
          if (err) {
            reject(err);
          } else {
            options.data = jsonString;
            this.webOperation("PUT", uri, options).then((res) => resolve(res)).catch((error) => reject(error));
          }
        });
      });
    }
    options.data = serialize(doc, this.store, doc.value, options.contentType);
    return this.webOperation("PUT", uriSting, options);
  }
  webCopy(here, there, contentType) {
    return this.webOperation("GET", here).then((result) => {
      return this.webOperation(
        "PUT",
        // change to binary from text
        there,
        {
          data: result.responseText,
          contentType
        }
      );
    });
  }
  delete(uri, options) {
    return this.webOperation("DELETE", uri, options).then((response) => {
      this.requested[uri] = 404;
      this.nonexistent[uri] = true;
      this.unload(this.store.rdfFactory.namedNode(uri));
      return response;
    });
  }
  /** Create an empty resource if it really does not exist
   *  Be absolutely sure something does not exist before creating a new empty file
   * as otherwise existing could  be deleted.
   * @param doc - The resource
  */
  async createIfNotExists(doc, contentType = TurtleContentType, data = "") {
    const fetcher2 = this;
    try {
      var response = await fetcher2.load(doc);
    } catch (err) {
      if (err.response.status === 404) {
        try {
          response = await fetcher2.webOperation("PUT", doc.value, {
            data,
            contentType
          });
        } catch (err2) {
          throw err2;
        }
        delete fetcher2.requested[doc.value];
        return response;
      } else {
        throw err;
      }
    }
    return response;
  }
  /**
   * @param parentURI URI of parent container
   * @param folderName - Optional folder name (slug)
   * @param data - Optional folder metadata
   */
  createContainer(parentURI, folderName, data) {
    let headers = {
      // Force the right mime type for containers
      "content-type": TurtleContentType,
      "link": this.ns.ldp("BasicContainer") + '; rel="type"'
    };
    if (folderName) {
      headers["slug"] = folderName;
    }
    let options = {
      headers
    };
    if (data) {
      options.body = data;
    }
    return this.webOperation("POST", parentURI, options);
  }
  invalidateCache(iri) {
    const uri = termValue(iri);
    const fetcher2 = this;
    if (fetcher2.fetchQueue && fetcher2.fetchQueue[uri]) {
      var promise = fetcher2.fetchQueue[uri];
      if (promise["PromiseStatus"] === "resolved") {
        delete fetcher2.fetchQueue[uri];
      } else {
        delete fetcher2.fetchQueue[uri];
      }
    }
    if (fetcher2.requested[uri] && fetcher2.requested[uri] !== "done" && fetcher2.requested[uri] !== "failed" && fetcher2.requested[uri] !== 404) {
      let msg = `Rdflib: fetcher: Destructive operation on <${fetcher2.requested[uri]}> file being fetched! ` + uri;
      console.error(msg);
    } else {
      delete fetcher2.requested[uri];
      delete fetcher2.nonexistent[uri];
    }
  }
  /**
   * A generic web operation, at the fetch() level.
   * does not involve the quad store.
   *
   *  Returns promise of Response
   *  If data is returned, copies it to response.responseText before returning
   */
  webOperation(method, uriIn, options = {}) {
    const uri = termValue(uriIn);
    options.method = method;
    options.body = options.data || options.body;
    options.force = true;
    const fetcher2 = this;
    if (options.body && !options.contentType) {
      throw new Error("Web operation sending data must have a defined contentType.");
    }
    if (options.contentType) {
      options.headers = options.headers || {};
      options.headers["content-type"] = options.contentType;
    }
    _Fetcher.setCredentials(uri, options);
    return new Promise(function(resolve, reject) {
      fetcher2._fetch(uri, options).then((response) => {
        if (response.ok) {
          if (method === "PUT" || method === "PATCH" || method === "POST" || method === "DELETE") {
            fetcher2.invalidateCache(uri);
          }
          if (response.text) {
            response.text().then((data) => {
              response.responseText = data;
              resolve(response);
            });
          } else {
            resolve(response);
          }
        } else {
          let msg = "Web error: " + response.status;
          if (response.statusText) msg += " (" + response.statusText + ")";
          msg += " on " + method + " of <" + uri + ">";
          if (response.responseText) msg += ": " + response.responseText;
          let e2 = new Error(msg);
          e2.response = response;
          reject(e2);
        }
      }, (err) => {
        let msg = "Fetch error for " + method + " of <" + uri + ">:" + err;
        reject(new Error(msg));
      });
    });
  }
  /**
   * Looks up something.
   * Looks up all the URIs a things has.
   *
   * @param term - canonical term for the thing whose URI is
   *   to be dereferenced
   * @param rterm - the resource which referred to this
   *   (for tracking bad links)
   */
  lookUpThing(term2, rterm) {
    let uris = this.store.uris(term2);
    uris = uris.map((u) => docpart(u));
    uris.forEach((u) => {
      this.lookedUp[u] = true;
    });
    return this.load(uris, {
      referringTerm: rterm
    });
  }
  /**
   * Looks up response header.
   *
   * @returns {Array|undefined} a list of header values found in a stored HTTP
   *   response, or [] if response was found but no header found,
   *   or undefined if no response is available.
   * Looks for { [] link:requestedURI ?uri; link:response [ httph:header-name  ?value ] }
   */
  getHeader(doc, header) {
    const kb = this.store;
    const docuri = doc.value;
    const requests = kb.each(void 0, this.ns.link("requestedURI"), kb.rdfFactory.literal(docuri));
    for (let r = 0; r < requests.length; r++) {
      let request = requests[r];
      if (request !== void 0) {
        let response = kb.any(request, this.ns.link("response"));
        if (response !== void 0 && kb.anyValue(response, this.ns.http("status")) && kb.anyValue(response, this.ns.http("status")).startsWith("2")) {
          let results = kb.each(response, this.ns.httph(header.toLowerCase()));
          if (results.length) {
            return results.map((v) => {
              return v.value;
            });
          }
          return [];
        }
      }
    }
    return void 0;
  }
  saveRequestMetadata(docuri, options) {
    let req = options.req;
    let kb = this.store;
    let rterm = options.referringTerm;
    this.addStatus(options.req, "Accept: " + options.headers["accept"]);
    if (isNamedNode(rterm)) {
      kb.add(kb.rdfFactory.namedNode(docuri), this.ns.link("requestedBy"), rterm, this.appNode);
    }
    if (options.original && options.original.value !== docuri) {
      kb.add(req, this.ns.link("orginalURI"), kb.rdfFactory.literal(options.original.value), this.appNode);
    }
    const now = /* @__PURE__ */ new Date();
    const timeNow = "[" + now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds() + "] ";
    kb.add(req, this.ns.rdfs("label"), kb.rdfFactory.literal(timeNow + " Request for " + docuri), this.appNode);
    kb.add(req, this.ns.link("requestedURI"), kb.rdfFactory.literal(docuri), this.appNode);
    kb.add(req, this.ns.link("status"), kb.collection(), this.appNode);
  }
  saveResponseMetadata(response, options) {
    const kb = this.store;
    let responseNode = kb.bnode();
    kb.add(options.req, this.ns.link("response"), responseNode, this.appNode);
    kb.add(responseNode, this.ns.http("status"), kb.rdfFactory.literal(response.status), this.appNode);
    kb.add(responseNode, this.ns.http("statusText"), kb.rdfFactory.literal(response.statusText), this.appNode);
    response.headers.forEach((value, header) => {
      kb.add(responseNode, this.ns.httph(header), this.store.rdfFactory.literal(value), this.appNode);
      if (header === "content-type") {
        kb.add(
          options.resource,
          this.ns.rdf("type"),
          kb.rdfFactory.namedNode(mediaTypeClass(value).value),
          this.appNode
          // responseNode
        );
      }
    });
    return responseNode;
  }
  objectRefresh(term2) {
    let uris = this.store.uris(term2);
    if (typeof uris !== "undefined") {
      for (let i = 0; i < uris.length; i++) {
        this.refresh(this.store.rdfFactory.namedNode(docpart(uris[i])));
      }
    }
  }
  /* refresh  Reload data from a given document
  **
  ** @param term - An RDF Named Node for the eodcument in question
  ** @param userCallback - A function userCallback(ok, message, response)
  */
  refresh(term2, userCallback) {
    this.fireCallbacks("refresh", arguments);
    this.nowOrWhenFetched(term2, {
      force: true,
      clearPreviousData: true
    }, userCallback);
  }
  /* refreshIfExpired   Conditional refresh if Expired
  **
  ** @param term - An RDF Named Node for the eodcument in question
  ** @param userCallback - A function userCallback(ok, message, response)
  */
  refreshIfExpired(term2, userCallback) {
    let exp = this.getHeader(term2, "Expires");
    if (!exp || new Date(exp[0]).getTime() <= (/* @__PURE__ */ new Date()).getTime()) {
      this.refresh(term2, userCallback);
    } else {
      userCallback(true, "Not expired", {});
    }
  }
  retract(term2) {
    this.store.removeMany(void 0, void 0, void 0, term2);
    if (term2.value) {
      delete this.requested[docpart(term2.value)];
    }
    this.fireCallbacks("retract", arguments);
  }
  getState(docuri) {
    if (typeof this.requested[docuri] === "undefined") {
      return "unrequested";
    } else if (this.requested[docuri] === true) {
      return "requested";
    } else if (this.requested[docuri] === "done") {
      return "fetched";
    } else if (this.requested[docuri] === "redirected") {
      return this.getState(this.redirectedTo[docuri]);
    } else {
      return "failed";
    }
  }
  isPending(docuri) {
    return this.requested[docuri] === true;
  }
  unload(term2) {
    this.store.removeDocument(term2);
    delete this.requested[term2.value];
  }
  addHandler(handler) {
    this.handlers.push(handler);
    handler.register(this);
  }
  retryNoCredentials(docuri, options) {
    options.retriedWithNoCredentials = true;
    delete this.requested[docuri];
    delete this.fetchQueue[docuri];
    let newOptions = Object.assign({}, options, {
      credentials: "omit"
    });
    this.addStatus(options.req, "Abort: Will retry with credentials SUPPRESSED to see if that helps");
    return this.load(docuri, newOptions);
  }
  /**
   * Tests whether a request is being made to a cross-site URI (for purposes
   * of retrying with a proxy)
   */
  isCrossSite(uri) {
    if (typeof document === "undefined" || !document.location) {
      return false;
    }
    const hostpart2 = hostpart;
    const here = "" + document.location;
    return (hostpart2(here) && hostpart2(uri) && hostpart2(here)) !== hostpart2(uri);
  }
  /**
   * Called when there's a network error in fetch(), or a response
   * with status of 0.
   */
  handleError(response, docuri, options) {
    if (this.isCrossSite(docuri)) {
      if (options.credentials && options.credentials === "include" && !options.retriedWithNoCredentials) {
        return this.retryNoCredentials(docuri, options);
      }
      let proxyUri = _Fetcher.crossSiteProxy(docuri);
      if (proxyUri && !options.proxyUsed) {
        return this.redirectToProxy(proxyUri, options);
      }
    }
    var message;
    if (response instanceof Error) {
      message = "Fetch error: " + response.message;
    } else {
      message = response.statusText;
      if (response.responseText) {
        message += ` ${response.responseText}`;
      }
    }
    return this.failFetch(options, message, response.status || 998, response);
  }
  // deduce some things from the HTTP transaction
  addType(rdfType, req, kb, locURI) {
    let prev = req;
    if (locURI) {
      var reqURI = kb.any(prev, this.ns.link("requestedURI"));
      if (reqURI && reqURI.value !== locURI) {
        kb.add(kb.rdfFactory.namedNode(locURI), this.ns.rdf("type"), rdfType, this.appNode);
      }
    }
    for (; ; ) {
      const doc = kb.any(prev, this.ns.link("requestedURI"));
      if (doc && doc.value) {
        kb.add(kb.rdfFactory.namedNode(doc.value), this.ns.rdf("type"), rdfType, this.appNode);
      }
      prev = kb.any(void 0, kb.rdfFactory.namedNode("http://www.w3.org/2007/ont/link#redirectedRequest"), prev);
      if (!prev) {
        break;
      }
      var response = kb.any(prev, kb.rdfFactory.namedNode("http://www.w3.org/2007/ont/link#response"));
      if (!response) {
        break;
      }
      var redirection = kb.any(response, kb.rdfFactory.namedNode("http://www.w3.org/2007/ont/http#status"));
      if (!redirection) {
        break;
      }
      if (redirection !== "301" && redirection !== "302") {
        break;
      }
    }
  }
  /**
   * Handle fetch() response
   */
  handleResponse(response, docuri, options) {
    const kb = this.store;
    const headers = response.headers;
    const reqNode = options.req;
    const responseNode = this.saveResponseMetadata(response, options);
    const contentType = this.normalizedContentType(options, headers) || "";
    let contentLocation = headers.get("content-location");
    if (response.status === 0) {
      return this.handleError(response, docuri, options);
    }
    if (response.status >= 400) {
      if (response.status === 404) {
        this.nonexistent[options.original.value] = true;
        this.nonexistent[docuri] = true;
      }
      return this.saveErrorResponse(response, responseNode).then(() => {
        let errorMessage = options.resource + " " + response.statusText;
        return this.failFetch(options, errorMessage, response.status, response);
      });
    }
    var diffLocation = null;
    var absContentLocation = null;
    if (contentLocation) {
      absContentLocation = join(contentLocation, docuri);
      if (absContentLocation !== docuri) {
        diffLocation = absContentLocation;
      }
    }
    if (response.status === 200) {
      this.addType(this.ns.link("Document"), reqNode, kb, docuri);
      if (diffLocation) {
        this.addType(this.ns.link("Document"), reqNode, kb, diffLocation);
      }
      if (options.clearPreviousData) {
        const sts = kb.statementsMatching(void 0, void 0, void 0, options.resource).slice();
        for (let i = 0; i < sts.length; i++) {
          kb.removeStatement(sts[i]);
        }
      }
      let isImage = contentType.includes("image/") || contentType.includes("application/pdf");
      if (contentType && isImage) {
        this.addType(kb.rdfFactory.namedNode("http://purl.org/dc/terms/Image"), reqNode, kb, docuri);
        if (diffLocation) {
          this.addType(kb.rdfFactory.namedNode("http://purl.org/dc/terms/Image"), reqNode, kb, diffLocation);
        }
      }
    }
    if (contentLocation) {
      if (!options.force && diffLocation && this.requested[absContentLocation] === "done") {
        return this.doneFetch(options, response);
      }
      this.requested[absContentLocation] = true;
    }
    this.parseLinkHeader(headers.get("link"), options.original, reqNode);
    let handler = this.handlerForContentType(contentType, response);
    if (!handler) {
      this.addStatus(reqNode, "Fetch over. No data handled.");
      return this.doneFetch(options, response);
    }
    return response.text().then((responseText) => {
      response.responseText = responseText;
      return handler.parse(this, responseText, options, response);
    });
  }
  saveErrorResponse(response, responseNode) {
    let kb = this.store;
    return response.text().then((content) => {
      if (content.length > 10) {
        kb.add(responseNode, this.ns.http("content"), kb.rdfFactory.literal(content), responseNode);
      }
    });
  }
  handlerForContentType(contentType, response) {
    if (!contentType) {
      return null;
    }
    let Handler2 = this.handlers.find((handler) => {
      return contentType.match(handler.pattern);
    });
    return Handler2 ? new Handler2(response) : null;
  }
  guessContentType(uri) {
    return CONTENT_TYPE_BY_EXT[uri.split(".").pop()];
  }
  normalizedContentType(options, headers) {
    if (options.forceContentType) {
      return options.forceContentType;
    }
    let contentType = headers.get("content-type");
    if (!contentType || contentType.includes("application/octet-stream")) {
      let guess = this.guessContentType(options.resource.value);
      if (guess) {
        return guess;
      }
    }
    let protocol2 = protocol(options.resource.value);
    if (!contentType && ["file", "chrome"].includes(protocol2)) {
      return "text/xml";
    }
    return contentType;
  }
  /**
   * Sends a new request to the specified uri. (Extracted from `onerrorFactory()`)
   */
  redirectToProxy(newURI, options) {
    this.addStatus(options.req, "BLOCKED -> Cross-site Proxy to <" + newURI + ">");
    options.proxyUsed = true;
    const kb = this.store;
    const oldReq = options.req;
    if (!options.noMeta) {
      kb.add(oldReq, this.ns.link("redirectedTo"), kb.rdfFactory.namedNode(newURI), oldReq);
      this.addStatus(oldReq, "redirected to new request");
    }
    this.requested[options.resource.value] = "redirected";
    this.redirectedTo[options.resource.value] = newURI;
    let newOptions = Object.assign({}, options);
    newOptions.baseURI = options.resource.value;
    return this.fetchUri(newURI, newOptions).then((response) => {
      if (!newOptions.noMeta) {
        kb.add(oldReq, this.ns.link("redirectedRequest"), newOptions.req, this.appNode);
      }
      return response;
    });
  }
  setRequestTimeout(uri, options) {
    return new Promise((resolve) => {
      this.timeouts[uri] = (this.timeouts[uri] || []).concat(setTimeout(() => {
        if (this.isPending(uri) && !options.retriedWithNoCredentials && !options.proxyUsed) {
          resolve(this.failFetch(options, `Request to ${uri} timed out`, "timeout"));
        }
      }, this.timeout));
    });
  }
  addFetchCallback(uri, callback) {
    if (!this.fetchCallbacks[uri]) {
      this.fetchCallbacks[uri] = [callback];
    } else {
      this.fetchCallbacks[uri].push(callback);
    }
  }
  acceptString() {
    let acceptstring = "";
    for (let mediaType in this.mediatypes) {
      if (acceptstring !== "") {
        acceptstring += ", ";
      }
      acceptstring += mediaType;
      for (let property in this.mediatypes[mediaType]) {
        acceptstring += ";" + property + "=" + this.mediatypes[mediaType][property];
      }
    }
    return acceptstring;
  }
  // var updatesVia = new $rdf.UpdatesVia(this) // Subscribe to headers
  // @@@@@@@@ This is turned off because it causes a websocket to be set up for ANY fetch
  // whether we want to track it ot not. including ontologies loaed though the XSSproxy
};
_defineProperty(Fetcher, "HANDLERS", void 0);
_defineProperty(Fetcher, "CONTENT_TYPE_BY_EXT", void 0);
_defineProperty(Fetcher, "crossSiteProxyTemplate", void 0);
Fetcher.HANDLERS = defaultHandlers;
Fetcher.CONTENT_TYPE_BY_EXT = CONTENT_TYPE_BY_EXT;

// node_modules/rdflib/esm/jsonparser.js
var jsonparser_default = /* @__PURE__ */ function() {
  return {
    parseJSON: function(data, source, store) {
      var subject, predicate, object;
      var bnodes = {};
      var why = store.sym(source);
      for (var x in data) {
        if (x.indexOf("_:") === 0) {
          if (bnodes[x]) {
            subject = bnodes[x];
          } else {
            subject = store.bnode(x);
            bnodes[x] = subject;
          }
        } else {
          subject = store.sym(x);
        }
        var preds = data[x];
        for (var y in preds) {
          var objects = preds[y];
          predicate = store.sym(y);
          for (var z in objects) {
            var obj = objects[z];
            if (obj.type === "uri") {
              object = store.sym(obj.value);
              store.add(subject, predicate, object, why);
            } else if (obj.type === "BlankNode") {
              if (bnodes[obj.value]) {
                object = bnodes[obj.value];
              } else {
                object = store.bnode(obj.value);
                bnodes[obj.value] = object;
              }
              store.add(subject, predicate, object, why);
            } else if (obj.type === "Literal") {
              if (obj.datatype) {
                object = store.literal(obj.value, void 0, store.sym(obj.datatype));
              } else if (obj.lang) {
                object = store.literal(obj.value, obj.lang);
              } else {
                object = store.literal(obj.value);
              }
              store.add(subject, predicate, object, why);
            } else {
              throw new Error("error: unexpected termtype: " + z.type);
            }
          }
        }
      }
    }
  };
}();

// node_modules/rdflib/esm/query-to-sparql.js
function queryToSPARQL(query) {
  var indent = 0;
  function getSelect(query2) {
    var str = addIndent() + "SELECT ";
    for (var i = 0; i < query2.vars.length; i++) {
      str += query2.vars[i] + " ";
    }
    str += "\n";
    return str;
  }
  function getPattern(pat) {
    var str = "";
    var st2 = pat.statements;
    for (var x in st2) {
      log_default.debug("Found statement: " + st2);
      str += addIndent() + st2[x] + "\n";
    }
    return str;
  }
  function getConstraints(pat) {
    var str = "";
    for (var v in pat.constraints) {
      var foo = pat.constraints[v];
      str += addIndent() + "FILTER ( " + foo.describe(v) + " ) \n";
    }
    return str;
  }
  function getOptionals(pat) {
    var str = "";
    for (var x = 0; x < pat.optional.length; x++) {
      log_default.debug("Found optional query");
      str += addIndent() + "OPTIONAL { \n";
      indent++;
      str += getPattern(pat.optional[x]);
      str += getConstraints(pat.optional[x]);
      str += getOptionals(pat.optional[x]);
      indent--;
      str += addIndent() + "}\n";
    }
    return str;
  }
  function getWhere(pat) {
    var str = addIndent() + "WHERE \n{ \n";
    indent++;
    str += getPattern(pat);
    str += getConstraints(pat);
    str += getOptionals(pat);
    indent--;
    str += "}";
    return str;
  }
  function addIndent() {
    var str = "";
    for (var i = 0; i < indent; i++) {
      str += "    ";
    }
    return str;
  }
  function getSPARQL(query2) {
    return getSelect(query2) + getWhere(query2.pat);
  }
  return getSPARQL(query);
}

// node_modules/rdflib/esm/sparql-to-query.js
function SPARQLToQuery(SPARQL, testMode, kb) {
  var variableHash = [];
  function makeVar(name) {
    if (variableHash[name]) {
      return variableHash[name];
    }
    var newVar = kb.variable(name);
    variableHash[name] = newVar;
    return newVar;
  }
  function isRealText(term2) {
    return typeof term2 === "string" && term2.match(/[^ \n\t]/);
  }
  function isVar(term2) {
    return typeof term2 === "string" && term2.match(/^[\?\$]/);
  }
  function fixSymbolBrackets(term2) {
    if (typeof term2 === "string") {
      return term2.replace(/^&lt;/, "<").replace(/&gt;$/, ">");
    } else {
      return term2;
    }
  }
  function isSymbol(term2) {
    return typeof term2 === "string" && term2.match(/^<[^>]*>$/);
  }
  function isBnode(term2) {
    return typeof term2 === "string" && (term2.match(/^_:/) || term2.match(/^$/));
  }
  function isPrefix(term2) {
    return typeof term2 === "string" && term2.match(/:$/);
  }
  function isPrefixedSymbol(term2) {
    return typeof term2 === "string" && term2.match(/^:|^[^_][^:]*:/);
  }
  function getPrefix(term2) {
    var a = term2.split(":");
    return a[0];
  }
  function getSuffix(term2) {
    var a = term2.split(":");
    return a[1];
  }
  function removeBrackets(term2) {
    if (isSymbol(term2)) {
      return term2.slice(1, term2.length - 1);
    } else {
      return term2;
    }
  }
  function parseLiterals(str) {
    var sin = str.indexOf("'") === -1 ? null : str.indexOf("'");
    var doub = str.indexOf('"') === -1 ? null : str.indexOf('"');
    if (!sin && !doub) {
      var a = new Array(1);
      a[0] = str;
      return a;
    }
    var res = new Array(2);
    var br;
    var ind;
    if (!sin || doub && doub < sin) {
      br = '"';
      ind = doub;
    } else if (!doub || sin && sin < doub) {
      br = "'";
      ind = sin;
    } else {
      log_default.error("SQARQL QUERY OOPS!");
      return res;
    }
    res[0] = str.slice(0, ind);
    var end = str.slice(ind + 1).indexOf(br);
    if (end === -1) {
      log_default.error("SPARQL parsing error: no matching parentheses in literal " + str);
      return str;
    }
    var end2;
    if (str.slice(end + ind + 2).match(/^\^\^/)) {
      end2 = str.slice(end + ind + 2).indexOf(" ");
      res[1] = kb.literal(str.slice(ind + 1, ind + 1 + end), kb.sym(removeBrackets(str.slice(ind + 4 + end, ind + 2 + end + end2))));
      res = res.concat(parseLiterals(str.slice(end + ind + 3 + end2)));
    } else if (str.slice(end + ind + 2).match(/^@/)) {
      end2 = str.slice(end + ind + 2).indexOf(" ");
      res[1] = kb.literal(str.slice(ind + 1, ind + 1 + end), str.slice(ind + 3 + end, ind + 2 + end + end2), null);
      res = res.concat(parseLiterals(str.slice(end + ind + 2 + end2)));
    } else {
      res[1] = kb.literal(str.slice(ind + 1, ind + 1 + end));
      log_default.info("Literal found: " + res[1]);
      res = res.concat(parseLiterals(str.slice(end + ind + 2)));
    }
    return res;
  }
  function spaceDelimit(str) {
    str = str.replace(/\(/g, " ( ").replace(/\)/g, " ) ").replace(/</g, " <").replace(/>/g, "> ").replace(/{/g, " { ").replace(/}/g, " } ").replace(/[\t\n\r]/g, " ").replace(/; /g, " ; ").replace(/\. /g, " . ").replace(/, /g, " , ");
    log_default.info("New str into spaceDelimit: \n" + str);
    var res = [];
    var br = str.split(" ");
    for (var x2 in br) {
      if (isRealText(br[x2])) {
        res = res.concat(br[x2]);
      }
    }
    return res;
  }
  function replaceKeywords(input) {
    var strarr = input;
    for (var x2 = 0; x2 < strarr.length; x2++) {
      if (strarr[x2] === "a") {
        strarr[x2] = "<http://www.w3.org/1999/02/22-rdf-syntax-ns#type>";
      }
      if (strarr[x2] === "is" && strarr[x2 + 2] === "of") {
        strarr.splice(x2, 1);
        strarr.splice(x2 + 1, 1);
        var s = strarr[x2 - 1];
        strarr[x2 - 1] = strarr[x2 + 1];
        strarr[x2 + 1] = s;
      }
    }
    return strarr;
  }
  function toTerms(input) {
    var res = [];
    for (var x2 = 0; x2 < input.length; x2++) {
      if (typeof input[x2] !== "string") {
        res[x2] = input[x2];
        continue;
      }
      input[x2] = fixSymbolBrackets(input[x2]);
      if (isVar(input[x2])) {
        res[x2] = makeVar(input[x2].slice(1));
      } else if (isBnode(input[x2])) {
        log_default.info(input[x2] + " was identified as a bnode.");
        res[x2] = kb.bnode();
      } else if (isSymbol(input[x2])) {
        log_default.info(input[x2] + " was identified as a symbol.");
        res[x2] = kb.sym(removeBrackets(input[x2]));
      } else if (isPrefixedSymbol(input[x2])) {
        log_default.info(input[x2] + " was identified as a prefixed symbol");
        if (prefixes[getPrefix(input[x2])]) {
          res[x2] = kb.sym(input[x2] = prefixes[getPrefix(input[x2])] + getSuffix(input[x2]));
        } else {
          log_default.error("SPARQL error: " + input[x2] + " with prefix " + getPrefix(input[x2]) + " does not have a correct prefix entry.");
          res[x2] = input[x2];
        }
      } else {
        res[x2] = input[x2];
      }
    }
    return res;
  }
  function tokenize(str) {
    var token1 = parseLiterals(str);
    var token2 = [];
    for (var x2 in token1) {
      if (typeof token1[x2] === "string") {
        token2 = token2.concat(spaceDelimit(token1[x2]));
      } else {
        token2 = token2.concat(token1[x2]);
      }
    }
    token2 = replaceKeywords(token2);
    log_default.info("SPARQL Tokens: " + token2);
    return token2;
  }
  function arrayIndexOf(str, arr) {
    for (var i = 0; i < arr.length; i++) {
      if (typeof arr[i] !== "string") {
        continue;
      }
      if (arr[i].toLowerCase() === str.toLowerCase()) {
        return i;
      }
    }
    return null;
  }
  function arrayIndicesOf(str, arr) {
    var ind = [];
    for (var i = 0; i < arr.length; i++) {
      if (typeof arr[i] !== "string") {
        continue;
      }
      if (arr[i].toLowerCase() === str.toLowerCase()) {
        ind.push(i);
      }
    }
    return ind;
  }
  function setVars(input, query) {
    log_default.info("SPARQL vars: " + input);
    for (var x2 in input) {
      if (isVar(input[x2])) {
        log_default.info("Added " + input[x2] + " to query variables from SPARQL");
        var v = makeVar(input[x2].slice(1));
        query.vars.push(v);
        v.label = input[x2].slice(1);
      } else {
        log_default.warn("Incorrect SPARQL variable in SELECT: " + input[x2]);
      }
    }
  }
  function getPrefixDeclarations(input) {
    var prefInd = arrayIndicesOf("PREFIX", input);
    var res = [];
    for (var i in prefInd) {
      var a = input[prefInd[i] + 1];
      var b = input[prefInd[i] + 2];
      if (!isPrefix(a)) {
        log_default.error("Invalid SPARQL prefix: " + a);
      } else if (!isSymbol(b)) {
        log_default.error("Invalid SPARQL symbol: " + b);
      } else {
        log_default.info("Prefix found: " + a + " -> " + b);
        var pref = getPrefix(a);
        var symbol = removeBrackets(b);
        res[pref] = symbol;
      }
    }
    return res;
  }
  function getMatchingBracket(arr, open, close) {
    log_default.info("Looking for a close bracket of type " + close + " in " + arr);
    var index = 0;
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] === open) {
        index++;
      }
      if (arr[i] === close) {
        index--;
      }
      if (index < 0) {
        return i;
      }
    }
    log_default.error("Statement had no close parenthesis in SPARQL query");
    return 0;
  }
  function constraintGreaterThan(value) {
    this.describe = function(varstr) {
      return varstr + " > " + value.toNT();
    };
    this.test = function(term2) {
      if (term2.value.match(/[0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)?/)) {
        return parseFloat(term2.value) > parseFloat(value);
      } else {
        return term2.toNT() > value.toNT();
      }
    };
    return this;
  }
  function constraintLessThan(value) {
    this.describe = function(varstr) {
      return varstr + " < " + value.toNT();
    };
    this.test = function(term2) {
      if (term2.value.match(/[0-9]+(\.[0-9]+)?([eE][+-]?[0-9]+)?/)) {
        return parseFloat(term2.value) < parseFloat(value);
      } else {
        return term2.toNT() < value.toNT();
      }
    };
    return this;
  }
  function ConstraintEqualTo(value) {
    this.describe = function(varstr) {
      return varstr + " = " + value.toNT();
    };
    this.test = function(term2) {
      return value.equals(term2);
    };
    return this;
  }
  function ConstraintRegexp(value) {
    this.describe = function(varstr) {
      return "REGEXP( '" + value + "' , " + varstr + " )";
    };
    this.test = function(term2) {
      var str = value;
      var rg = new RegExp(str);
      if (term2.value) {
        return rg.test(term2.value);
      } else {
        return false;
      }
    };
  }
  function setConstraint(input, pat) {
    if (input.length === 3 && input[0].termType === "Variable" && (input[2].termType === "NamedNode" || input[2].termType === "Literal")) {
      if (input[1] === "=") {
        log_default.debug("Constraint added: " + input);
        pat.constraints[input[0]] = new ConstraintEqualTo(input[2]);
      } else if (input[1] === ">") {
        log_default.debug("Constraint added: " + input);
        pat.constraints[input[0]] = new ConstraintEqualTo(input[2]);
      } else if (input[1] === "<") {
        log_default.debug("Constraint added: " + input);
        pat.constraints[input[0]] = new ConstraintEqualTo(input[2]);
      } else {
        log_default.warn("I don't know how to handle the constraint: " + input);
      }
    } else if (input.length === 6 && typeof input[0] === "string" && input[0].toLowerCase() === "regexp" && input[1] === "(" && input[5] === ")" && input[3] === "," && input[4].termType === "Variable" && input[2].termType === "Literal") {
      log_default.debug("Constraint added: " + input);
      pat.constraints[input[4]] = new ConstraintRegexp(input[2].value);
    }
  }
  function setOptional(terms, pat) {
    log_default.debug("Optional query: " + terms + " not yet implemented.");
    var opt = kb.formula();
    setWhere(terms, opt);
    pat.optional.push(opt);
  }
  function setWhere(input, pat) {
    var terms = toTerms(input);
    var end;
    log_default.debug("WHERE: " + terms);
    var opt;
    while (arrayIndexOf("OPTIONAL", terms)) {
      opt = arrayIndexOf("OPTIONAL", terms);
      log_default.debug("OPT: " + opt + " " + terms[opt] + " in " + terms);
      if (terms[opt + 1] !== "{") {
        log_default.warn("Bad optional opening bracket in word " + opt);
      }
      end = getMatchingBracket(terms.slice(opt + 2), "{", "}");
      if (end === -1) {
        log_default.error("No matching bracket in word " + opt);
      } else {
        setOptional(terms.slice(opt + 2, opt + 2 + end), pat);
        opt = arrayIndexOf("OPTIONAL", terms);
        end = getMatchingBracket(terms.slice(opt + 2), "{", "}");
        terms.splice(opt, end + 3);
      }
    }
    log_default.debug("WHERE after optionals: " + terms);
    while (arrayIndexOf("FILTER", terms)) {
      var filt = arrayIndexOf("FILTER", terms);
      if (terms[filt + 1] !== "(") {
        log_default.warn("Bad filter opening bracket in word " + filt);
      }
      end = getMatchingBracket(terms.slice(filt + 2), "(", ")");
      if (end === -1) {
        log_default.error("No matching bracket in word " + filt);
      } else {
        setConstraint(terms.slice(filt + 2, filt + 2 + end), pat);
        filt = arrayIndexOf("FILTER", terms);
        end = getMatchingBracket(terms.slice(filt + 2), "(", ")");
        terms.splice(filt, end + 3);
      }
    }
    log_default.debug("WHERE after filters and optionals: " + terms);
    extractStatements(terms, pat);
  }
  function extractStatements(terms, formula2) {
    var arrayZero = new Array(1);
    arrayZero[0] = -1;
    var per = arrayZero.concat(arrayIndicesOf(".", terms));
    var stat = [];
    for (var x2 = 0; x2 < per.length - 1; x2++) {
      stat[x2] = terms.slice(per[x2] + 1, per[x2 + 1]);
    }
    for (x2 in stat) {
      log_default.info("s+p+o " + x2 + " = " + stat[x2]);
      var subj = stat[x2][0];
      stat[x2].splice(0, 1);
      var sem = arrayZero.concat(arrayIndicesOf(";", stat[x2]));
      sem.push(stat[x2].length);
      var stat2 = [];
      for (var y = 0; y < sem.length - 1; y++) {
        stat2[y] = stat[x2].slice(sem[y] + 1, sem[y + 1]);
      }
      for (x2 in stat2) {
        log_default.info("p+o " + x2 + " = " + stat[x2]);
        var pred = stat2[x2][0];
        stat2[x2].splice(0, 1);
        var com = arrayZero.concat(arrayIndicesOf(",", stat2[x2]));
        com.push(stat2[x2].length);
        var stat3 = [];
        for (y = 0; y < com.length - 1; y++) {
          stat3[y] = stat2[x2].slice(com[y] + 1, com[y + 1]);
        }
        for (x2 in stat3) {
          var obj = stat3[x2][0];
          log_default.info("Subj=" + subj + " Pred=" + pred + " Obj=" + obj);
          formula2.add(subj, pred, obj);
        }
      }
    }
  }
  log_default.info("SPARQL input: \n" + SPARQL);
  var q = new Query();
  var sp = tokenize(SPARQL);
  var prefixes = getPrefixDeclarations(sp);
  if (!prefixes.rdf) {
    prefixes.rdf = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
  }
  if (!prefixes.rdfs) {
    prefixes.rdfs = "http://www.w3.org/2000/01/rdf-schema#";
  }
  var selectLoc = arrayIndexOf("SELECT", sp);
  var whereLoc = arrayIndexOf("WHERE", sp);
  if (selectLoc < 0 || whereLoc < 0 || selectLoc > whereLoc) {
    log_default.error("Invalid or nonexistent SELECT and WHERE tags in SPARQL query");
    return false;
  }
  setVars(sp.slice(selectLoc + 1, whereLoc), q);
  setWhere(sp.slice(whereLoc + 2, sp.length - 1), q.pat);
  if (testMode) {
    return q;
  }
  for (var x in q.pat.statements) {
    var st2 = q.pat.statements[x];
    if (st2.subject.termType === "NamedNode") {
      if (kb.fetcher) {
        kb.fetcher.lookUpThing(st2.subject, "sparql:" + st2.subject);
      }
    }
    if (st2.object.termType === "NamedNode") {
      if (kb.fetcher) {
        kb.fetcher.lookUpThing(st2.object, "sparql:" + st2.object);
      }
    }
  }
  return q;
}

// node_modules/rdflib/esm/update-manager.js
var UpdateManager = class {
  /**
   * @param  store - The quadstore to store data and metadata. Created if not passed.
  */
  constructor(store) {
    _defineProperty(this, "store", void 0);
    _defineProperty(this, "ifps", void 0);
    _defineProperty(this, "fps", void 0);
    _defineProperty(this, "patchControl", void 0);
    _defineProperty(this, "ns", void 0);
    store = store || new IndexedFormula();
    if (store.updater) {
      throw new Error("You can't have two UpdateManagers for the same store");
    }
    if (!store.fetcher) {
      store.fetcher = new Fetcher(store);
    }
    this.store = store;
    store.updater = this;
    this.ifps = {};
    this.fps = {};
    this.ns = {};
    this.ns.link = Namespace("http://www.w3.org/2007/ont/link#");
    this.ns.http = Namespace("http://www.w3.org/2007/ont/http#");
    this.ns.httph = Namespace("http://www.w3.org/2007/ont/httph#");
    this.ns.ldp = Namespace("http://www.w3.org/ns/ldp#");
    this.ns.rdf = Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
    this.ns.rdfs = Namespace("http://www.w3.org/2000/01/rdf-schema#");
    this.ns.rdf = Namespace("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
    this.ns.owl = Namespace("http://www.w3.org/2002/07/owl#");
    this.patchControl = [];
  }
  patchControlFor(doc) {
    if (!this.patchControl[doc.value]) {
      this.patchControl[doc.value] = [];
    }
    return this.patchControl[doc.value];
  }
  isHttpUri(uri) {
    return uri.slice(0, 4) === "http";
  }
  /** Remove from the store HTTP authorization metadata
  * The editable function below relies on copies we have in the store
  * of the results of previous HTTP transactions. However, when
  * the user logs in, then that data misrepresents what would happen
  * if the user tried again.
  */
  flagAuthorizationMetadata(kb) {
    var _a;
    if (!kb) {
      kb = this.store;
    }
    const meta = (_a = kb.fetcher) == null ? void 0 : _a.appNode;
    const requests = kb.statementsMatching(void 0, this.ns.link("requestedURI"), void 0, meta).map((st2) => st2.subject);
    for (const request of requests) {
      const response = kb.any(request, this.ns.link("response"), null, meta);
      if (response != void 0) {
        kb.add(response, this.ns.link("outOfDate"), true, meta);
      }
    }
  }
  /**
   * Tests whether a file is editable.
   * If the file has a specific annotation that it is machine written,
   * for safety, it is editable (this doesn't actually check for write access)
   * If the file has wac-allow and accept patch headers, those are respected.
   * and local write access is determined by those headers.
   * This async version not only looks at past HTTP requests, it also makes new ones if necessary.
   *
   * @returns The method string N3PATCH or SPARQL or DAV or
   *   LOCALFILE or false if known, undefined if not known.
   */
  async checkEditable(uri, kb) {
    var _a;
    if (!uri) {
      return false;
    }
    if (!kb) {
      kb = this.store;
    }
    const initial = this.editable(uri, kb);
    if (initial !== void 0) {
      return initial;
    }
    await ((_a = kb.fetcher) == null ? void 0 : _a.load(uri));
    const final = this.editable(uri, kb);
    return final;
  }
  /**
   * Tests whether a file is editable.
   * If the file has a specific annotation that it is machine written,
   * for safety, it is editable (this doesn't actually check for write access)
   * If the file has wac-allow and accept patch headers, those are respected.
   * and local write access is determined by those headers.
   * This synchronous version only looks at past HTTP requests, does not make new ones.
   *
   * @returns The method string SPARQL or DAV or
   *   LOCALFILE or false if known, undefined if not known.
   */
  editable(uri, kb) {
    var _a;
    if (!uri) {
      return false;
    }
    if (!kb) {
      kb = this.store;
    }
    uri = termValue(uri);
    if (!this.isHttpUri(uri)) {
      if (kb.holds(kb.rdfFactory.namedNode(uri), kb.rdfFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), kb.rdfFactory.namedNode("http://www.w3.org/2007/ont/link#MachineEditableDocument"))) {
        return "LOCALFILE";
      }
    }
    var request;
    var definitive = false;
    const meta = (_a = kb.fetcher) == null ? void 0 : _a.appNode;
    var requests = kb.each(void 0, this.ns.link("requestedURI"), docpart(uri), meta);
    var method;
    for (var r = 0; r < requests.length; r++) {
      request = requests[r];
      if (request !== void 0) {
        const response = kb.any(request, this.ns.link("response"), null, meta);
        if (response !== void 0) {
          const outOfDate = kb.anyJS(response, this.ns.link("outOfDate"), null, meta);
          if (outOfDate) continue;
          var wacAllow = kb.anyValue(response, this.ns.httph("wac-allow"));
          if (wacAllow) {
            for (var bit of wacAllow.split(",")) {
              var lr = bit.split("=");
              if (lr[0].includes("user") && !lr[1].includes("write") && !lr[1].includes("append")) {
                return false;
              }
            }
          }
          var acceptPatch = kb.each(response, this.ns.httph("accept-patch"));
          if (acceptPatch.length) {
            for (let i = 0; i < acceptPatch.length; i++) {
              method = acceptPatch[i].value.trim();
              if (method.indexOf("application/sparql-update") >= 0) return "SPARQL";
              if (method.indexOf("application/sparql-update-single-match") >= 0) return "SPARQL";
              if (method.indexOf("text/n3") >= 0) return "N3PATCH";
            }
          }
          var authorVia = kb.each(response, this.ns.httph("ms-author-via"));
          if (authorVia.length) {
            for (let i = 0; i < authorVia.length; i++) {
              method = authorVia[i].value.trim();
              if (method.indexOf("SPARQL") >= 0) {
                return "SPARQL";
              }
              if (method.indexOf("DAV") >= 0) {
                return "DAV";
              }
            }
          }
          if (!this.isHttpUri(uri)) {
            if (!wacAllow) return false;
            else return "LOCALFILE";
          }
          var status = kb.each(response, this.ns.http("status"));
          if (status.length) {
            for (let i = 0; i < status.length; i++) {
              if (status[i] === 200 || status[i] === 404) {
                definitive = true;
              }
            }
          }
        } else {
        }
      }
    }
    if (requests.length === 0) {
    } else {
      if (definitive) {
        return false;
      }
    }
    return void 0;
  }
  anonymize(obj) {
    let anonymized = obj.toNT().substr(0, 2) === "_:" && this.mentioned(obj) ? "?" + obj.toNT().substr(2) : obj.toNT();
    return anonymized;
  }
  anonymizeNT(stmt) {
    return this.anonymize(stmt.subject) + " " + this.anonymize(stmt.predicate) + " " + this.anonymize(stmt.object) + " .";
  }
  nTriples(stmt) {
    return `${stmt.subject.toNT()} ${stmt.predicate.toNT()} ${stmt.object.toNT()} .`;
  }
  /**
   * Returns a list of all bnodes occurring in a statement
   * @private
   */
  statementBnodes(st2) {
    return [st2.subject, st2.predicate, st2.object].filter(function(x) {
      return isBlankNode(x);
    });
  }
  /**
   * Returns a list of all bnodes occurring in a list of statements
   * @private
   */
  statementArrayBnodes(sts) {
    var bnodes = [];
    for (let i = 0; i < sts.length; i++) {
      bnodes = bnodes.concat(this.statementBnodes(sts[i]));
    }
    bnodes.sort();
    var bnodes2 = [];
    for (let j = 0; j < bnodes.length; j++) {
      if (j === 0 || !bnodes[j].equals(bnodes[j - 1])) {
        bnodes2.push(bnodes[j]);
      }
    }
    return bnodes2;
  }
  /**
   * Makes a cached list of [Inverse-]Functional properties
   * @private
   */
  cacheIfps() {
    this.ifps = {};
    var a = this.store.each(void 0, this.ns.rdf("type"), this.ns.owl("InverseFunctionalProperty"));
    for (let i = 0; i < a.length; i++) {
      this.ifps[a[i].value] = true;
    }
    this.fps = {};
    a = this.store.each(void 0, this.ns.rdf("type"), this.ns.owl("FunctionalProperty"));
    for (let i = 0; i < a.length; i++) {
      this.fps[a[i].value] = true;
    }
  }
  /**
   * Returns a context to bind a given node, up to a given depth
   * @private
   */
  bnodeContext2(x, source, depth) {
    var sts = this.store.statementsMatching(void 0, void 0, x, source);
    var y;
    var res;
    for (let i = 0; i < sts.length; i++) {
      if (this.fps[sts[i].predicate.value]) {
        y = sts[i].subject;
        if (!y.isBlank) {
          return [sts[i]];
        }
        if (depth) {
          res = this.bnodeContext2(y, source, depth - 1);
          if (res) {
            return res.concat([sts[i]]);
          }
        }
      }
    }
    sts = this.store.statementsMatching(x, void 0, void 0, source);
    for (let i = 0; i < sts.length; i++) {
      if (this.ifps[sts[i].predicate.value]) {
        y = sts[i].object;
        if (!y.isBlank) {
          return [sts[i]];
        }
        if (depth) {
          res = this.bnodeContext2(y, source, depth - 1);
          if (res) {
            return res.concat([sts[i]]);
          }
        }
      }
    }
    return null;
  }
  /**
   * Returns the smallest context to bind a given single bnode
   * @private
   */
  bnodeContext1(x, source) {
    for (var depth = 0; depth < 3; depth++) {
      var con = this.bnodeContext2(x, source, depth);
      if (con !== null) return con;
    }
    return this.store.connectedStatements(x, source);
  }
  /**
   * @private
   */
  mentioned(x) {
    return this.store.statementsMatching(x, null, null, null).length !== 0 || // Don't pin fresh bnodes
    this.store.statementsMatching(null, x).length !== 0 || this.store.statementsMatching(null, null, x).length !== 0;
  }
  /**
   * @private
   */
  bnodeContext(bnodes, doc) {
    var context = [];
    if (bnodes.length) {
      this.cacheIfps();
      for (let i = 0; i < bnodes.length; i++) {
        var bnode = bnodes[i];
        if (!this.mentioned(bnode)) continue;
        context = context.concat(this.bnodeContext1(bnode, doc));
      }
    }
    return context;
  }
  /**
   * Returns the best context for a single statement
   * @private
   */
  statementContext(st2) {
    var bnodes = this.statementBnodes(st2);
    return this.bnodeContext(bnodes, st2.graph);
  }
  /**
   * @private
   */
  contextWhere(context) {
    var updater = this;
    return !context || context.length === 0 ? "" : "WHERE { " + context.map(function(x) {
      return updater.anonymizeNT(x);
    }).join("\n") + " }\n";
  }
  /**
   * @private
   */
  fire(uri, query, callbackFunction, options = {}) {
    return Promise.resolve().then(() => {
      if (!uri) {
        throw new Error("No URI given for remote editing operation: " + query);
      }
      options.noMeta = true;
      options.contentType = options.contentType || "application/sparql-update";
      options.body = query;
      return this.store.fetcher.webOperation("PATCH", uri, options);
    }).then((response) => {
      if (!response.ok) {
        let message = "UpdateManager: update failed for <" + uri + "> status=" + response.status + ", " + response.statusText + "\n   for query: " + query;
        throw new Error(message);
      }
      callbackFunction(uri, response.ok, response.responseText, response);
    }).catch((err) => {
      callbackFunction(uri, false, err.message, err);
    });
  }
  // ARE THESE THREE FUNCTIONS USED? DEPRECATE?
  /** return a statemnet updating function
   *
   * This does NOT update the statement.
   * It returns an object which includes
   *  function which can be used to change the object of the statement.
   */
  update_statement(statement) {
    if (statement && !statement.graph) {
      return;
    }
    var updater = this;
    var context = this.statementContext(statement);
    return {
      statement: statement ? [statement.subject, statement.predicate, statement.object, statement.graph] : void 0,
      statementNT: statement ? this.anonymizeNT(statement) : void 0,
      where: updater.contextWhere(context),
      set_object: function(obj, callbackFunction) {
        var query = this.where;
        query += "DELETE DATA { " + this.statementNT + " } ;\n";
        query += "INSERT DATA { " + // @ts-ignore `this` might refer to the wrong scope. Does this work?
        this.anonymize(this.statement[0]) + " " + // @ts-ignore
        this.anonymize(this.statement[1]) + " " + // @ts-ignore
        this.anonymize(obj) + "  . }\n";
        updater.fire(this.statement[3].value, query, callbackFunction);
      }
    };
  }
  insert_statement(st2, callbackFunction) {
    var st0 = st2 instanceof Array ? st2[0] : st2;
    var query = this.contextWhere(this.statementContext(st0));
    if (st2 instanceof Array) {
      var stText = "";
      for (let i = 0; i < st2.length; i++) stText += st2[i] + "\n";
      query += "INSERT DATA { " + stText + " }\n";
    } else {
      query += "INSERT DATA { " + this.anonymize(st2.subject) + " " + this.anonymize(st2.predicate) + " " + this.anonymize(st2.object) + "  . }\n";
    }
    this.fire(st0.graph.value, query, callbackFunction);
  }
  delete_statement(st2, callbackFunction) {
    var st0 = st2 instanceof Array ? st2[0] : st2;
    var query = this.contextWhere(this.statementContext(st0));
    if (st2 instanceof Array) {
      var stText = "";
      for (let i = 0; i < st2.length; i++) stText += st2[i] + "\n";
      query += "DELETE DATA { " + stText + " }\n";
    } else {
      query += "DELETE DATA { " + this.anonymize(st2.subject) + " " + this.anonymize(st2.predicate) + " " + this.anonymize(st2.object) + "  . }\n";
    }
    this.fire(st0.graph.value, query, callbackFunction);
  }
  /// //////////////////////
  /**
   * Requests a now or future action to refresh changes coming downstream
   * This is designed to allow the system to re-request the server version,
   * when a websocket has pinged to say there are changes.
   * If the websocket, by contrast, has sent a patch, then this may not be necessary.
   *
   * @param doc
   * @param action
   */
  requestDownstreamAction(doc, action) {
    var control = this.patchControlFor(doc);
    if (!control.pendingUpstream) {
      action(doc);
    } else {
      if (control.downstreamAction) {
        if ("" + control.downstreamAction !== "" + action) {
          throw new Error("Can't wait for > 1 different downstream actions");
        }
      } else {
        control.downstreamAction = action;
      }
    }
  }
  /**
   * We want to start counting websocket notifications
   * to distinguish the ones from others from our own.
   */
  clearUpstreamCount(doc) {
    var control = this.patchControlFor(doc);
    control.upstreamCount = 0;
  }
  getUpdatesVia(doc) {
    var linkHeaders = this.store.fetcher.getHeader(doc, "updates-via");
    if (!linkHeaders || !linkHeaders.length) return null;
    return linkHeaders[0].trim();
  }
  addDownstreamChangeListener(doc, listener) {
    var control = this.patchControlFor(doc);
    if (!control.downstreamChangeListeners) {
      control.downstreamChangeListeners = [];
    }
    control.downstreamChangeListeners.push(listener);
    this.setRefreshHandler(doc, (doc2) => {
      this.reloadAndSync(doc2);
    });
  }
  reloadAndSync(doc) {
    var control = this.patchControlFor(doc);
    var updater = this;
    if (control.reloading) {
      control.outOfDate = true;
      return;
    }
    control.reloading = true;
    var retryTimeout = 1e3;
    var tryReload = function() {
      updater.reload(updater.store, doc, function(ok, message, response) {
        if (ok) {
          if (control.downstreamChangeListeners) {
            for (let i = 0; i < control.downstreamChangeListeners.length; i++) {
              control.downstreamChangeListeners[i]();
            }
          }
          control.reloading = false;
          if (control.outOfDate) {
            control.outOfDate = false;
            tryReload();
          }
        } else {
          control.reloading = false;
          if (response && response.status === 0) {
            control.reloading = true;
            retryTimeout = retryTimeout * 2;
            setTimeout(tryReload, retryTimeout);
          } else {
          }
        }
      });
    };
    tryReload();
  }
  /**
   * Sets up websocket to listen on
   *
   * There is coordination between upstream changes and downstream ones
   * so that a reload is not done in the middle of an upstream patch.
   * If you use this API then you get called when a change happens, and you
   * have to reload the file yourself, and then refresh the UI.
   * Alternative is addDownstreamChangeListener(), where you do not
   * have to do the reload yourself. Do mot mix them.
   *
   * kb contains the HTTP  metadata from previous operations
   *
   * @param doc
   * @param handler
   *
   * @returns {boolean}
   */
  setRefreshHandler(doc, handler) {
    let wssURI = this.getUpdatesVia(doc);
    var theHandler = handler;
    var self2 = this;
    var updater = this;
    var retryTimeout = 1500;
    var retries = 0;
    if (!wssURI) {
      return false;
    }
    wssURI = join(wssURI, doc.value);
    const validWssURI = wssURI.replace(/^http:/, "ws:").replace(/^https:/, "wss:");
    var openWebsocket = function() {
      var socket;
      if (typeof WebSocket !== "undefined") {
        socket = new WebSocket(validWssURI);
      } else if (typeof window !== "undefined" && window.WebSocket) {
        socket = window.WebSocket(validWssURI);
      } else {
        return;
      }
      socket.onopen = function() {
        retryTimeout = 1500;
        this.send("sub " + doc.value);
        if (retries) {
          updater.requestDownstreamAction(doc, theHandler);
        }
      };
      var control = self2.patchControlFor(doc);
      control.upstreamCount = 0;
      socket.onerror = function onerror(err) {
      };
      socket.onclose = function(event) {
        retryTimeout *= 2;
        retries += 1;
        setTimeout(function() {
          openWebsocket();
        }, retryTimeout);
      };
      socket.onmessage = function(msg) {
        if (msg.data && msg.data.slice(0, 3) === "pub") {
          if ("upstreamCount" in control) {
            control.upstreamCount -= 1;
            if (control.upstreamCount >= 0) {
              return;
            }
          }
          control.upstreamCount = 0;
          self2.requestDownstreamAction(doc, theHandler);
        }
      };
    };
    openWebsocket();
    return true;
  }
  /**
   * This high-level function updates the local store iff the web is changed successfully.
   * Deletions, insertions may be undefined or single statements or lists or formulae (may contain bnodes which can be indirectly identified by a where clause).
   * The `why` property of each statement must be the give the web document to be updated.
   * The statements to be deleted and inserted may span more than one web document.
   * @param deletions - Statement or statements to be deleted.
   * @param insertions - Statement or statements to be inserted.
   * @returns a promise
   */
  updateMany(deletions, insertions = []) {
    const docs = deletions.concat(insertions).map((st2) => st2.why);
    const thisUpdater = this;
    const uniqueDocs = [];
    docs.forEach((doc) => {
      if (!uniqueDocs.find((uniqueDoc) => uniqueDoc.equals(doc))) uniqueDocs.push(doc);
    });
    const updates = uniqueDocs.map((doc) => thisUpdater.update(deletions.filter((st2) => st2.why.equals(doc)), insertions.filter((st2) => st2.why.equals(doc))));
    if (updates.length > 1) {
    }
    return Promise.all(updates);
  }
  /**
   * @private
   * 
   * This helper function constructs SPARQL Update query from resolved arguments.
   * 
   * @param ds: deletions array.
   * @param is: insertions array.
   * @param bnodes_context: Additional context to uniquely identify any blank nodes.
   */
  constructSparqlUpdateQuery(ds, is, bnodes_context) {
    var whereClause = this.contextWhere(bnodes_context);
    var query = "";
    if (whereClause.length) {
      if (ds.length) {
        query += "DELETE { ";
        for (let i = 0; i < ds.length; i++) {
          query += this.anonymizeNT(ds[i]) + "\n";
        }
        query += " }\n";
      }
      if (is.length) {
        query += "INSERT { ";
        for (let i = 0; i < is.length; i++) {
          query += this.anonymizeNT(is[i]) + "\n";
        }
        query += " }\n";
      }
      query += whereClause;
    } else {
      if (ds.length) {
        query += "DELETE DATA { ";
        for (let i = 0; i < ds.length; i++) {
          query += this.anonymizeNT(ds[i]) + "\n";
        }
        query += " } \n";
      }
      if (is.length) {
        if (ds.length) query += " ; ";
        query += "INSERT DATA { ";
        for (let i = 0; i < is.length; i++) {
          query += this.nTriples(is[i]) + "\n";
        }
        query += " }\n";
      }
    }
    return query;
  }
  /**
   * @private
   * 
   * This helper function constructs n3-patch query from resolved arguments.
   * 
   * @param ds: deletions array.
   * @param is: insertions array.
   * @param bnodes_context: Additional context to uniquely identify any blanknodes.
   */
  constructN3PatchQuery(ds, is, bnodes_context) {
    var query = `
@prefix solid: <http://www.w3.org/ns/solid/terms#>.
@prefix ex: <http://www.example.org/terms#>.

_:patch
`;
    if (bnodes_context && bnodes_context.length > 0) {
      query += `
      solid:where {
        ${bnodes_context.map((x) => this.anonymizeNT(x)).join("\n        ")}
      };`;
    }
    if (ds.length > 0) {
      query += `
      solid:deletes {
        ${ds.map((x) => this.anonymizeNT(x)).join("\n        ")}
      };`;
    }
    if (is.length > 0) {
      query += `
      solid:inserts {
        ${is.map((x) => this.anonymizeNT(x)).join("\n        ")}
      };`;
    }
    query += "   a solid:InsertDeletePatch .\n";
    return query;
  }
  /**
   * This high-level function updates the local store if the web is changed successfully.
   * Deletions, insertions may be undefined or single statements or lists or formulae (may contain bnodes which can be indirectly identified by a where clause).
   * The `why` property of each statement must be the same and give the web document to be updated.
   * @param deletions - Statement or statements to be deleted.
   * @param insertions - Statement or statements to be inserted.
   * @param callback - called as callbackFunction(uri, success, errorbody)
   *           OR returns a promise
   * @param options - Options for the fetch call
   */
  update(deletions, insertions, callback, secondTry, options = {}) {
    if (!callback) {
      var thisUpdater = this;
      return new Promise(function(resolve, reject) {
        thisUpdater.update(deletions, insertions, function(uri, ok, errorBody) {
          if (!ok) {
            reject(new Error(errorBody));
          } else {
            resolve();
          }
        }, secondTry, options);
      });
    }
    try {
      var kb = this.store;
      var ds = !deletions ? [] : isStore(deletions) ? deletions.statements : deletions instanceof Array ? deletions : [deletions];
      var is = !insertions ? [] : isStore(insertions) ? insertions.statements : insertions instanceof Array ? insertions : [insertions];
      if (!(ds instanceof Array)) {
        throw new Error("Type Error " + typeof ds + ": " + ds);
      }
      if (!(is instanceof Array)) {
        throw new Error("Type Error " + typeof is + ": " + is);
      }
      if (ds.length === 0 && is.length === 0) {
        return callback(null, true);
      }
      var doc = ds.length ? ds[0].graph : is[0].graph;
      if (!doc) {
        let message = "Error patching: statement does not specify which document to patch:" + ds[0] + ", " + is[0];
        throw new Error(message);
      }
      if (doc.termType !== "NamedNode") {
        let message = "Error patching: document not a NamedNode:" + ds[0] + ", " + is[0];
        throw new Error(message);
      }
      var control = this.patchControlFor(doc);
      var startTime = Date.now();
      var props = ["subject", "predicate", "object", "why"];
      var verbs = ["insert", "delete"];
      var clauses = {
        "delete": ds,
        "insert": is
      };
      verbs.map(function(verb) {
        clauses[verb].map(function(st2) {
          if (!doc.equals(st2.graph)) {
            throw new Error("update: destination " + doc + " inconsistent with delete quad " + st2.graph);
          }
          props.map(function(prop) {
            if (typeof st2[prop] === "undefined") {
              throw new Error("update: undefined " + prop + " of statement.");
            }
          });
        });
      });
      var protocol2 = this.editable(doc.value, kb);
      if (protocol2 === false) {
        throw new Error("Update: Can't make changes in uneditable " + doc);
      }
      if (protocol2 === void 0) {
        if (secondTry) {
          throw new Error("Update: Loaded " + doc + "but still can't figure out what editing protocol it supports.");
        }
        this.store.fetcher.load(doc).then((response) => {
          this.update(deletions, insertions, callback, true, options);
        }, (err) => {
          if (err.response.status === 404) {
            this.update(deletions, insertions, callback, true, options);
          } else {
            throw new Error(`Update: Can't get updatability status ${doc} before patching: ${err}`);
          }
        });
        return;
      } else if (protocol2.indexOf("SPARQL") >= 0 || protocol2.indexOf("N3PATCH") >= 0) {
        var isSparql = protocol2.indexOf("SPARQL") >= 0;
        var bnodes = [];
        if (ds.length) bnodes = this.statementArrayBnodes(ds);
        if (is.length) bnodes = bnodes.concat(this.statementArrayBnodes(is));
        var context = this.bnodeContext(bnodes, doc);
        var query = isSparql ? this.constructSparqlUpdateQuery(ds, is, context) : this.constructN3PatchQuery(ds, is, context);
        options.contentType = isSparql ? "application/sparql-update" : "text/n3";
        control.pendingUpstream = control.pendingUpstream ? control.pendingUpstream + 1 : 1;
        if ("upstreamCount" in control) {
          control.upstreamCount += 1;
        }
        this.fire(doc.value, query, (uri, success, body, response) => {
          response.elapsedTimeMs = Date.now() - startTime;
          if (success) {
            try {
              kb.remove(ds);
            } catch (e) {
              success = false;
              body = "Remote Ok BUT error deleting " + ds.length + " from store!!! " + e;
            }
            for (let i = 0; i < is.length; i++) {
              kb.add(is[i].subject, is[i].predicate, is[i].object, doc);
            }
          }
          callback(uri, success, body, response);
          control.pendingUpstream -= 1;
          if (control.pendingUpstream === 0 && control.downstreamAction) {
            var downstreamAction = control.downstreamAction;
            delete control.downstreamAction;
            downstreamAction(doc);
          }
        }, options);
      } else if (protocol2.indexOf("DAV") >= 0) {
        this.updateDav(doc, ds, is, callback, options);
      } else {
        if (protocol2.indexOf("LOCALFILE") >= 0) {
          try {
            this.updateLocalFile(doc, ds, is, callback, options);
          } catch (e) {
            callback(
              doc.value,
              false,
              "Exception trying to write back file <" + doc.value + ">\n"
              // + tabulator.Util.stackString(e))
            );
          }
        } else {
          throw new Error("Unhandled edit method: '" + protocol2 + "' for " + doc);
        }
      }
    } catch (e) {
      callback(void 0, false, "Exception in update: " + e + "\n" + stackString(e));
    }
  }
  updateDav(doc, ds, is, callbackFunction, options = {}) {
    let kb = this.store;
    var request = kb.any(doc, this.ns.link("request"));
    if (!request) {
      throw new Error("No record of our HTTP GET request for document: " + doc);
    }
    var response = kb.any(request, this.ns.link("response"));
    if (!response) {
      return null;
    }
    var contentType = kb.the(response, this.ns.httph("content-type")).value;
    let newSts = kb.statementsMatching(void 0, void 0, void 0, doc).slice();
    for (let i = 0; i < ds.length; i++) {
      RDFArrayRemove(newSts, ds[i]);
    }
    for (let i = 0; i < is.length; i++) {
      newSts.push(is[i]);
    }
    const documentString = this.serialize(doc.value, newSts, contentType);
    var candidateTarget = kb.the(response, this.ns.httph("content-location"));
    var targetURI;
    if (candidateTarget) {
      targetURI = join(candidateTarget.value, targetURI);
    }
    options.contentType = contentType;
    options.noMeta = true;
    options.body = documentString;
    return kb.fetcher.webOperation("PUT", targetURI, options).then((response2) => {
      if (!response2.ok) {
        throw new Error(response2.error);
      }
      for (let i = 0; i < ds.length; i++) {
        kb.remove(ds[i]);
      }
      for (let i = 0; i < is.length; i++) {
        kb.add(is[i].subject, is[i].predicate, is[i].object, doc);
      }
      callbackFunction(doc.value, response2.ok, response2.responseText, response2);
    }).catch((err) => {
      callbackFunction(doc.value, false, err.message, err);
    });
  }
  /**
   * Likely deprecated, since this lib no longer deals with browser extension
   *
   * @param doc
   * @param ds
   * @param is
   * @param callbackFunction
   * @param options
   */
  updateLocalFile(doc, ds, is, callbackFunction, options = {}) {
    const kb = this.store;
    let newSts = kb.statementsMatching(void 0, void 0, void 0, doc).slice();
    for (let i = 0; i < ds.length; i++) {
      RDFArrayRemove(newSts, ds[i]);
    }
    for (let i = 0; i < is.length; i++) {
      newSts.push(is[i]);
    }
    var dot = doc.value.lastIndexOf(".");
    if (dot < 1) {
      throw new Error("Rewriting file: No filename extension: " + doc.value);
    }
    var ext = doc.value.slice(dot + 1);
    let contentType = Fetcher.CONTENT_TYPE_BY_EXT[ext];
    if (!contentType) {
      throw new Error("File extension ." + ext + " not supported for data write");
    }
    options.body = this.serialize(doc.value, newSts, contentType);
    options.contentType = contentType;
    kb.fetcher.webOperation("PUT", doc.value, options).then((response) => {
      if (!response.ok) return callbackFunction(doc.value, false, response.error);
      for (let i = 0; i < ds.length; i++) {
        kb.remove(ds[i]);
      }
      for (let i = 0; i < is.length; i++) {
        kb.add(is[i].subject, is[i].predicate, is[i].object, doc);
      }
      callbackFunction(doc.value, true, "");
    });
  }
  /**
   * @throws {Error} On unsupported content type
   *
   * @returns {string}
   */
  serialize(uri, data, contentType) {
    const kb = this.store;
    let documentString;
    if (typeof data === "string") {
      return data;
    }
    var sz = createSerializer(kb);
    sz.suggestNamespaces(kb.namespaces);
    sz.setBase(uri);
    switch (contentType) {
      case "text/xml":
      case "application/rdf+xml":
        documentString = sz.statementsToXML(data);
        break;
      case "text/n3":
      case "text/turtle":
      case "application/x-turtle":
      // Legacy
      case "application/n3":
        documentString = sz.statementsToN3(data);
        break;
      default:
        throw new Error("Content-type " + contentType + " not supported for data serialization");
    }
    return documentString;
  }
  /**
   * This is suitable for an initial creation of a document.
   */
  put(doc, data, contentType, callback) {
    const kb = this.store;
    let documentString;
    return Promise.resolve().then(() => {
      documentString = this.serialize(doc.value, data, contentType);
      return kb.fetcher.webOperation("PUT", doc.value, {
        contentType,
        body: documentString
      });
    }).then((response) => {
      if (!response.ok) {
        return callback(doc.value, response.ok, response.error, response);
      }
      delete kb.fetcher.nonexistent[doc.value];
      delete kb.fetcher.requested[doc.value];
      if (typeof data !== "string") {
        data.map((st2) => {
          kb.addStatement(st2);
        });
      }
      callback(doc.value, response.ok, "", response);
    }).catch((err) => {
      callback(doc.value, false, err.message);
    });
  }
  /**
   * Reloads a document.
   *
   * Fast and cheap, no metadata. Measure times for the document.
   * Load it provisionally.
   * Don't delete the statements before the load, or it will leave a broken
   * document in the meantime.
   *
   * @param kb
   * @param doc {RDFlibNamedNode}
   * @param callbackFunction
   */
  reload(kb, doc, callbackFunction) {
    var startTime = Date.now();
    const options = {
      force: true,
      noMeta: true,
      clearPreviousData: true
    };
    kb.fetcher.nowOrWhenFetched(doc.value, options, function(ok, body, response) {
      if (!ok) {
        callbackFunction(false, "Error reloading data: " + body, response);
      } else if (response.onErrorWasCalled || response.status !== 200) {
        callbackFunction(false, "Non-HTTP error reloading data: " + body, response);
      } else {
        var elapsedTimeMs = Date.now() - startTime;
        if (!doc.reloadTimeTotal) doc.reloadTimeTotal = 0;
        if (!doc.reloadTimeCount) doc.reloadTimeCount = 0;
        doc.reloadTimeTotal += elapsedTimeMs;
        doc.reloadTimeCount += 1;
        callbackFunction(true);
      }
    });
  }
};

// node_modules/rdflib/esm/factories/rdflib-data-factory.js
var RDFlibDataFactory = {
  ...extended_term_factory_default,
  /**
   * Creates a new fetcher
   * @param store - The store to use
   * @param options - The options
   */
  fetcher(store, options) {
    return new Fetcher(store, options);
  },
  /**
   * Creates a new graph (store)
   */
  graph(features = void 0, opts = void 0) {
    return new IndexedFormula(features, opts || {
      rdfFactory: extended_term_factory_default
    });
  },
  /**
   * Creates a new literal node
   * @param val The lexical value
   * @param lang The language
   * @param dt The datatype
   */
  lit(val, lang, dt) {
    return this.literal("" + val, lang || dt);
  },
  /**
   * Creates a new statement
   * @param subject The subject
   * @param predicate The predicate
   * @param object The object
   * @param graph The containing graph
   */
  st(subject, predicate, object, graph2) {
    return this.quad(subject, predicate, object, graph2);
  }
};
var rdflib_data_factory_default = RDFlibDataFactory;

// node_modules/rdflib/esm/updates-via.js
var UpdatesSocket = class {
  constructor(parent, via) {
    this.parent = parent;
    this.via = via;
    this.connected = false;
    this.pending = {};
    this.subscribed = {};
    this.socket = {};
    try {
      this.socket = new WebSocket(via);
      this.socket.onopen = this.onOpen;
      this.socket.onclose = this.onClose;
      this.socket.onmessage = this.onMessage;
      this.socket.onerror = this.onError;
    } catch (error) {
      this.onError(error);
    }
  }
  _decode(q) {
    var elt;
    var i;
    var k;
    var r;
    var ref;
    var ref1;
    var v;
    r = {};
    ref = function() {
      var j, len, ref2, results;
      ref2 = q.split("&");
      results = [];
      for (j = 0, len = ref2.length; j < len; j++) {
        elt = ref2[j];
        results.push(elt.split("="));
      }
      return results;
    }();
    for (i in ref) {
      elt = ref[i];
      ref1 = [decodeURIComponent(elt[0]), decodeURIComponent(elt[1])];
      k = ref1[0];
      v = ref1[1];
      if (r[k] == null) {
        r[k] = [];
      }
      r[k].push(v);
    }
    return r;
  }
  _send(method, uri, data) {
    var base, message;
    message = [method, uri, data].join(" ");
    return typeof (base = this.socket).send === "function" ? base.send(message) : void 0;
  }
  _subscribe(uri) {
    this._send("sub", uri, "");
    this.subscribed[uri] = true;
    return this.subscribed[uri];
  }
  onClose(e) {
    var uri;
    this.connected = false;
    for (uri in this.subscribed) {
      this.pending[uri] = true;
    }
    this.subscribed = {};
    return this.subscribed;
  }
  onError(e) {
    throw new Error("onError" + e);
  }
  onMessage(e) {
    var base, message;
    message = e.data.split(" ");
    if (message[0] === "ping") {
      return typeof (base = this.socket).send === "function" ? base.send("pong " + message.slice(1).join(" ")) : void 0;
    } else if (message[0] === "pub") {
      return this.parent.onUpdate(message[1], this._decode(message[2]));
    }
  }
  onOpen(e) {
    var results, uri;
    this.connected = true;
    results = [];
    for (uri in this.pending) {
      delete this.pending[uri];
      results.push(this._subscribe(uri));
    }
    return results;
  }
  subscribe(uri) {
    if (this.connected) {
      return this._subscribe(uri);
    } else {
      this.pending[uri] = true;
      return this.pending[uri];
    }
  }
};
var UpdatesVia = class {
  constructor(fetcher2) {
    this.fetcher = fetcher2;
    this.graph = {};
    this.via = {};
    this.fetcher.addCallback("headers", this.onHeaders);
  }
  onHeaders(d) {
    var etag, uri, via;
    if (d.headers == null) {
      return true;
    }
    if (typeof WebSocket === "undefined" || WebSocket === null) {
      return true;
    }
    etag = d.headers["etag"];
    via = d.headers["updates-via"];
    uri = d.uri;
    if (etag && via) {
      this.graph[uri] = {
        etag,
        via
      };
      this.register(via, uri);
    }
    return true;
  }
  onUpdate(uri, d) {
    return this.fetcher.refresh(rdflib_data_factory_default.namedNode(uri));
  }
  register(via, uri) {
    if (this.via[via] == null) {
      this.via[via] = new UpdatesSocket(this, via);
    }
    return this.via[via].subscribe(uri);
  }
};

// node_modules/rdflib/esm/index.js
var boundDataFactory = {};
for (const name in rdflib_data_factory_default) {
  if (typeof rdflib_data_factory_default[name] === "function") boundDataFactory[name] = rdflib_data_factory_default[name].bind(rdflib_data_factory_default);
}
var {
  fetcher,
  graph,
  lit,
  st,
  namedNode,
  variable: variable2,
  blankNode: blankNode2,
  defaultGraph: defaultGraph4,
  literal: literal2,
  quad: quad2,
  triple
} = boundDataFactory;
var formula = new Formula();
var fromNT = (str) => formula.fromNT(str);
var term = node_default.fromValue;
var NextId = BlankNode.nextId;
var ConnectedStore = class extends IndexedFormula {
  constructor(features) {
    super(features);
    _defineProperty(this, "fetcher", void 0);
    this.fetcher = new Fetcher(this, {});
  }
};
var LiveStore = class extends ConnectedStore {
  constructor(features) {
    super(features);
    _defineProperty(this, "updater", void 0);
    this.updater = new UpdateManager(this);
  }
};
export {
  BlankNode,
  Collection,
  ConnectedStore,
  rdflib_data_factory_default as DataFactory,
  Empty,
  Fetcher,
  Formula,
  IndexedFormula,
  Literal,
  LiveStore,
  n3parser_default as N3Parser,
  NamedNode,
  Namespace,
  NextId,
  node_default as Node,
  Query,
  RDFParser,
  RDFaProcessor,
  SPARQLToQuery,
  createSerializer as Serializer,
  Statement,
  IndexedFormula as Store,
  UpdateManager,
  UpdatesSocket,
  UpdatesVia,
  utils_js_exports as Util,
  Variable,
  blankNode2 as blankNode,
  defaultGraph4 as defaultGraph,
  fetcher,
  fromNT,
  graph,
  isBlankNode,
  isCollection,
  isGraph,
  isLiteral,
  isNamedNode,
  isPredicate,
  isQuad,
  isRDFObject,
  isRDFlibObject,
  isRDFlibPredicate,
  isRDFlibSubject,
  isStatement,
  isStore,
  isSubject,
  isTerm,
  isVariable,
  jsonparser_default as jsonParser,
  lit,
  literal2 as literal,
  log_default as log,
  namedNode,
  parse2 as parse,
  quad2 as quad,
  queryToSPARQL,
  serialize,
  sparqlUpdateParser,
  st,
  namedNode as sym,
  term,
  termValue,
  triple,
  uri_exports as uri,
  variable2 as variable
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=rdflib.js.map
